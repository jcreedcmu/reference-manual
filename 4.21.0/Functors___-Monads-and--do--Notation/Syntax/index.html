<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Syntax</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="current numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">20.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-monads-and-do" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-monads-and-do" checked="checked"></label><span class="number">14.</span> <span class=""><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></span></div>
              <table><tr class="numbered"><td class="num">14.1.</td><td><a href="Functors___-Monads-and--do--Notation/Laws/#monad-laws">Laws</a></td></tr><tr class="numbered"><td class="num">14.2.</td><td><a href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads">Lifting Monads</a></td></tr><tr class="current numbered"><td class="num">14.3.</td><td><a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax">Syntax</a></td></tr><tr class="numbered"><td class="num">14.4.</td><td><a href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference">API Reference</a></td></tr><tr class="numbered"><td class="num">14.5.</td><td><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties">Varieties of Monads</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax" checked="checked"></label><span class="number">14.3.</span> <span class="current"><a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax">Syntax</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators">Infix Operators</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors">Functors</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;$&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;&&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors">Applicative Functors</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;*&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term_____GT___FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">*&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT______FLQQ_-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;*</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____GT___FLQQ_-next-next-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;|&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">1.3.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads">Monads</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__GT__GT______FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&gt;&gt;=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term_____LT__LT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&lt;&lt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__GT_____GT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&gt;=&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#_FLQQ_term__LT_____LT___FLQQ_"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">&lt;=&lt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#do-notation"><code>do</code>-Notation</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><span class="syntax"><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations">Sequential Computations</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return">Early Return</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">return</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">return</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State">Local Mutable State</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="keyword">mut</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">let</span><span class="ws"> </span><span class="keyword">mut</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassign"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassign-next"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassignArrow"><span class="syntax"><span class="meta">…</span><span class="meta">(</span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doReassignArrow-next"><span class="syntax"><span class="meta">…</span><span class="ws"> </span><span class="keyword">←</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.4.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#do-control-structures">Control Structures</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">if</span><span class="ws"> </span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">then</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">else</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)?</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">unless</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">match</span><span class="ws"> </span><span class="meta">(</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="meta">),*</span><span class="ws"> </span><span class="keyword">with</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.5.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#monad-iteration-syntax">Iteration</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">for</span><span class="ws"> </span><span class="meta">(</span><span class="meta">(</span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">in</span><span class="ws"> </span><span class="meta">…</span><span class="meta">),*</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">while</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">while</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">do</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">repeat</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">until</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">repeat</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">continue</span></span></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="syntax"><span class="keyword">break</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.6.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#closest-do-block">Identifying <code>do</code> Blocks</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.7.</span> <a href="Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration">Type Classes for Iteration</a></span></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk"><code>ForIn</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk"><code>ForIn'</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done"><code>ForInStep</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___value"><code>value</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk"><code>ForM</code></a></li>
                <li>
                  <a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___forIn"><code>forIn</code></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads" rel="prev" title="14.2. Lifting Monads"><span class="arrow">←</span><span class="where">14.2. Lifting Monads</span></a><a class="local-button active" href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference" rel="next" title="14.4. API Reference"><span class="where">14.4. API Reference</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              14.3. Syntax</h1>
            <p>
              Lean supports programming with functors, applicative functors, and monads via special syntax:</p>
            <ul>
              <li>
                <p>
                  Infix operators are provided for the most common operations.</p>
                </li>
              <li>
                <p>
                  An embedded language called <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a> allows the use of imperative syntax when writing programs in a monad.</p>
                </li>
              </ul>
            <section>
              <h2 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators">
                14.3.1. Infix Operators</h2>
              <p>
                Infix operators are primarily useful in smaller expressions, or when there is no <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a></code> instance.</p>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors">
                  14.3.1.1. Functors</h3>
                <p>
                  There are two infix operators for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk" title="Documentation for Functor.map"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1296">Functor.map</span></a></code>.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Functor Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.429" data-verso-hover="306">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;$&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.431" data-verso-hover="2715">x</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk" title="Documentation for Functor.map"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1296">Functor.map</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.471" data-verso-hover="306">g</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.473" data-verso-hover="2715">x</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<$>_»"><code class="hover-info"><code class="docstring">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.

When mapping a constant function, use `Functor.mapConst` instead, because it may be more
efficient.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;$&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.507" data-verso-hover="2715">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;&&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.505" data-verso-hover="306">g</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk" title="Documentation for Functor.map"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1296">Functor.map</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.547" data-verso-hover="306">g</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.549" data-verso-hover="2715">x</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<&amp;>_»"><code class="hover-info"><code class="docstring">Maps a function over a functor, with parameters swapped so that the function comes last.

This function is `Functor.map` with the parameters reversed, typically used via the `&lt;&&gt;` operator.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;&&gt;` in identifiers is `mapRev`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;&&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors">
                  14.3.1.2. Applicative Functors</h3>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Applicative Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1226" data-verso-hover="2815">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;*&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1228" data-verso-hover="2715">x</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Seq___mk" title="Documentation for Seq.seq"><span class="const token" data-binding="const-Seq.seq" data-verso-hover="2732">Seq.seq</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1295" data-verso-hover="2815">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1800">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1297" data-verso-hover="2715">x</span><span class="unknown token" data-binding="">)</span></code>.
The function is inserted to delay evaluation because control might not reach the argument.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<*>_»"><code class="hover-info"><code class="docstring">The implementation of the `&lt;*&gt;` operator.

In a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the
function first, then the argument, and applies one to the other.

To avoid surprising evaluation semantics, `mx` is taken "lazily", using a `Unit → f α` function.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;*&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1363" data-verso-hover="2715">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1369" data-verso-hover="2738">e2</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#SeqRight___mk" title="Documentation for SeqRight.seqRight"><span class="const token" data-binding="const-SeqRight.seqRight" data-verso-hover="2807">SeqRight.seqRight</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1432" data-verso-hover="2715">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1991">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1438" data-verso-hover="2738">e2</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term_____GT___FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_*>_»"><code class="hover-info"><code class="docstring">Sequences the effects of two terms, discarding the value of the first. This function is usually
invoked via the `*&gt;` operator.

Given `x : f α` and `y : f β`, `x *&gt; y` runs `x`, then runs `y`, and finally returns the result of
`y`.

The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `*&gt;` in identifiers is `seqRight`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">*&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1496" data-verso-hover="2715">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1502" data-verso-hover="2738">e2</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#SeqLeft___mk" title="Documentation for SeqLeft.seqLeft"><span class="const token" data-binding="const-SeqLeft.seqLeft" data-verso-hover="2806">SeqLeft.seqLeft</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="2715">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2089">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1571" data-verso-hover="2738">e2</span><span class="unknown token" data-binding="">)</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT______FLQQ_-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<*_»"><code class="hover-info"><code class="docstring">Sequences the effects of two terms, discarding the value of the second. This function is usually
invoked via the `&lt;*` operator.

Given `x : f α` and `y : f β`, `x &lt;* y` runs `x`, then runs `y`, and finally returns the result of
`x`.

The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `&lt;*` in identifiers is `seqLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;*</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                <p>
                  Many applicative functors also support failure and recovery via the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Alternative___mk" title="Documentation for Alternative"><span class="const token" data-binding="const-Alternative" data-verso-hover="2714">Alternative</span></a></code> type class.
This class also has an infix operator.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Alternative Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2586" data-verso-hover="2715">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;|&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2588" data-verso-hover="2715">e'</span></code> is short for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-OrElse.orElse" data-verso-hover="2893">OrElse.orElse</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2690" data-verso-hover="2715">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2378">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2692" data-verso-hover="2715">e'</span><span class="unknown token" data-binding="">)</span></code>.
The function is inserted to delay evaluation because control might not reach the argument.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____GT___FLQQ_-next-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<|>_»"><code class="hover-info"><code class="docstring">`a &lt;|&gt; b` executes `a` and returns the result, unless it fails in which
case it executes and returns `b`. Because `b` is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent. 

Conventions for notations in identifiers:

 * The recommended spelling of `&lt;|&gt;` in identifiers is `orElse`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;|&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-2827">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-User" data-verso-hover="2894">User</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-2842">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-User.name" data-verso-hover="2895">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-User.favoriteNat" data-verso-hover="2896">favoriteNat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2884">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="2897">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/#Pure___mk" title="Documentation for Pure.pure"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1146">pure</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><details class="example"><summary class="description">Infix <code>Functor</code> and <code>Applicative</code> Operators</summary><div class="example-content">
                    <p>
                      A common functional programming idiom is to use a pure function in some context with effects by applying it via <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Functor___mk" title="Documentation for Functor.map"><span class="const token" data-binding="const-Functor.map" data-verso-hover="1296">Functor.map</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Seq___mk" title="Documentation for Seq.seq"><span class="const token" data-binding="const-Seq.seq" data-verso-hover="2732">Seq.seq</span></a></code>.
The function is applied to its sequence of arguments using <code>&lt;$&gt;</code>, and the arguments are separated by <code>&lt;*&gt;</code>.</p>
                    <p>
                      In this example, the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-User.mk" data-verso-hover="2898">User.mk</span></code> is applied via this idiom in the body of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="2897">main</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-getName" data-verso-hover="2899" id="main-next">getName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-27">do</span></a><span class="inter-text">
  </span><a href="IO/Console-Output/#IO___println" title="Documentation for IO.println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2900">"What is your name?"</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-66" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="IO/Files___-File-Handles___-and-Streams/#IO___getStdin" title="Documentation for IO.getStdin"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="2901">IO.getStdin</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="IO/Files___-File-Handles___-and-Streams/#IO___FS___Stream___mk" title="Documentation for IO.FS.Stream.getLine"><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="2902">getLine</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___trimRight" title="Documentation for String.trimRight"><span class="const token" data-binding="const-String.trimRight" data-verso-hover="2903">trimRight</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-116">partial</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-124">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2904" id="main-next">getFavoriteNat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-155">do</span></a><span class="inter-text">
  </span><a href="IO/Console-Output/#IO___println" title="Documentation for IO.println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2905">"What is your favorite natural number?"</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-213">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.548" data-verso-hover="144">line</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="IO/Files___-File-Handles___-and-Streams/#IO___getStdin" title="Documentation for IO.getStdin"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="2901">IO.getStdin</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="IO/Files___-File-Handles___-and-Streams/#IO___FS___Stream___mk" title="Documentation for IO.FS.Stream.getLine"><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="2902">getLine</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-254">if</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIfLet-257">let</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.567" data-verso-hover="7">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.548" data-verso-hover="144">line</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___trim" title="Documentation for String.trim"><span class="const token" data-binding="const-String.trim" data-verso-hover="2906">trim</span></a><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Strings/#String___toNat___" title="Documentation for String.toNat?"><span class="const token" data-binding="const-String.toNat?" data-verso-hover="2907">toNat?</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-254">then</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-297" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.567" data-verso-hover="7">n</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-null-308">else</span><span class="inter-text">
    </span><a href="IO/Console-Output/#IO___println" title="Documentation for IO.println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2908">"Let's try again."</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Syntax/#main-next" title="Definition of example getFavoriteNat"><span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2904">getFavoriteNat</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-367">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-User" data-verso-hover="2894">User</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-382">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-User.name" data-verso-hover="2895">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="141">String</span></a><span class="inter-text">
  </span><span class="const token" data-binding="const-User.favoriteNat" data-verso-hover="2896">favoriteNat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-424">deriving</span><span class="inter-text"> </span><a href="Interacting-with-Lean/#Repr___mk" title="Documentation for Repr"><span class="const token" data-binding="const-Repr" data-verso-hover="67">Repr</span></a><span class="inter-text">

</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-439">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="2897">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="1">IO</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-461">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-466">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2180" data-verso-hover="2909">user</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-User.mk" data-verso-hover="2898">User.mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;$&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#main-next" title="Definition of example getName"><span class="const token" data-binding="const-getName" data-verso-hover="2899">getName</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;*&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#main-next" title="Definition of example getFavoriteNat"><span class="const token" data-binding="const-getFavoriteNat" data-verso-hover="2904">getFavoriteNat</span></a><span class="inter-text">
  </span><a href="IO/Console-Output/#IO___println" title="Documentation for IO.println"><span class="const token" data-binding="const-IO.println" data-verso-hover="4">IO.println</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Interacting-with-Lean/#repr-next" title="Documentation for repr"><span class="const token" data-binding="const-repr" data-verso-hover="230">repr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2180" data-verso-hover="2909">user</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      When run with this input:</p>
                    <div class="example-file">
                      <code>stdin</code><code class="line">A. Lean User</code><code class="line">None</code><code class="line">42</code></div>
                    <p>
                      it produces this output:</p>
                    <div class="example-file">
                      <code>stdout</code><code class="line">What is your name?</code><code class="line">What is your favorite natural number?</code><code class="line">Let's try again.</code><code class="line">What is your favorite natural number?</code><code class="line">{ name := "A. Lean User", favoriteNat := 42 }</code></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Monads">
                  14.3.1.3. Monads</h3>
                <p>
                  Monads are primarily used via <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-notation"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</a>.
However, it can sometimes be convenient to describe monadic computations via operators.</p>
                <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Monad Operators</span><div class="text">
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.4174" data-verso-hover="370">act</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4178" data-verso-hover="2800">f</span></code> is syntax for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk" title="Documentation for Bind.bind"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1285">Bind.bind</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4253" data-verso-hover="370">act</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4257" data-verso-hover="2800">f</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__GT__GT______FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_>>=_»"><code class="hover-info"><code class="docstring">Sequences two computations, allowing the second to depend on the value computed by the first.

If `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get
a value of type `α` and then passing it to `f`.


Conventions for notations in identifiers:

 * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&gt;&gt;=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      Similarly, the reversed operator <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.4326" data-verso-hover="2800">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&lt;&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4322" data-verso-hover="370">act</span></code> is syntax for <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk" title="Documentation for Bind.bind"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1285">Bind.bind</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4400" data-verso-hover="370">act</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4404" data-verso-hover="2800">f</span></code>.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term_____LT__LT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_=<<_»"><code class="hover-info"><code class="docstring">Same as `Bind.bind` but with arguments swapped. 

Conventions for notations in identifiers:

 * The recommended spelling of `=&lt;&lt;` in identifiers is `bindLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">=&lt;&lt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><p>
                      The Kleisli composition operators <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/API-Reference/#Bind___kleisliRight" title="Documentation for Bind.kleisliRight"><span class="const token" data-binding="const-Bind.kleisliRight" data-verso-hover="2910">Bind.kleisliRight</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/API-Reference/#Bind___kleisliLeft" title="Documentation for Bind.kleisliLeft"><span class="const token" data-binding="const-Bind.kleisliLeft" data-verso-hover="2911">Bind.kleisliLeft</span></a></code> also have infix operators.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__GT_____GT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_>=>_»"><code class="hover-info"><code class="docstring">Left-to-right composition of Kleisli arrows. 

Conventions for notations in identifiers:

 * The recommended spelling of `&gt;=&gt;` in identifiers is `kleisliRight`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&gt;=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="_FLQQ_term__LT_____LT___FLQQ_"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal documented" data-kind="«term_<=<_»"><code class="hover-info"><code class="docstring">Right-to-left composition of Kleisli arrows. 

Conventions for notations in identifiers:

 * The recommended spelling of `&lt;=&lt;` in identifiers is `kleisliLeft`.</code></code><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">&lt;=&lt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></pre></div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="do-notation">
                14.3.2. <code>do</code>-Notation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=do-notation" title="Permalink">🔗</a></span></h2>
              <p>
                Monads are primarily used via <span id="--tech-term-do-notation" class="def-technical-term"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation</span>, which is an embedded language for programming in an imperative style.
It provides familiar syntax for sequencing effectful operations, early return, local mutable variables, loops, and exception handling.
All of these features are translated to the operations of the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a></code> type class, with a few of them requiring addition instances of classes such as <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn"><span class="const token" data-binding="const-ForIn" data-verso-hover="2912">ForIn</span></a></code> that specify iteration over containers.
For more details about the design of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation, please consult Ullrich and de Moura (2022)<span class="marginalia"><span class="note"><span class="citation">Sebastian Ullrich and Leonardo de Moura, 2022. <a href="https://dl.acm.org/doi/10.1145/3547640">“<code>do</code> Unchained: Embracing Local Imperativity in a Purely Functional Language”</a>. In <em>Proceedings of the ACM on Programming Languages: ICFP 2022.</em></span></span></span>.
A <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> term consists of the keyword <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> followed by a sequence of <span id="--tech-term-do-items" class="def-technical-term"><em><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items</em></span>.</p>
              <div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title"><code>do</code>-Notation</span><div class="text">
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___do"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.do"><span class="keyword">do</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span></pre><p>
                    The items in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> may be separated by semicolons; otherwise, each should be on its own line and they should have equal indentation.</p>
                  </div>
                </div>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Sequential-Computations">
                  14.3.2.1. Sequential Computations</h3>
                <p>
                  One form of <a class="technical-term" href="Functors___-Monads-and--do--Notation/Syntax/#--tech-term-do-items"><span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> item</a> is a term.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem">
                  <span class="label">syntax</span><span class="title">Terms in <code>do</code>-Notation</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  A term followed by a sequence of items is translated to a use of <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk" title="Documentation for Bind.bind"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1285">bind</span></a></code>; in particular, <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6693">do</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7400" data-verso-hover="2913">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6735">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6745">do</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7404" data-verso-hover="370">es</span></code>.</p>
                <table class="tabular"><thead><tr><th><p>
                          <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                        </th><th><p>
                          Desugaring
</p>
                        </th></tr></thead><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6865">do</span></a><span class="inter-text">
</span><span class="unknown token" data-binding="">e1</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7682" data-verso-hover="2913">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-6917">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6927">do</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7686" data-verso-hover="370">es</span></code></td></tr></table><p>
                  The result of the term's computation may also be named, allowing it to be used in subsequent steps.
This is done using <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next">
                  <span class="label">syntax</span><span class="title">Data Dependence in <code>do</code>-Notation</span><div class="text">
                    <p>
                      There are two forms of monadic <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span>-binding in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.
The first binds an identifier to the result, with an optional type annotation:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      The second binds a pattern to the result.
The fallback clause, beginning with <code>|</code>, specifies the behavior when the pattern does not match the result.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.doSeq.pseudo">doSeq</span></span><span class="bnf">)?</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  This syntax is also translated to a use of <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk" title="Documentation for Bind.bind"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1285">bind</span></a></code>.
<code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8018">do</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8021">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9309" data-verso-hover="2820">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8070">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9340" data-verso-hover="311">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8079">do</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9307" data-verso-hover="370">es</span></code>, and fallback clauses are translated to default pattern matches.
<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let</code></span> may also be used with the standard definition syntax <code>:=</code> instead of <code>←</code>.
This indicates a pure, rather than monadic, definition:</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Definitions in <code>do</code>-Notation</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLet"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.letDecl"><code class="hover-info"><code class="docstring">`letDecl` matches the body of a let declaration `let f x1 x2 := e`,
`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 =&gt; e1 | pat2 =&gt; e2 ...`
(a pattern matching declaration), except for the `let` keyword itself.
`let rec` declarations are not handled here. </code></code><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes/#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8452">do</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-8455">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">es</span></code> is translated to <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8495" data-verso-hover="109">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10181" data-verso-hover="311">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10153" data-verso-hover="311">e</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8507">do</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">es</span></code>.</p>
                <table class="tabular"><thead><tr><th><p>
                          <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                        </th><th><p>
                          Desugaring
</p>
                        </th></tr></thead><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8626">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8633">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.10429" data-verso-hover="2820">e1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8688">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10460" data-verso-hover="311">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8703">do</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10427" data-verso-hover="370">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8739">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-8746">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1?</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">fallback</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.10701" data-verso-hover="2914">e1?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;&gt;=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-8825">fun</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="46">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10745" data-verso-hover="311">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8847">do</span></a><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.10696" data-verso-hover="370">es</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10703" data-verso-hover="370">fallback</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8913">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-8920">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-8966" data-verso-hover="109">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10926" data-verso-hover="311">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10898" data-verso-hover="311">e</span><span class="inter-text">
</span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-8981">do</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">es</span></code></td></tr></table><p>
                  Within a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <code>←</code> may be used as a prefix operator.
The expression to which it is applied is replaced with a fresh variable, which is bound using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Bind___mk" title="Documentation for Bind.bind"><span class="const token" data-binding="const-Bind.bind" data-verso-hover="1285">bind</span></a></code> just before the current step.
This allows monadic effects to be used in positions that otherwise might expect a pure value, while still maintaining the distinction between <em>describing</em> an effectful computation and actually <em>executing</em> its effects.
Multiple occurrences of <code>←</code> are processed from left to right, inside to outside.</p>
                <figure><table class="tabular"><thead><tr><th><p>
                            Example <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                          </th><th><p>
                            Desugaring
</p>
                          </th></tr></thead><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10175">do</span></a><span class="inter-text">
</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10237">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10244">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10261">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e2</span><span class="inter-text">
</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10321">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-10328">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10391">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10398">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e1</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10415">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-10433">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">g</span><span class="inter-text"> </span><span class="unknown token" data-binding="">z</span><span class="inter-text">
</span><span class="unknown token" data-binding="">es</span></code></td></tr></table><figcaption>Example Nested Action Desugarings</figcaption></figure><p>
                  In addition to convenient support for sequential computations with data dependencies, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation also supports the local addition of a variety of effects, including early return, local mutable state, and loops with early termination.
These effects are implemented via transformations of the entire <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block in a manner akin to <a class="technical-term" href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#--tech-term-monad-transformer">monad transformers</a>, rather than via a local desugaring.</p>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Early-Return">
                  14.3.2.2. Early Return</h3>
                <p>
                  Early return terminates a computation immediately with a given value.
The value is returned from the closest containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block; however, this may not be the closest <code>do</code> keyword.
The rules for determining the extent of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block are described <a href="Functors___-Monads-and--do--Notation/Syntax/#closest-do-block">in their own section</a>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Early Return</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doReturn"><code class="hover-info"><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><span class="keyword">return</span> <span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doReturn"><code class="hover-info"><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><span class="keyword">return</span><span class="from-nonterminal" data-kind="null"></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  Not all monads include early return.
Thus, when a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block contains <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span>, the code needs to be rewritten to simulate the effect.
A program that uses early return to compute a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14076" data-verso-hover="289">α</span></code> in a monad <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14113" data-verso-hover="79">m</span></code> can be thought of as a program in the monad <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#ExceptT" title="Documentation for ExceptT"><span class="const token" data-binding="const-ExceptT" data-verso-hover="2854">ExceptT</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14169" data-verso-hover="289">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14160" data-verso-hover="79">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14169" data-verso-hover="289">α</span></code>: early-returned values take the exception pathway, while ordinary returns do not.
Then, an outer handler can return the value from either code paths.
Internally, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> elaborator performs a translation very much like this one.</p>
                <p>
                  On its own, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> is short for <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span>​<code> </code>​<code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code>.</p>
                </section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Local-Mutable-State">
                  14.3.2.3. Local Mutable State</h3>
                <p>
                  Local mutable state is mutable state that cannot escape the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block in which it is defined.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doLet : doElem</code></code><code class="kw">let mut</code></span> binder introduces a locally-mutable binding.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Local Mutability</span><div class="text">
                    <p>
                      Mutable bindings may be initialized either with pure computations or with monadic computations:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLet"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">mut</span> </span><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.letDecl"><code class="hover-info"><code class="docstring">`letDecl` matches the body of a let declaration `let f x1 x2 := e`,
`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 =&gt; e1 | pat2 =&gt; e2 ...`
(a pattern matching declaration), except for the `let` keyword itself.
`let rec` declarations are not handled here. </code></code><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes/#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doLetArrow"><span class="keyword">let</span> <span class="from-nonterminal" data-kind="null"><span class="keyword">mut</span> </span><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span> <span class="from-nonterminal" data-kind="null"></span><span class="keyword">←</span> <span class="nonterminal" data-kind="doElem.pseudo">doElem</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><p>
                      Similarly, they can be mutated either with pure values or the results of monad computations:</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassign"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassign"><span class="from-nonterminal" data-kind="Lean.Parser.Term.letIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span>  </span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassign-next"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassign"><span class="from-nonterminal" data-kind="Lean.Parser.Term.letPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">:=</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassignArrow"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassignArrow"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIdDecl"><span class="nonterminal" data-kind="ident">ident</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.typeSpec"><span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)?</span> </span><span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span></span></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doReassignArrow-next"><span class="nonterminal" data-kind="doElem">doElem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doReassignArrow"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doPatDecl"><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">←</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doExpr"><span class="nonterminal" data-kind="term.pseudo">term</span>
        </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">|</span> <span class="nonterminal" data-kind="Lean.Parser.Term.doSeq.pseudo">doSeq</span></span><span class="bnf">)?</span></span></span></span></pre></div>
                  </div>
                <p>
                  These locally-mutable bindings are less powerful than a <a class="technical-term" href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#--tech-term-State-monads">state monad</a> because they are not mutable outside their lexical scope; this also makes them easier to reason about.
When <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks contain mutable bindings, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> elaborator transforms the expression similarly to the way that <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT" title="Documentation for StateT"><span class="const token" data-binding="const-StateT" data-verso-hover="2793">StateT</span></a></code> would, constructing a new monad and initializing it with the correct values.</p>
                </section>
              <section>
                <h3 id="do-control-structures">
                  14.3.2.4. Control Structures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=do-control-structures" title="Permalink">🔗</a></span></h3>
                <p>
                  There are <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items that correspond to most of Lean's term-level control structures.
When they occur as a step in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, they are interpreted as <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items rather than terms.
Each branch of the control structures is a sequence of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> items, rather than a term, and some of them are more syntactically flexible than their corresponding terms.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Conditionals</span><div class="text">
                    <p>
                      In a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span> statements may omit their <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">else</code></span> branch.
Omitting an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">else</code></span> branch is equivalent to using <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Pure___mk" title="Documentation for Pure.pure"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1146">pure</span></a></code><code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> as the contents of the branch.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doIf"><span class="keyword">if</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doIfProp"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span> </span><span class="keyword">then</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span>
      </span></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">else</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="bnf">)?</span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  Syntactically, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">then</code></span> branch cannot be omitted.
For these cases, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> only executes its body when the condition is false.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> in <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> is part of its syntax and does not induce a nested <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Reverse Conditionals</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doUnless"><span class="keyword">unless</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  When <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doMatch : doElem</code></code><code class="kw">match</code></span> is used in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, each branch is considered to be part of the same block.
Otherwise, it is equivalent to the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> term.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Pattern Matching</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doMatch"><span class="keyword">match</span> <span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"></span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.matchDiscr"><code class="hover-info"><code class="docstring">`matchDiscr` matches a "match discriminant", either `h : tm` or `tm`, used in `match` as
`match h1 : e1, e2, h3 : e3 with ...`. </code></code><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="nonterminal" data-kind="ident">ident</span> <span class="bnf">|</span> <a href="Terms/Holes/#Lean___Parser___Term___hole"><span class="nonterminal documented" data-kind="Lean.Parser.Term.hole"><code class="hover-info"><code class="docstring">A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.
For example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.

The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as *unification*.

Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:
* In `match` patterns, holes are catch-all patterns.
* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.

Related concept: implicit parameters are automatically filled in with holes during the elaboration process.

See also `?m` syntax (synthetic holes).
</code></code>hole</span></a><span class="bnf">)</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">),*</span> </span><span class="keyword">with</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="term.pseudo">term</span><span class="bnf">,*</span> </span></span><span class="keyword">=&gt;</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span></span><span class="bnf">)*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                </section>
              <section>
                <h3 id="monad-iteration-syntax">
                  14.3.2.5. Iteration<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=monad-iteration-syntax" title="Permalink">🔗</a></span></h3>
                <p>
                  Within a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>​<code>…</code>​<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loops allow iteration over a data structure.
The body of the loop is part of the containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block, so local effects such as early return and mutable variables may be used.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Iteration over Collections</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doFor"><code class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><span class="keyword">for</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.doForDecl"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span></span><span class="bnf">)?</span> </span><span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">in</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">),*</span> </span><span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  A <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>​<code>…</code>​<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span> loop requires at least one clause that specifies the iteration to be performed, which consists of an optional membership proof name followed by a colon (<code>:</code>), a pattern to bind, the keyword <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">in</code></span>, and a collection term.
The pattern, which may just be an <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-Identifiers">identifier</a>, must match any element of the collection; patterns in this position cannot be used as implicit filters.
Further clauses may be provided by separating them with commas.
Each collection is iterated over at the same time, and iteration stops when any of the collections runs out of elements.</p>
                <details class="example"><summary class="description">Iteration Over Multiple Collections</summary><div class="example-content">
                    <p>
                      When iterating over multiple collections, iteration stops when any of the collections runs out of elements.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">#[(0, 'a'), (1, 'b')]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-17128" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run" title="Documentation for Id.run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1142">Id.run</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-17141">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-17146">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-17150">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.249" data-verso-hover="2915">v</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17165" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.234" data-verso-hover="7">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17169">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">:</span><span class="typed token" data-binding="" data-verso-hover="7">43</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.372" data-verso-hover="352">y</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17182">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">'a'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">'b'</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17165" data-verso-hover="1144">do</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.249" data-verso-hover="2915">v</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.249" data-verso-hover="2915">v</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push" title="Documentation for Array.push"><span class="const token" data-binding="const-Array.push" data-verso-hover="353">push</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.234" data-verso-hover="7">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.372" data-verso-hover="352">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-17226" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.249" data-verso-hover="2915">v</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>#[(0, 'a'), (1, 'b')]
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Iteration over Array Indices with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span></summary><div class="example-content">
                    <p>
                      When iterating over the valid indices for an array with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span>, naming the membership proof allows the tactic that searches for proofs that array indices are in bounds to succeed.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17631">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-satisfyingIndices" data-verso-hover="2916" id="satisfyingIndices">satisfyingIndices</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="597">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="289">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="23">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#DecidablePred" title="Documentation for DecidablePred"><span class="const token" data-binding="const-DecidablePred" data-verso-hover="2917">DecidablePred</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="597">p</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="434">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="286">Array</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="289">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="286">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#Id___run" title="Documentation for Id.run"><span class="const token" data-binding="const-Id.run" data-verso-hover="1142">Id.run</span></a><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-17727">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-17732">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-17736">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="285">out</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17753" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.227" data-verso-hover="1147">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">i</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-17757">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="434">xs</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___size" title="Documentation for Array.size"><span class="const token" data-binding="const-Array.size" data-verso-hover="288">size</span></a><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-17753" data-verso-hover="1144">do</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-17785">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="597">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.63" data-verso-hover="434">xs</span><span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">i</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-17785">then</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="285">out</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="285">out</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push" title="Documentation for Array.push"><span class="const token" data-binding="const-Array.push" data-verso-hover="353">push</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="7">i</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-17821" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="285">out</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Omitting the hypothesis name causes the array lookup to fail, because no proof is available in the context that the iteration variable is within the specified range.</p>
                    </div>
                  </details><p>
                  Iteration with <code>for</code>-loops is translated into uses of <code>ForIn.forIn</code>, which is an analogue of <code>ForM.forM</code> with added support for local mutations and early termination.
<code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> receives an initial value for the local mutable state and a monadic action as parameters, along with the collection being iterated over.
The monadic action passed to <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> takes a current state as a parameter and, after carrying out actions in the monad <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.21937" data-verso-hover="79">m</span></code>, returns either <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a></code> to indicate that iteration should continue with an updated set of local mutable values, or <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a></code> to indicate that <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span> or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> was executed.
When iteration is complete, <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> returns the final values of the local mutable values.</p>
                <p>
                  The specific desugaring of a loop depends on how state and early termination are used in its body.
Here are some examples:</p>
                <table class="tabular"><thead><tr><th><p>
                          <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> Item</p>
                        </th><th><p>
                          Desugaring
</p>
                        </th></tr></thead><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20429">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-20436">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20440">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22457" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-20457" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22451" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-20461">in</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22249" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-20457" data-verso-hover="1144">do</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.22457" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22279" data-verso-hover="2921">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22451" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22457" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.22217" data-verso-hover="370">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20542">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-20549">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22861" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-20566">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23207" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22761" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22861" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-20593">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23074" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23077" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20604">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-20613">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23130" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22791" data-verso-hover="2921">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23074" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23077" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-20635" data-verso-hover="360">return</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23130" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.22729" data-verso-hover="370">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20714">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-20721">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20725">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23518" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-20742" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23512" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-20746">in</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23322" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-20742" data-verso-hover="1144">do</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.23518" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23352" data-verso-hover="2921">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23512" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23518" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doBreak-20781" data-verso-hover="2922">break</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.23290" data-verso-hover="370">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20839">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-20846">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23842" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-20863">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24188" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23742" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23842" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-20890">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24055" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24058" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-20901">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-20910">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24111" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23772" data-verso-hover="2921">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24055" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24058" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-20932" data-verso-hover="360">return</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24111" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.23710" data-verso-hover="370">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21010">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-21017">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21021">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24503" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-21038" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24497" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24494" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-21042">in</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24303" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-21038" data-verso-hover="1144">do</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.24503" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24386" data-verso-hover="2923">f'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24494" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24497" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24503" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.24271" data-verso-hover="370">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21130">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-21137">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24894" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-21154">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25143" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24794" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24894" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-21183">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25003" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25006" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25009" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21196">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-21205">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25067" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24877" data-verso-hover="2923">f'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25003" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25006" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25009" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-21230" data-verso-hover="360">return</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25067" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.24762" data-verso-hover="370">es</span></code></td></tr><tr><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21309">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-21316">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-21320">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25458" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-21337" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25452" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25449" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-21341">in</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25258" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-21337" data-verso-hover="1144">do</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.25458" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25341" data-verso-hover="2923">f'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25449" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25452" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25458" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doBreak-21383" data-verso-hover="2922">break</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.25226" data-verso-hover="370">es</span></code></td><td><code class="hl lean block" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21441">do</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-21448">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25784" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-21465">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26033" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25684" data-verso-hover="2920">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25784" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-21494">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25893" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25896" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25899" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-21507">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-21516">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25957" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25767" data-verso-hover="2923">f'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25893" data-verso-hover="45">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25896" data-verso-hover="1155">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25899" data-verso-hover="311">b</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-21541" data-verso-hover="360">return</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25957" data-verso-hover="311">b</span><span class="inter-text">
</span><span class="var token" data-binding="var-_uniq.25652" data-verso-hover="370">es</span></code></td></tr></table><p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loop is repeated while the condition remains true.
It is possible to write infinite loops using them in functions that are not marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span>.
This is because the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span> modifier only applies to non-termination or infinite regress induced by the function being defined, and not by those that it calls.
The translation of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loops relies on a separate helper.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Conditional Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemWhile_Do_"><span class="keyword">while</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.«doElemWhile_:_Do_»"><span class="keyword">while</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">:</span> <span class="nonterminal" data-kind="term.pseudo">term</span> <span class="keyword">do</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat__Until_ : doElem</code></code><code class="kw">repeat</code></span>-<span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat__Until_ : doElem</code></code><code class="kw">until</code></span> loop is always executed at least once.
After each iteration, the condition is checked, and the loop is repeated when the condition is <strong>false</strong>.
When the condition becomes true, iteration stops.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Post-Tested Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemRepeat__Until_"><span class="keyword">repeat</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span>
      </span></span><span class="keyword">until</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The body of a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span> loop is repeated until a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span> statement is executed.
Just like <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> loops, these loops can be used in functions that are not marked <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.declaration : command</code></code><code class="kw">partial</code></span>.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Unconditional Loops</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal" data-kind="Lean.doElemRepeat_"><span class="keyword">repeat</span>
        <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqIndent"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span><span class="bnf">*</span></span></span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doContinue : doElem</code><span class="sep"></span><code class="docstring">`continue` skips to the next iteration of the surrounding `for` loop. </code></code><code class="kw">continue</code></span> statement skips the rest of the body of the closest enclosing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loop, moving on to the next iteration.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span> statement terminates the closest enclosing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loop, stopping iteration.</p>
                <div class="namedocs" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Loop Control Statements</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doContinue"><code class="hover-info"><code class="docstring">`continue` skips to the next iteration of the surrounding `for` loop. </code></code><span class="keyword">continue</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next"><span class="nonterminal" data-kind="Lean.Parser.Term.doSeqItem">doSeqItem</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Term.doSeqItem"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.doBreak"><code class="hover-info"><code class="docstring">`break` exits the surrounding `for` loop. </code></code><span class="keyword">break</span></span><span class="from-nonterminal" data-kind="null"></span></span></pre></div>
                  </div>
                <p>
                  In addition to <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doBreak : doElem</code><span class="sep"></span><code class="docstring">`break` exits the surrounding `for` loop. </code></code><code class="kw">break</code></span>, loops can always be terminated by effects in the current monad.
Throwing an exception from a loop terminates the loop.</p>
                <details class="example"><summary class="description">Terminating Loops in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> Monad</summary><div class="example-content">
                    <p>
                      The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Alternative.failure" data-verso-hover="361">failure</span></code> method from the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Alternative___mk" title="Documentation for Alternative"><span class="const token" data-binding="const-Alternative" data-verso-hover="2714">Alternative</span></a></code> class can be used to terminate an otherwise-infinite loop in the <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a></code> monad.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-24165" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-24171">show</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="44">Option</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-24187">from</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-24192">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-24197">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24201">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.doElemRepeat_-24214">repeat</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-24225">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1000</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-24225">then</span><span class="inter-text"> </span><span class="const token" data-binding="const-Alternative.failure" data-verso-hover="361">failure</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-null-24254">else</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-24278" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.141" data-verso-hover="7">i</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>none
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="closest-do-block">
                  14.3.2.6. Identifying <code>do</code> Blocks<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=closest-do-block" title="Permalink">🔗</a></span></h3>
                <p>
                  Many features of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span>-notation have an effect on the <span id="--tech-term-current-do-block" class="def-technical-term">current <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block</span>.
In particular, early return aborts the current block, causing it to evaluate to the returned value, and mutable bindings can only be mutated in the block in which they are defined.
Understanding these features requires a precise definition of what it means to be in the “same” block.</p>
                <p>
                  Empirically, this can be checked using the Lean language server.
When the cursor is on a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> statement, the corresponding <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword is highlighted.
Attempting to mutate a mutable binding outside of the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block results in an error message.</p>
                <figure><p>
                    <img src="static/screenshots/do-return-hl-1.png" alt="Highlighting do from return"></p>
                  <p>
                    <img src="static/screenshots/do-return-hl-2.png" alt="Highlighting do from return with errors"></p>
                  <figcaption>Highlighting <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span></figcaption></figure><p>
                  The rules are as follows:</p>
                <ul>
                  <li>
                    <p>
                      Each item immediately nested under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword that begins a block belongs to that block.</p>
                    </li>
                  <li>
                    <p>
                      Each item immediately nested under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> keyword that is an item in a containing <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block belongs to the outer block.</p>
                    </li>
                  <li>
                    <p>
                      Items in the branches of an <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doMatch : doElem</code></code><code class="kw">match</code></span>, or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> item belong to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block as the control structure that contains them. The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">do</code></span> keyword that is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doUnless : doElem</code></code><code class="kw">unless</code></span> does not introduce a new <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                    </li>
                  <li>
                    <p>
                      Items in the body of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemRepeat_ : doElem</code></code><code class="kw">repeat</code></span>, <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span>, and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> belong to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block as the loop  that contains them. The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">do</code></span> keyword that is part of the syntax of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.doElemWhile_Do_ : doElem</code></code><code class="kw">while</code></span> and <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> does not introduce a new <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.</p>
                    </li>
                  </ul>
                <details class="example"><summary class="description">Nested <code>do</code> and Branches</summary><div class="example-content">
                    <p>
                      The following example outputs <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">6</span></code> rather than <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">7</span></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27330">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-test" data-verso-hover="2924" id="test">test</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateM" title="Documentation for StateM"><span class="const token" data-binding="const-StateM" data-verso-hover="1673">StateM</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="22">Nat</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="3">Unit</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-27360">do</span></a><span class="inter-text">
  </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk" title="Documentation for MonadStateOf.set"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2925">set</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">5</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-27373">if</span><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="40">true</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-27373">then</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk" title="Documentation for MonadStateOf.set"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2925">set</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">6</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doNested-27400">do</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-27403" data-verso-hover="360">return</span><span class="inter-text">
  </span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#MonadStateOf___mk" title="Documentation for MonadStateOf.set"><span class="const token" data-binding="const-MonadStateOf.set" data-verso-hover="2925">set</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">7</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-27420" data-verso-hover="360">return</span><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">((), 6)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-27428" data-verso-hover="6">#eval</span></a></span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#test" title="Definition of example test"><span class="const token" data-binding="const-test" data-verso-hover="2924">test</span></a><span class="unknown token" data-binding="">.</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT___run" title="Documentation for StateT.run"><span class="const token" data-binding="const-StateT.run" data-verso-hover="2885">run</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">0</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>((), 6)
</pre></div>
                    <p>
                      This is because the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doReturn : doElem</code><span class="sep"></span><code class="docstring">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,
skipping any further statements.
Note that uses of the `do` keyword in other syntax like in `for _ in _ do`
do not constitute a surrounding block in this sense;
in supported editors, the corresponding `do` keyword of the surrounding block
is highlighted when hovering over `return`.

`return` not followed by a term starting on the same line is equivalent to `return ()`.
</code></code><code class="kw">return</code></span> statement under the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span> belongs to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> as its immediate parent, which itself belongs to the same <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> as the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doIf : doElem</code></code><code class="kw">if</code></span>.
If <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks that occurred as items in other <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> blocks instead created new blocks, then the example would output <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="7">7</span></code>.</p>
                    </div>
                  </details></section>
              <section>
                <h3 id="The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--do--Notation--Type-Classes-for-Iteration">
                  14.3.2.7. Type Classes for Iteration</h3>
                <p>
                  To be used with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loops without membership proofs, collections must implement the <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn"><span class="const token" data-binding="const-ForIn" data-verso-hover="2912">ForIn</span></a></code> type class.
Implementing <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'"><span class="const token" data-binding="const-ForIn'" data-verso-hover="2926">ForIn'</span></a></code> additionally allows the use of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.doFor : doElem</code><span class="sep"></span><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></code><code class="kw">for</code></span> loops with membership proofs.</p>
                <div class="namedocs" id="ForIn___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForIn.forIn" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForIn.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34521" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34522" data-verso-hover="55">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34523" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type v)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max u (u₁ + 1)) u₂) v)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForIn.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34521" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34522" data-verso-hover="55">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34523" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type v)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max u (u₁ + 1)) u₂) v)</span></div></pre><div class="text">
                    <p>
                      Monadic iteration in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-blocks, using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span></code> notation.</p>
                    <p>
                      The parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34479" data-verso-hover="2927">m</span></code> is the monad of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-block in which iteration is performed, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34480" data-verso-hover="55">ρ</span></code> is the type of
the collection being iterated over, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.34481" data-verso-hover="2928">α</span></code> is the type of elements.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.mk"><span class="const token" data-binding="const-ForIn.mk" data-verso-hover="2929">ForIn.mk</span></a><span class="unknown token" data-binding="">.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="2930">forIn</span> : <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.34492" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34487" data-verso-hover="2927">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34488" data-verso-hover="55">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34492" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34489" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34492" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34487" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34492" data-verso-hover="2931">β</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34487" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34492" data-verso-hover="2931">β</span></pre><div class="docs">
                        <p>
                          Monadically iterates over the contents of a collection <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs</span></code>, with a local state <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and the
possibility of early termination.</p>
                        <p>
                          Because a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> block supports local mutable bindings along with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">return</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">break</span></code>, the monadic
action passed to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> takes a starting state in addition to the current element of the
collection and returns an updated state together with an indication of whether iteration should
continue or terminate. If the action returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> should stop
iteration and return the updated state. If the action returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a></code>, then
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> should continue iterating if there are further elements, passing the updated state
to the action.</p>
                        <p>
                          More information about the translation of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loops into <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> is available in <a href="https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&amp;name=monad-iteration-syntax">the Lean
reference manual</a>.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForIn______mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForIn'.forIn'" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForIn'.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35654" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35655" data-verso-hover="55">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35656" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type v)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35657" data-verso-hover="2933">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Membership" data-verso-hover="1221">Membership</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35656" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35655" data-verso-hover="55">ρ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max u (u₁ + 1)) u₂) v)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForIn'.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35654" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35655" data-verso-hover="55">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35656" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type v)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35657" data-verso-hover="2933">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Membership" data-verso-hover="1221">Membership</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35656" data-verso-hover="2928">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35655" data-verso-hover="55">ρ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max u (u₁ + 1)) u₂) v)</span></div></pre><div class="text">
                    <p>
                      Monadic iteration in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-blocks with a membership proof, using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span></code> notation.</p>
                    <p>
                      The parameter <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.35604" data-verso-hover="2927">m</span></code> is the monad of the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-block in which iteration is performed, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.35605" data-verso-hover="55">ρ</span></code> is the type of
the collection being iterated over, <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.35606" data-verso-hover="2928">α</span></code> is the type of elements, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.35607" data-verso-hover="2933">d</span></code> is the specific membership
predicate to provide.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.mk"><span class="const token" data-binding="const-ForIn'.mk" data-verso-hover="2934">ForIn'.mk</span></a><span class="unknown token" data-binding="">.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u₂}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="2935">forIn'</span> : <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.35620" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u₁</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35614" data-verso-hover="2927">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35624" data-verso-hover="2936">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35615" data-verso-hover="55">ρ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35620" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">((</span><span class="var token" data-binding="var-_uniq.35629" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35616" data-verso-hover="2928">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35629" data-verso-hover="45">a</span><span class="inter-text"> </span><span class="const token" data-binding="const-Membership.mem" data-verso-hover="1148">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35624" data-verso-hover="2936">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35620" data-verso-hover="2931">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35614" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35620" data-verso-hover="2931">β</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35614" data-verso-hover="2927">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35620" data-verso-hover="2931">β</span></pre><div class="docs">
                        <p>
                          Monadically iterates over the contents of a collection <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">xs</span></code>, with a local state <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">b</span></code> and the
possibility of early termination. At each iteration, the body of the loop is provided with a proof
that the current element is in the collection.</p>
                        <p>
                          Because a <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code> block supports local mutable bindings along with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">return</span></code>, and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">break</span></code>, the monadic
action passed to <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a></code> takes a starting state in addition to the current element of the
collection with its membership proof. The action returns an updated state together with an
indication of whether iteration should continue or terminate. If the action returns
<code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a></code> should stop iteration and return the updated state. If the
action returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a></code>, then <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a></code> should continue iterating if there are
further elements, passing the updated state to the action.</p>
                        <p>
                          More information about the translation of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> loops into <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'.forIn'"><span class="const token" data-binding="const-ForIn'.forIn'" data-verso-hover="1385">ForIn'.forIn'</span></a></code> is available in <a href="https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&amp;name=monad-iteration-syntax">the
Lean reference manual</a>.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForInStep___done">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForInStep" title="Permalink">🔗</a></span><span class="label">inductive type</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForInStep.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36904" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForInStep.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36904" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span></div></pre><div class="text">
                    <p>
                      An indication of whether a loop's body terminated early that's used to compile the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">xs</span></code>
notation.</p>
                    <p>
                      A collection's <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn"><span class="const token" data-binding="const-ForIn" data-verso-hover="2912">ForIn</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn______mk" title="Documentation for ForIn'"><span class="const token" data-binding="const-ForIn'" data-verso-hover="2926">ForIn'</span></a></code> instance describe's how to iterate over its elements. The monadic
action that represents the body of the loop returns a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36886" data-verso-hover="55">α</span></code>, where <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.36886" data-verso-hover="55">α</span></code> is the local state
used to implement features such as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-0">mut</span></code>.</p>
                    <h1>
                      Constructors</h1>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">done.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.36897" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36897" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36897" data-verso-hover="55">α</span></pre><div class="docs">
                        <p>
                          The loop should terminate early.</p>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a></code> is produced by uses of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">break</span></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">return</span></code> in the loop body.</p>
                        </div>
                      </div>
                    <div class="constructor">
                      <pre class="name-and-type hl lean"><span class="unknown token" data-binding="">yield.{u}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.36900" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36900" data-verso-hover="55">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36900" data-verso-hover="55">α</span></pre><div class="docs">
                        <p>
                          The loop should continue with the next iteration, using the returned state.</p>
                        <p>
                          <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a></code> is produced by <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">continue</span></code> and by reaching the bottom of the loop body.</p>
                        </div>
                      </div>
                    </div>
                  </div>
                <div class="namedocs" id="ForInStep___value">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForInStep.value" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForInStep.value.{u_1}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37593" data-verso-hover="2937">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForInStep.value.{u_1}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37593" data-verso-hover="2937">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37592" data-verso-hover="43">α</span></div></pre><div class="text">
                    <p>
                      Extracts the value from a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a></code>, ignoring whether it is <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.done"><span class="const token" data-binding="const-ForInStep.done" data-verso-hover="2919">ForInStep.done</span></a></code> or <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep.yield"><span class="const token" data-binding="const-ForInStep.yield" data-verso-hover="2918">ForInStep.yield</span></a></code>.</p>
                    </div>
                  </div>
                <div class="namedocs" id="ForM___mk">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForM.mk" title="Permalink">🔗</a></span><span class="label">type class</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForM.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₂}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37775" data-verso-hover="98">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type v</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37776" data-verso-hover="2938">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type w₁</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37777" data-verso-hover="2939">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type w₂)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max (u + 1) v) w₁) w₂)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForM.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₂}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37775" data-verso-hover="98">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type v</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37776" data-verso-hover="2938">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type w₁</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37777" data-verso-hover="2939">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Type-Classes/Instance-Synthesis/#outParam" title="Documentation for outParam"><span class="const token" data-binding="const-outParam" data-verso-hover="1676">outParam</span></a><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">(Type w₂)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type (max (max (max (u + 1) v) w₁) w₂)</span></div></pre><div class="text">
                    <p>
                      Overloaded monadic iteration over some container type.</p>
                    <p>
                      An instance of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM"><span class="const token" data-binding="const-ForM" data-verso-hover="2940">ForM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37712" data-verso-hover="98">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37713" data-verso-hover="2938">γ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37714" data-verso-hover="2939">α</span></code> describes how to iterate a monadic operator over a container of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.37713" data-verso-hover="2938">γ</span></code>
with elements of type <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.37714" data-verso-hover="2939">α</span></code> in the monad <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.37712" data-verso-hover="98">m</span></code>. The element type should be uniquely determined by the
monad and the container.</p>
                    <p>
                      Use <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___forIn" title="Documentation for ForM.forIn"><span class="const token" data-binding="const-ForM.forIn" data-verso-hover="2941">ForM.forIn</span></a></code> to construct a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn"><span class="const token" data-binding="const-ForIn" data-verso-hover="2912">ForIn</span></a></code> instance from a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM"><span class="const token" data-binding="const-ForM" data-verso-hover="2940">ForM</span></a></code> instance, thus enabling the use of
the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">for</span></code> operator in <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">do</span></code>-notation.</p>
                    <h1>
                      Instance Constructor</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM.mk"><span class="const token" data-binding="const-ForM.mk" data-verso-hover="2942">ForM.mk</span></a><span class="unknown token" data-binding="">.{u,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">v,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₁,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">w₂}</span></pre><div class="docs"></div>
                      </section>
                    <h1>
                      Methods</h1>
                    <section class="subdocs">
                      <pre class="name-and-type hl lean"><span class="const token" data-binding="const-ForM.forM" data-verso-hover="2943">forM</span> : <span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37753" data-verso-hover="98">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37754" data-verso-hover="2938">γ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37755" data-verso-hover="2939">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37753" data-verso-hover="98">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit" title="Documentation for PUnit"><span class="const token" data-binding="const-PUnit" data-verso-hover="276">PUnit</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37753" data-verso-hover="98">m</span><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#PUnit___unit" title="Documentation for PUnit"><span class="const token" data-binding="const-PUnit" data-verso-hover="276">PUnit</span></a></pre><div class="docs">
                        <p>
                          Runs the monadic action <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">f</span></code> on each element of the collection <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">coll</span></code>.</p>
                        </div>
                      </section>
                    </div>
                  </div>
                <div class="namedocs" id="ForM___forIn">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=ForM.forIn" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">ForM.forIn.{u_1,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_2,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_3,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_4}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_2</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_3</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_4</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM"><span class="const token" data-binding="const-ForM" data-verso-hover="2940">ForM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT" title="Documentation for StateT"><span class="const token" data-binding="const-StateT" data-verso-hover="2793">StateT</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#ExceptT" title="Documentation for ExceptT"><span class="const token" data-binding="const-ExceptT" data-verso-hover="2854">ExceptT</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38333" data-verso-hover="2936">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38334" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38338" data-verso-hover="2947">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span></div><div class="narrow-only"><span class="unknown token" data-binding="">ForM.forIn.{u_1,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_2,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_3,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">u_4}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_2</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_1</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_3</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="49">Type u_4</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="208">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM"><span class="const token" data-binding="const-ForM" data-verso-hover="2940">ForM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#StateT" title="Documentation for StateT"><span class="const token" data-binding="const-StateT" data-verso-hover="2793">StateT</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Varieties-of-Monads/#ExceptT" title="Documentation for ExceptT"><span class="const token" data-binding="const-ExceptT" data-verso-hover="2854">ExceptT</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38333" data-verso-hover="2936">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38327" data-verso-hover="2945">ρ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38334" data-verso-hover="311">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.38338" data-verso-hover="2947">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38328" data-verso-hover="2946">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Functors___-Monads-and--do--Notation/Syntax/#ForInStep___done" title="Documentation for ForInStep"><span class="const token" data-binding="const-ForInStep" data-verso-hover="2932">ForInStep</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38325" data-verso-hover="2944">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38326" data-verso-hover="43">β</span></div></pre><div class="text">
                    <p>
                      Creates a suitable implementation of <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForIn___mk" title="Documentation for ForIn.forIn"><span class="const token" data-binding="const-ForIn.forIn" data-verso-hover="1383">ForIn.forIn</span></a></code> from a <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Functors___-Monads-and--do--Notation/Syntax/#ForM___mk" title="Documentation for ForM"><span class="const token" data-binding="const-ForM" data-verso-hover="2940">ForM</span></a></code> instance.</p>
                    </div>
                  </div>
                </section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Functors___-Monads-and--do--Notation/Lifting-Monads/#lifting-monads" rel="prev" title="14.2. Lifting Monads"><span class="arrow">←</span><span class="where">14.2. Lifting Monads</span></a><a class="local-button active" href="Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference" rel="next" title="14.4. API Reference"><span class="where">14.4. API Reference</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

