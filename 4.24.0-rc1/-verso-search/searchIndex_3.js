window.docContents[3].resolve({"/Basic-Types/Linked-Lists/#List":{"contents":"Linked lists, implemented as the inductive type List, contain an ordered sequence of elements.\nUnlike arrays, Lean compiles lists according to the ordinary rules for inductive types; however, some operations on lists are replaced by tail-recursive equivalents in compiled code using the csimp mechanism.\nLean provides syntax for both literal lists and the constructor List.cons.\n\nLinked lists: ordered lists, in which each element has a reference to the next element.Most operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.List α is isomorphic to Array α, but they are useful for different things:* List α is easier for reasoning, and Array α is modeled as a wrapper around List α.* List α works well as a persistent data structure, when many copies of the tail are shared. When\nthe value is not shared, Array α will have better performance because it can do destructive\nupdates.The empty list, usually written [].Conventions for notations in identifiers:* The recommended spelling of [] in identifiers is nil.The list whose first element is head, where tail is the rest of the list.\nUsually written head :: tail.Conventions for notations in identifiers:* The recommended spelling of :: in identifiers is cons.* The recommended spelling of [a] in identifiers is singleton.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.15. Linked Lists","id":"/Basic-Types/Linked-Lists/#List"},"/Type-Classes/Instance-Declarations/#instance-declarations":{"contents":"The syntax of instance declarations is almost identical to that of definitions.\nThe only syntactic differences are that the keyword def is replaced by instance and the name is optional:\n\nInstance DeclarationsMost instances define each method using where syntax:However, type classes are inductive types, so instances can be constructed using any expression with an appropriate type:Instances may also be defined by cases; however, this feature is rarely used outside of Decidable instances:\n\nInstances defined with explicit terms often consist of either anonymous constructors (⟨...⟩) wrapping method implementations or of invocations of inferInstanceAs on definitionally equal types.\n\nElaboration of instances is almost identical to the elaboration of ordinary definitions, with the exception of the caveats documented below.\nIf no name is provided, then one is created automatically.\nIt is possible to refer to this generated name directly, but the algorithm used to generate the names has changed in the past and may change in the future.\nIt's better to explicitly name instances that will be referred to directly.\nAfter elaboration, the new instance is registered as a candidate for instance search.\nAdding the attribute instance to a name can be used to mark any other defined name as a candidate.\n\nInstance Name GenerationFollowing these declarations:structure NatWrapper where\n  val : Nat\n\ninstance : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\nthe name instBEqNatWrapper refers to the new instance.\n\nVariations in Instance DefinitionsGiven this structure type:structure NatWrapper where\n  val : Nat\nall of the following ways of defining a BEq instance are equivalent:instance : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\n\ninstance : BEq NatWrapper :=\n  ⟨fun x y => x.val == y.val⟩\n\ninstance : BEq NatWrapper :=\n  ⟨fun ⟨x⟩ ⟨y⟩ => x == y⟩\nAside from introducing different names into the environment, the following are also equivalent:@[instance]\ndef instBeqNatWrapper : BEq NatWrapper where\n  beq\n    | ⟨x⟩, ⟨y⟩ => x == y\n\ninstance : BEq NatWrapper :=\n  ⟨fun x y => x.val == y.val⟩\n\ninstance : BEq NatWrapper :=\n  ⟨fun ⟨x⟩ ⟨y⟩ => x == y⟩\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.2. Instance Declarations","id":"/Type-Classes/Instance-Declarations/#instance-declarations"}});