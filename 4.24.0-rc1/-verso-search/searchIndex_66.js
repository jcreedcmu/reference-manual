window.docContents[66].resolve({"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Conversions":{"contents":"Extracts the underlying Nat value.This function is a synonym for Fin.val, which is the simp normal form. Fin.val is also a\ncoercion, so values of type Fin n are automatically converted to Nats as needed.\n\nReturns a modulo n as a Fin n.The assumption NeZero n ensures that Fin n is nonempty.\n\nUses a proof that two bounds are equal to allow a value bounded by one to be used with the other.In other words, when eq : n = m, Fin.cast eq i converts i : Fin n into a Fin m.\n\nReplaces the bound with another that is suitable for the value.The proof embedded in i can be used to cast to a larger bound even if the concrete value is not\nknown.Examples:example : Fin 12 := (7 : Fin 10).castLT (by decide : 7 < 12)\nexample (i : Fin 10) : Fin 12 :=\n  i.castLT <| by\n    cases i; simp; omega\n\n\nCoarsens a bound to one at least as large.See also Fin.castAdd for a version that represents the larger bound with addition rather than an\nexplicit inequality proof.\n\nCoarsens a bound to one at least as large.See also Fin.natAdd and Fin.addNat for addition functions that increase the bound, and\nFin.castLE for a version that uses an explicit inequality proof.\n\nCoarsens a bound by one.\n\nReplaces a value with its difference from the largest value in the type.Considering the values of Fin n as a sequence 0, 1, â€¦, n-2, n-1, Fin.rev finds the\ncorresponding element of the reversed sequence. In other words, it maps 0 to n-1, 1 to n-2,\n..., and n-1 to 0.Examples:* (5 : Fin 6).rev = (0 : Fin 6)* (0 : Fin 6).rev = (5 : Fin 6)* (2 : Fin 5).rev = (2 : Fin 5)\n\nThe type Fin 0 is uninhabited, so it can be used to derive any result whatsoever.This is similar to Empty.elim. It can be thought of as a compiler-checked assertion that a code\npath is unreachable, or a logical contradiction from which False and thus anything else could be\nderived.\n\n","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","header":"19.3.3.4. Conversions","id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Conversions"},"/Basic-Types/Maps-and-Sets/#maps":{"contents":"A map is a data structure that associates keys with values.\nThey are also referred to as dictionaries, associative arrays, or simply as hash tables.\n\nIn Lean, maps may have the following properties: Representation\n\nThe in-memory representation of a map may be either a tree or a hash table.\n  Tree-based representations are better when the reference to the data structure is shared, because hash tables are based on arrays.\n  Arrays are copied in full on modification when the reference is not unique, while only the path from the root of the tree to the modified nodes must be copied on modification of a tree.\n  Hash tables, on the other hand, can be more efficient when references are not shared, because non-shared arrays can be modified in constant time.\n  Furthermore, tree-based maps store data in order and thus support ordered traversals of the data.\n\n Extensionality\n\nMaps can be viewed as partial functions from keys to values.\n  Extensional maps are maps for which propositional equality matches this interpretation.\n  This can be convenient for reasoning, but it also rules out some useful operations that would be able to distinguish between them.\n  In general, extensional maps should be used only when needed for verification.\n\n Dependent or Not\n\nA dependent map is one in which the type of each value is determined by its corresponding key, rather than being constant.\n  Dependent maps have more expressive power, but are also more difficult to use.\n  They impose more requirements on their users.\n  For example, many operations on DHashMap require LawfulBEq instances rather than BEq.\n\n\n\n* Map* Representation* Extensional?* Dependent?* TreeMap* Tree* No* No* DTreeMap* Tree* No* Yes* HashMap* Hash Table* No* No* DHashMap* Hash Table* No* Yes* ExtHashMap* Hash Table* Yes* No* ExtDHashMap* Hash Table* Yes* Yes\n\nA map can always be used as a set by setting its type of values to Unit.\nThe following set types are provided:\n\n* Std.HashSet is a set based on hash tables. Its performance characteristics are like those of Std.HashMap: it is based on arrays and can be efficiently updated, but only when not shared.* Std.TreeSet is a set based on balanced trees. Its performance characteristics are like those of Std.TreeMap.* Std.ExtHashSet is an extensional hash set type that matches the mathematical notion of finite sets: two sets are equal if they contain the same elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.17. Maps and Sets","id":"/Basic-Types/Maps-and-Sets/#maps"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Discarding-Results":{"contents":"The discard function is especially useful when using an action that returns a value only for its side effects.\n\nDiscards the value in a functor, retaining the functor's structure.Discarding values is especially useful when using Applicative functors or Monads to implement\neffects, and some operation should be carried out only for its effects. In do-notation, statements\nwhose values are discarded must return Unit, and discard can be used to explicitly discard their\nvalues.\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","header":"14.4.1. Discarding Results","id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Discarding-Results"},"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--Other-solutions":{"contents":"At this point, it's worth pausing and doing at least one of the following:\n\n* Try to prove this yourself! It's quite challenging for a beginner!\n  You can have a go\n  in the Live Lean editor without any installation.* Read Chris Hughes's solution,\n  which is included in the Mathlib Archive.\n  This solution makes good use of Aesop, but is not ideal because1. It defines the solution using a subtype, simultaneously giving the construction and proving properties about it.\n     We think it's better stylistically to keep these separate.2. Even with Aesop automation, there's still about 15 lines of manual proof work before we can hand off to Aesop.* Read Wojciech Nawrocki's solution.\n  This one uses less automation, at about 300 lines of proof work.\n\n","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","header":"17.10.2.3. Other solutions","id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--Other-solutions"}});