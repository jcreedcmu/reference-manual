window.docContents[68].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation":{"contents":"Creates a new empty tree map. It is also possible and recommended to\nuse the empty collection notations ∅ and {} to create an empty tree map. simp replaces\nempty with ∅.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps","header":"19.17.8.1. Creation","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Creation"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors":{"contents":"\n\nApplicative Operatorsg <*> x is short for Seq.seq g (fun () => x).\nThe function is inserted to delay evaluation because control might not reach the argument.e1 *> e2 is short for SeqRight.seqRight e1 (fun () => e2).e1 <* e2 is short for SeqLeft.seqLeft e1 (fun () => e2).\n\nMany applicative functors also support failure and recovery via the Alternative type class.\nThis class also has an infix operator.\n\nAlternative Operatorse <|> e' is short for OrElse.orElse e (fun () => e').\nThe function is inserted to delay evaluation because control might not reach the argument.\n\n\n\nstructure User where\n  name : String\n  favoriteNat : Nat\ndef main : IO Unit := pure ()\nInfix Functor and Applicative OperatorsA common functional programming idiom is to use a pure function in some context with effects by applying it via Functor.map and Seq.seq.\nThe function is applied to its sequence of arguments using <$>, and the arguments are separated by <*>.In this example, the constructor User.mk is applied via this idiom in the body of main.def getName : IO String := do\n  IO.println \"What is your name?\"\n  return (← (← IO.getStdin).getLine).trimRight\n\npartial def getFavoriteNat : IO Nat := do\n  IO.println \"What is your favorite natural number?\"\n  let line ← (← IO.getStdin).getLine\n  if let some n := line.trim.toNat? then\n    return n\n  else\n    IO.println \"Let's try again.\"\n    getFavoriteNat\n\nstructure User where\n  name : String\n  favoriteNat : Nat\nderiving Repr\n\ndef main : IO Unit := do\n  let user ← User.mk <$> getName <*> getFavoriteNat\n  IO.println (repr user)\nWhen run with this input:A. Lean User\nNone\n42\nit produces this output:What is your name?\nWhat is your favorite natural number?\nLet's try again.\nWhat is your favorite natural number?\n{ name := \"A. Lean User\", favoriteNat := 42 }\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009Infix Operators","header":"14.3.1.2. Applicative Functors","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Applicative-Functors"}});