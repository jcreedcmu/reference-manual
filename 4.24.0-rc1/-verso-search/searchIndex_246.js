window.docContents[246].resolve({"/Terms/Function-Application/#generalized-field-notation":{"contents":"The section on structure fields describes the notation for projecting a field from a term whose type is a structure.\nGeneralized field notation consists of a term followed by a dot (.) and an identifier, not separated by spaces.\n\nField Notation\n\nIf a term's type is a constant applied to zero or more arguments, then field notation can be used to apply a function to it, regardless of whether the term is a structure or type class instance that has fields.\nThe use of field notation to apply other functions is called generalized field notation.\n\nThe identifier after the dot is looked up in the namespace of the term's type, which is the constant's name.\nIf the type is not an application of a constant (e.g., a function, a metavariable, or a universe) then it doesn't have a namespace and generalized field notation cannot be used.\nIf the field is not found, but the constant can be unfolded to yield a further type which is a constant or application of a constant, then the process is repeated with the new constant.\n\nWhen a function is found, the term before the dot becomes an argument to the function.\nSpecifically, it becomes the first explicit argument that would not be a type error.\nAside from that, the application is elaborated as usual.\n\nGeneralized Field NotationThe type Username is a constant, so functions in the Username namespace can be applied to terms with type Username with generalized field notation.def Username := String\nOne such function is Username.validate, which checks that a username contains no leading whitespace and that only a small set of acceptable characters are used.\nIn its definition, generalized field notation is used to call the functions String.isPrefixOf, String.any, Char.isAlpha, and Char.isDigit.\nIn the case of String.isPrefixOf, which takes two String arguments, \" \" is used as the first  because it's the term before the dot.\nString.any can be called on name using generalized field notation even though it has type Username because Username.any is not defined and Username unfolds to String.def Username.validate (name : Username) : Except String Unit := do\n  if \" \".isPrefixOf name then\n    throw \"Unexpected leading whitespace\"\n  if name.any notOk then\n    throw \"Unexpected character\"\n  return ()\nwhere\n  notOk (c : Char) : Bool :=\n    !c.isAlpha &&\n    !c.isDigit &&\n    !c ∈ ['_', ' ']\n\ndef root : Username := \"root\"\nHowever, Username.validate can't be called on \"root\" using field notation, because String does not unfold to Username.#eval \"root\".validate\nInvalid field `validate`: The environment does not contain `String.validate`\n  \"root\"\nhas type\n  String\nroot, on the other hand, has type Username:#eval root.validate\nExcept.ok ()\n\n\n(pretty printer) use field notation when pretty printing, including for structure projections, unless '@[pp_nodot]' is applied\n\nControlling Field NotationThe pp_nodot attribute causes Lean's pretty printer to not use field notation when printing a function.\n\nTurning Off Field NotationNat.half is printed using field notation by default.def Nat.half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => n.half + 1\n#check Nat.half Nat.zero\nNat.zero.half : Nat\nAdding pp_nodot to Nat.half causes ordinary function application syntax to be used instead when displaying the term.attribute [pp_nodot] Nat.half\n\n#check Nat.half Nat.zero\nNat.half Nat.zero : Nat\n\n\n","context":"Lean Reference\u0009Terms\u0009Function Application","header":"10.4.1. Generalized Field Notation","id":"/Terms/Function-Application/#generalized-field-notation"}});