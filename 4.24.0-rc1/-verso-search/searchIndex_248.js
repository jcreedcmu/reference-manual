window.docContents[248].resolve({"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration--Folds":{"contents":"Folds are operators that combine the elements of a list using a function.\nThey come in two varieties, named after the nesting of the function calls: Left folds\n\nLeft folds combine the elements from the head of the list towards the end.\n  The head of the list is combined with the initial value, and the result of this operation is then combined with the next value, and so forth.\n\n Right folds\n\nRight folds combine the elements from the end of the list towards the start, as if each cons constructor were replaced by a call to the combining function and nil were replaced by the initial value.\n\nMonadic folds, indicated with an -M suffix, allow the combining function to use effects in a monad, which may include stopping the fold early.\n\nFolds a function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.Examples:* [a, b, c].foldl f z  = f (f (f z a) b) c* [1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"* [1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"\n\nFolds a monadic function over a list from the left, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in order, using f.Example:example [Monad m] (f : α → β → m α) :\n    List.foldlM (m := m) f x₀ [a, b, c] = (do\n      let x₁ ← f x₀ a\n      let x₂ ← f x₁ b\n      let x₃ ← f x₂ c\n      pure x₃)\n  := by rfl\n\n\nA reasoning principle for proving propositions about the result of List.foldl by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.Because the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.Example:example {xs : List Nat} : xs.foldl (· + ·) 1 > 0 := by\n  apply List.foldlRecOn\n  . show 0 < 1; trivial\n  . show ∀ (b : Nat), 0 < b → ∀ (a : Nat), a ∈ xs → 0 < b + a\n    intros; omega\n\n\nFolds a function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.O(|l|). Replaced at runtime with List.foldrTR.Examples:* [a, b, c].foldr f init  = f a (f b (f c init))* [1, 2, 3].foldr (toString · ++ ·) \"\" = \"123\"* [1, 2, 3].foldr (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"\n\nFolds a monadic function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.Example:example [Monad m] (f : α → β → m β) :\n  List.foldrM (m := m) f x₀ [a, b, c] = (do\n    let x₁ ← f c x₀\n    let x₂ ← f b x₁\n    let x₃ ← f a x₂\n    pure x₃)\n  := by rfl\n\n\nA reasoning principle for proving propositions about the result of List.foldr by establishing an\ninvariant that is true for the initial data and preserved by the operation being folded.Because the motive can return a type in any sort, this function may be used to construct data as\nwell as to prove propositions.Example:example {xs : List Nat} : xs.foldr (· + ·) 1 > 0 := by\n  apply List.foldrRecOn\n  . show 0 < 1; trivial\n  . show ∀ (b : Nat), 0 < b → ∀ (a : Nat), a ∈ xs → 0 < a + b\n    intros; omega\n\n\nFolds a function over a list from the right, accumulating a value starting with init. The\naccumulated value is combined with the each element of the list in reverse order, using f.O(|l|). This is the tail-recursive replacement for List.foldr in runtime code.Examples:* [a, b, c].foldrTR f init  = f a (f b (f c init))* [1, 2, 3].foldrTR (toString · ++ ·) \"\" = \"123\"* [1, 2, 3].foldrTR (s!\"({·} {·})\") \"!\" = \"(1 (2 (3 !)))\"\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference\u0009Iteration","header":"19.15.3.10.1. Folds","id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Iteration--Folds"},"/Interacting-with-Lean/#Format":{"contents":"A FormatThe API described here is an adaptation of Wadler's () It has been modified to be efficient in a strict language and with support for additional features such as metadata tags. is a compact representation of a set of strings.\nThe most important Format operations are: Strings\n\nA String can be made into a Format using the text constructor.\n  This constructor is registered as a coercion from String to Format, so it is often unnecessary to invoke it explicitly.\n  text str represents the singleton set that contains only str.\n  If the string contains newline characters ('\\n'), then they are unconditionally inserted as newlines into the resulting output, regardless of groups.\n  They are, however, indented according to the current indentation level.\n\n Appending\n\nTwo Formats can be appended using the ++ operator from the Append Format instance.\n\n Groups and Newlines\n\nThe constructor line represents the set that contains both \"\\n\" ++ indent and \" \", where indent is a string with enough spaces to indent the line correctly.\n  Imperatively, it can be thought of as a newline that will be “flattened” to a space if there is sufficient room on the current line.\n  Newlines occur in groups: the nearest enclosing application of the group operator determines which group the newline belongs to.\n  By default, either all lines in a group represent \"\\n\" or all represent \" \"; groups may also be configured to fill lines, in which case the minimal number of lines in the group represent \"\\n\".\n  Uses of line that do not belong to a group always represent \"\\n\".\n\n Indentation\n\nWhen a newline is inserted, the output is also indented.\n  nest n increases the indentation of a document by n spaces.\n  This is not sufficient to represent all Lean syntax, which sometimes requires that columns align exactly.\n  align is a document that ensures that the output string is at the current indentation level, inserting just spaces if possible, or a newline followed by spaces if needed.\n\n Tagging\n\nLean's interactive features require the ability to associate output with the underlying values that they represent.\n  This allows Lean development environments to present elaborated terms when hovering over terms proof states or error messages, for example.\n  Documents can be tagged with a Nat value n using tag n; these Nats should be mapped to the underlying value in a side table.\n\n\n\nWidths and Newlinesopen Std Format\nThe helper parenSeq creates a parenthesized sequence, with grouping and indentation to make it responsive to different output widths.def parenSeq (xs : List Format) : Format :=\n  group <|\n    nest 2 (text \"(\" ++ line ++ joinSep xs line) ++\n    line ++\n    \")\"\nThis document represents a parenthesized sequence of numbers:def lst : Format := parenSeq nums\nwhere nums := [1, 2, 3, 4, 5].map (text s!\"{·}\")\nRendering it with the default line width of 120 characters places the entire sequence on one line:#eval IO.println lst.pretty\n( 1 2 3 4 5 )\nBecause all the lines belong to the same group, they will either all be rendered as spaces or all be rendered as newlines.\nIf only 9 characters are available, all of the lines in lst become newlines:#eval IO.println (lst.pretty (width := 9))\n(\n  1\n  2\n  3\n  4\n  5\n)\nThis document contains three copies of lst in a further parenthesized sequence:def lsts := parenSeq [lst, lst, lst]\nAt the default width, it remains on one line:#eval IO.println lsts.pretty\n( ( 1 2 3 4 5 ) ( 1 2 3 4 5 ) ( 1 2 3 4 5 ) )\nIf only 20 characters are available, each occurrence of lst ends up on its own line.\nThis is because converting the outer group to newlines is sufficient to keep the string within 20 columns:#eval IO.println (lsts.pretty (width := 20))\n(\n  ( 1 2 3 4 5 )\n  ( 1 2 3 4 5 )\n  ( 1 2 3 4 5 )\n)\nIf only 10 characters are available, each number must be on its own line:#eval IO.println (lsts.pretty (width := 10))\n(\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n  (\n    1\n    2\n    3\n    4\n    5\n  )\n)\n\n\nGrouping and Fillingopen Std Format\nThe helper parenSeq creates a parenthesized sequence, with each element placed on a new line and indented:def parenSeq (xs : List Format) : Format :=\n  nest 2 (text \"(\" ++ line ++ joinSep xs line) ++\n  line ++\n  \")\"\nnums contains the numbers one through twenty, as a list of formats:def nums : List Format :=\n  Nat.fold 20 (init := []) fun i _ ys =>\n    text s!\"{20 - i}\" :: ys\n#eval nums\nBecause parenSeq does not introduce any groups, the resulting document is rendered on a single line:#eval IO.println (pretty (parenSeq nums))\nThis can be fixed by grouping them.\ngrouped does so with group, while filled does so with fill.def grouped := group (parenSeq nums)\ndef filled := fill (parenSeq nums)\nBoth grouping operators cause uses of line to render as spaces.\nGiven sufficient space, both render on a single line:#eval IO.println (pretty grouped)\n( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )\n#eval IO.println (pretty filled)\n( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )\nHowever, difference become apparent when there is not sufficient space on a single line.\nUnless all newlines in a group can be spaces, none can:#eval IO.println (pretty (width := 30) grouped)\n(\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n  10\n  11\n  12\n  13\n  14\n  15\n  16\n  17\n  18\n  19\n  20\n)\nUsing fill, on the other hand, only inserts newlines as required to avoid being two wide:#eval IO.println (pretty (width := 30) filled)\n( 1 2 3 4 5 6 7 8 9 10 11 12\n  13 14 15 16 17 18 19 20 )\nThe behavior of fill can be seen clearly with longer sequences:#eval IO.println <|\n  pretty (width := 30) (fill (parenSeq (nums ++ nums ++ nums ++ nums)))\n( 1 2 3 4 5 6 7 8 9 10 11 12\n  13 14 15 16 17 18 19 20 1 2\n  3 4 5 6 7 8 9 10 11 12 13 14\n  15 16 17 18 19 20 1 2 3 4 5\n  6 7 8 9 10 11 12 13 14 15 16\n  17 18 19 20 1 2 3 4 5 6 7 8\n  9 10 11 12 13 14 15 16 17 18\n  19 20 )\n\n\nNewline Characters in StringsIncluding a newline character in a string causes the rendering process to unconditionally insert a newline.\nThese newlines do, however, respect the current indentation level.The document str consists of an embedded string with two newlines:open Std Format\n\ndef str : Format := text \"abc\\nxyz\\n123\"\nPrinting the string both with and without grouping results in the newlines being used:#eval IO.println str.pretty\nabc\nxyz\n123\n#eval IO.println (group str).pretty\nabc\nxyz\n123\nBecause the string does not terminate with a newline, the last line of the first string is on the same line as the first line of the second string:#eval IO.println (str ++ str).pretty\nabc\nxyz\n123abc\nxyz\n123\nIncreasing the indentation level, however, causes all three lines of the string to begin at the same column:#eval IO.println (text \"It is:\" ++ indentD str).pretty\nIt is:\n  abc\n  xyz\n  123\n#eval IO.println (nest 8 <| text \"It is:\" ++ align true ++ str).pretty\nIt is:  abc\n        xyz\n        123\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output","header":"3.7.1. Format","id":"/Interacting-with-Lean/#Format"}});