window.docContents[163].resolve({"/Basic-Types/Characters/#char-runtime":{"contents":"As a trivial wrapper, characters are represented identically to UInt32.\nIn particular, characters are represented as 32-bit immediate values in monomorphic contexts.\nIn other words, a field of a constructor or structure of type Char does not require indirection to access.\nIn polymorphic contexts, characters are boxed.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters","header":"19.7.2. Run-Time Representation","id":"/Basic-Types/Characters/#char-runtime"},"/Basic-Types/Lazy-Computations/#Thunk-coercions":{"contents":"There is a coercion from any type α to Thunk α that converts a term e into Thunk.mk fun () => e.\nBecause the elaborator unfolds coercions, evaluation of the original term e is delayed; the coercion is not equivalent to Thunk.pure.\n\nLazy ListsLazy lists are lists that may contain thunks.\nThe delayed constructor causes part of the list to be computed on demand.inductive LazyList (α : Type u) where\n  | nil\n  | cons : α → LazyList α → LazyList α\n  | delayed : Thunk (LazyList α) → LazyList α\nderiving Inhabited\nLazy lists can be converted to ordinary lists by forcing all the embedded thunks.def LazyList.toList : LazyList α → List α\n  | .nil => []\n  | .cons x xs => x :: xs.toList\n  | .delayed xs => xs.get.toList\nMany operations on lazy lists can be implemented without forcing the embedded thunks, instead building up further thunks.\nThe body of delayed does not need to be an explicit call to Thunk.mk because of the coercion.def LazyList.take : Nat → LazyList α → LazyList α\n  | 0, _ => .nil\n  | _, .nil => .nil\n  | n + 1, .cons x xs => .cons x <| .delayed <| take n xs\n  | n + 1, .delayed xs => .delayed <| take (n + 1) xs.get\n\ndef LazyList.ofFn (f : Fin n → α) : LazyList α :=\n  Fin.foldr n (init := .nil) fun i xs =>\n    .delayed <| LazyList.cons (f i) xs\n\ndef LazyList.append (xs ys : LazyList α) : LazyList α :=\n  .delayed <|\n    match xs with\n    | .nil => ys\n    | .cons x xs' => LazyList.cons x (append xs' ys)\n    | .delayed xs' => append xs'.get ys\nLaziness is ordinarily invisible to Lean programs: there is no way to check whether a thunk has been forced.\nHowever, dbg_trace can be used to gain insight into thunk evaluation.def observe (tag : String) (i : Fin n) : Nat :=\n  dbg_trace \"{tag}: {i.val}\"\n  i.val\nThe lazy lists xs and ys emit traces when evaluated.def xs := LazyList.ofFn (n := 3) (observe \"xs\")\ndef ys := LazyList.ofFn (n := 3) (observe \"ys\")\nConverting xs to an ordinary list forces all of the embedded thunks:#eval xs.toList\nxs: 0\nxs: 1\nxs: 2\n[0, 1, 2]\nLikewise, converting xs.append ys to an ordinary list forces the embedded thunks:#eval xs.append ys |>.toList\nxs: 0\nxs: 1\nxs: 2\nys: 0\nys: 1\nys: 2\n[0, 1, 2, 0, 1, 2]\nAppending xs to itself before forcing the thunks results in a single set of traces, because each thunk's code is evaluated just once:#eval xs.append xs |>.toList\nxs: 0\nxs: 1\nxs: 2\n[0, 1, 2, 0, 1, 2]\nFinally, taking a prefix of xs.append ys results in only some of the thunks in ys being evaluated:#eval xs.append ys |>.take 4 |>.toList\nxs: 0\nxs: 1\nxs: 2\nys: 0\n[0, 1, 2, 0]\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Lazy Computations","header":"19.19.3. Coercions","id":"/Basic-Types/Lazy-Computations/#Thunk-coercions"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Prefix-and-Suffix":{"contents":"Returns the longest common prefix of two substrings.The returned substring uses the same underlying string as s.\n\nReturns the longest common suffix of two substrings.The returned substring uses the same underlying string as s.\n\nIf pre is a prefix of s, returns the remainder. Returns none otherwise.The substring pre is a prefix of s if there exists a t : Substring such that\ns.toString = pre.toString ++ t.toString. If so, the result is the substring of s without the\nprefix.\n\nIf suff is a suffix of s, returns the remainder. Returns none otherwise.The substring suff is a suffix of s if there exists a t : Substring such that\ns.toString = t.toString ++ suff.toString. If so, the result the substring of s without the\nsuffix.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","header":"19.8.4.10.5. Prefix and Suffix","id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Prefix-and-Suffix"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-control":{"contents":"first | conv | ... runs each conv until one succeeds, or else fails.\n\ntry tac runs tac and succeeds even if tac failed.\n\ntac <;> tac' runs tac on the main goal and tac' on each produced goal, concatenating all goals\nproduced by tac'.\n\nrepeat convs runs the sequence convs repeatedly until it fails to apply.\n\nskip does nothing.\n\n{ convs } runs the list of convs on the current target, and any subgoals that\nremain are trivially closed by skip.\n\n(convs) runs the convs in sequence on the current list of targets.\nThis is pure grouping with no added effects.\n\ndone succeeds iff there are no goals remaining.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.1. Control Structures","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-control"},"/The-Type-System/Inductive-Types/#structures":{"contents":"Structure DeclarationsDeclares a new structure type.\n\nStructures are inductive types that have only a single constructor and no indices.\nIn exchange for these restrictions, Lean generates code for structures that offers a number of conveniences: projection functions are generated for each field, an additional constructor syntax based on field names rather than positional arguments is available, a similar syntax may be used to replace the values of certain named fields, and structures may extend other structures.\nJust like other inductive types, structures may be recursive; they are subject to the same restrictions regarding strict positivity.\nStructures do not add any expressive power to Lean; all of their features are implemented in terms of code generation.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types","header":"4.4.2. Structure Declarations","id":"/The-Type-System/Inductive-Types/#structures"}});