window.docContents[197].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Sorted-Arrays":{"contents":"In-place quicksort.qsort as lt lo hi sorts the subarray as[lo...=hi] in-place using lt to compare elements.\n\nSort an array using compare to compare elements.\n\nSorts an array using insertion sort.The optional parameter lt specifies an ordering predicate. It defaults to LT.lt, which must be\ndecidable to be used for sorting.\n\nInserts an element into a sorted array such that the resulting array is sorted. If the element is\nalready present in the array, it is not inserted.The ordering predicate lt should be a total order on elements, and the array as should be sorted\nwith respect to lt.Array.binInsertM is a more general operator that provides greater control over the handling of\nduplicate elements in addition to running in a monad.Examples:* #[0, 1, 3, 5].binInsert (· < ·) 2 = #[0, 1, 2, 3, 5]* #[0, 1, 3, 5].binInsert (· < ·) 1 = #[0, 1, 3, 5]* #[].binInsert (· < ·) 1 = #[1]\n\nInserts an element k into a sorted array as such that the resulting array is sorted.The ordering predicate lt should be a total order on elements, and the array as should be sorted\nwith respect to lt.If an element that lt equates to k is already present in as, then merge is applied to the\nexisting element to determine the value of that position in the resulting array. If no element equal\nto k is present, then add is used to determine the value to be inserted.\n\nBinary search for an element equivalent to k in the sorted array as. Returns the element from\nthe array, if it is found, or none otherwise.The array as must be sorted according to the comparison operator lt, which should be a total\norder.The optional parameters lo and hi determine the region of the array indices to be searched. Both\nare inclusive, and default to searching the entire array.\n\nBinary search for an element equivalent to k in the sorted array as. Returns true if the\nelement is found, or false otherwise.The array as must be sorted according to the comparison operator lt, which should be a total\norder.The optional parameters lo and hi determine the region of the array indices to be searched. Both\nare inclusive, and default to searching the entire array.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.7. Sorted Arrays","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Sorted-Arrays"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Comparisons":{"contents":"Most comparisons on Booleans should be performed using the DecidableEq Bool, LT Bool, LE Bool instances.\n\nDecides whether two Booleans are equal.This function should normally be called via the DecidableEq Bool instance that it exists to\nsupport.\n\n","context":"Lean Reference\u0009Basic Types\u0009Booleans\u0009API Reference","header":"19.11.4.2. Comparisons","id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference--Comparisons"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Search-Path-Helpers":{"contents":"Get the detected LEAN_PATH value of the Lake environment.\n\nGet the detected LEAN_SRC_PATH value of the Lake environment.\n\nGet the detected sharedLibPathEnvVar value of the Lake environment.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference\u0009Accessing the Environment","header":"22.1.4.1.1. Search Path Helpers","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Search-Path-Helpers"},"/Definitions/Theorems/#The-Lean-Language-Reference--Definitions--Theorems":{"contents":"Because propositions are types whose inhabitants count as proofs, theorems and definitions are technically very similar.\nHowever, because their use cases are quite different, they differ in many details:* The theorem statement must be a proposition.\n  The types of definitions may inhabit any universe.* A theorem's header (that is, the theorem statement) is completely elaborated before the body is elaborated.\n  Section variables only become parameters to the theorem if they (or their dependents) are mentioned in the header.\n  This prevents changes to a proof from unintentionally changing the theorem statement.* Theorems are irreducible by default.\n  Because all proofs of the same proposition are definitionally equal, there few reasons to unfold a theorem.\n\nTheorems may be recursive, subject to the same conditions as recursive function definitions.\nHowever, it is more common to use tactics such as induction or fun_induction instead.\n\nTheoremsThe syntax of theorems is like that of definitions, except the codomain (that is, the theorem statement) in the signature is mandatory.\n\n","context":"Lean Reference\u0009Definitions","header":"7.4. Theorems","id":"/Definitions/Theorems/#The-Lean-Language-Reference--Definitions--Theorems"},"/Interacting-with-Lean/#format-render":{"contents":"The ToString Std.Format instance invokes Std.Format.pretty with its default arguments.\n\nThere are two ways to render a document:\n\n* Use pretty to construct a String.\n  The entire string must be constructed up front before any can be sent to a user.* Use prettyM to incrementally emit the String, using effects in some Monad.\n  As soon as each line is rendered, it is emitted.\n  This is suitable for streaming output.\n\nRenders a Format to a string.* width: the total width* indent: the initial indentation to use for wrapped lines\n(subsequent wrapping may increase the indentation)* column: begin the first line wrap column characters earlier than usual\n(this is useful when the output String will be printed starting at column)\n\nThe default width of the targeted output, which is 120 columns.\n\nRenders a Format using effects in the monad m, using the methods of MonadPrettyFormat.Each line is emitted as soon as it is rendered, rather than waiting for the entire document to be\nrendered.* w: the total width* indent: the initial indentation to use for wrapped lines (subsequent wrapping may increase the\nindentation)\n\nA monad that can be used to incrementally render Format objects.Emits the string s.Emits a newline followed by indent columns of indentation.Gets the current column at which the next string will be emitted.Starts a region tagged with tag.Exits the scope of count opened tags.\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","header":"3.7.1.6. Rendering","id":"/Interacting-with-Lean/#format-render"}});