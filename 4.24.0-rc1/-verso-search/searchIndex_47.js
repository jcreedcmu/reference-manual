window.docContents[47].resolve({"/Basic-Types/The-Empty-Type/#empty":{"contents":"The empty type Empty represents impossible values.\nIt is an inductive type with no constructors whatsoever.\n\nWhile the trivial type Unit, which has a single constructor that takes no parameters, can be used to model computations where a result is unwanted or uninteresting, Empty can be used in situations where no computation should be possible at all.\nInstantiating a polymorphic type with Empty can mark some of its constructors—those with a parameter of the corresponding type—as impossible; this can rule out certain code paths that are not desired.\n\nThe presence of a term with type Empty indicates that an impossible code path has been reached.\nThere will never be a value with this type, due to the lack of constructors.\nOn an impossible code path, there's no reason to write further code; the function Empty.elim can be used to escape an impossible path.\n\nThe universe-polymorphic equivalent of Empty is PEmpty.\n\nThe empty type. It has no constructors.Use Empty.elim in contexts where a value of type Empty is in scope.\n\nThe universe-polymorphic empty type, with no constructors.PEmpty can be used in any universe, but this flexibility can lead to worse error messages and more\nchallenges with universe level unification. Prefer the type Empty or the proposition False when\npossible.\n\nImpossible Code PathsThe type signature of the function f indicates that it might throw exceptions, but allows the exception type to be anything:def f (n : Nat) : Except ε Nat := pure n\nInstantiating f's exception type with Empty exploits the fact that f never actually throws an exception to convert it to a function whose type indicates that no exceptions will be thrown.\nIn particular, it allows Empty.elim to be used to avoid handing the impossible exception value.def g (n : Nat) : Nat :=\n  match f (ε := Empty) n with\n  | .error e =>\n    Empty.elim e\n  | .ok v => v\n\n\n\n\n","context":"Lean Reference\u0009Basic Types","header":"19.10. The Empty Type","id":"/Basic-Types/The-Empty-Type/#empty"},"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions":{"contents":"Definitions add a new constant to the global environment as a name that stands for a term.\nAs part of the kernel's definitional equality, this new constant may be replaced via δ-reduction with the term that it stands for.\nIn the elaborator, this replacement is governed by the constant's reducibility.\nThe new constant may be universe polymorphic, in which case occurrences may instantiate it with different universe level parameters.\n\nFunction definitions may be recursive.\nTo preserve the consistency of Lean's type theory as a logic, recursive functions must either be opaque to the kernel (e.g. by declaring them partial) or proven to terminate with one of the strategies described in the section on recursive definitions.\n\nThe headers and bodies of definitions are elaborated together.\nIf the header is incompletely specified (e.g. a parameter's type or the codomain is missing), then the body may provide sufficient information for the elaborator to reconstruct the missing parts.\nHowever, instance implicit parameters must be specified in the header or as section variables.\n\nDefinitionsDefinitions that use := associate the term on the right-hand side with the constant's name.\nThe term is wrapped in a fun for each parameter, and the type is found by binding the parameters in a function type.\nDefinitions with def are semireducible.Definitions may use pattern matching.\nThese definitions are desugared to uses of match.Values of structure types, or functions that return them, may be defined by providing values for their fields, following where:\n\nAbbreviationsAbbreviations are identical to definitions with def, except they are reducible.\n\nOpaque constants are defined constants that are not subject to δ-reduction in the kernel.\nThey are useful for specifying the existence of some function.\nUnlike axioms, opaque declarations can only be used for types that are inhabited, so they do not risk introducing inconsistency.\nAlso unlike axioms, the inhabitant of the type is used in compiled code.\nThe implemented_by attribute can be used to instruct the compiler to emit a call to some other function as the compilation of an opaque constant.\n\nOpaque ConstantsOpaque definitions with right-hand sides are elaborated like other definitions.\nThis demonstrates that the type is inhabited; the inhabitant plays no further role.Opaque constants may also be specified without right-hand sides.\nThe elaborator fills in the right-hand side by synthesizing an instance of Inhabited, or Nonempty if that fails.\n\n","context":"Lean Reference\u0009Definitions","header":"7.3. Definitions","id":"/Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions"},"/Definitions/Headers-and-Signatures/#parameter-syntax":{"contents":"After the name, if present, is the header's signature.\nThe signature specifies the declaration's parameters and type.\n\nDeclaration SignaturesA signature consists of zero or more parameters, followed by a colon and a type.\n\nOptional SignaturesSignatures are often optional.\nIn these cases, parameters may be supplied even if the type is omitted.\n\nParameters may have three forms:\n\n* An identifier, which names a parameter but does not provide a type.\n   These parameters' types must be inferred during elaboration.* An underscore (_), which indicates a parameter that is not accessible by name in the local scope.\n   These parameters' types must also be inferred during elaboration.* A bracketed binder, which may specify every aspect of one or more parameters, including their names, their types, default values, and whether they are explicit, implicit, strictly implicit, or instance-implicit.\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.2. Parameters and Types","id":"/Definitions/Headers-and-Signatures/#parameter-syntax"},"/Interacting-with-Lean/#interaction":{"contents":"Lean is designed for interactive use, rather than as a batch-mode system in which whole files are fed in and then translated to either object code or error messages.\nMany programming languages designed for interactive use provide a REPL,Short for “Read-Eval-Print Loop”, because code is parsed (“read”), evaluated, and the result displayed, with this process repeated as many times as desired. at which code can be input and tested, along with commands for loading source files, type checking terms, or querying the environment.\nLean's interactive features are based on a different paradigm.\nRather than a separate command prompt outside of the program, Lean provides commands for accomplishing the same tasks in the context of a source file.\nBy convention, commands that are intended for interactive use rather than as part of a durable code artifact are prefixed with #.\n\nInformation from Lean commands is available in the message log, which accumulates output from the elaborator.\nEach entry in the message log is associated with a specific source range and has a severity.\nThere are three severities: information is used for messages that do not indicate a problem, warning indicates a potential problem, and error indicates a definite problem.\nFor interactive commands, results are typically returned as informational messages that are associated with the command's leading keyword.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"3. Interacting with Lean","id":"/Interacting-with-Lean/#interaction"}});