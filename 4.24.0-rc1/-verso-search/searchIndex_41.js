window.docContents[41].resolve({"/Basic-Types/Strings/#string-syntax":{"contents":"Lean has three kinds of string literals: ordinary string literals, interpolated string literals, and raw string literals.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings","header":"19.8.3. Syntax","id":"/Basic-Types/Strings/#string-syntax"},"/Definitions/Recursive-Definitions/#partial-fixpoint-tailrec":{"contents":"A recursive function can be defined as a partial fixpoint if the following two conditions hold:1. The function's return type is inhabited (as with functions marked partial) - either a Nonempty or Inhabited instance works.2. All recursive calls are in tail position of the function.An expression is in tail position in the function body if it is:* the function body itself,* the branches of a match expression that is in tail position,* the branches of an if expression that is in tail position, and* the body of a let expression that is in tail position.In particular, the discriminant of a match expression, the condition of an if expression and the arguments of functions are not tail positions.\n\n\n\nLoops are Tail Recursive FunctionsBecause the function body itself is a tail position, the infinitely looping function loop is tail recursive.\nIt can be defined as a partial fixpoint.def loop (x : Nat) : Nat := loop (x + 1)\npartial_fixpoint\n\n\nTail Recursion with BranchingArray.find could also be constructed using well-founded recursion with a termination proof, but may be more convenient to define using partial_fixpoint, where no termination proof is needed.def Array.find (xs : Array α) (p : α → Bool)\n    (i : Nat := 0) : Option α :=\n  if h : i < xs.size then\n    if p xs[i] then\n      some xs[i]\n    else\n      Array.find xs p (i + 1)\n  else\n    none\npartial_fixpoint\nIf the result of the recursive call is not just returned, but passed to another function, it is not in tail position and this definition fails.def List.findIndex (xs : List α) (p : α → Bool) : Int :=\n  match xs with\n  | [] => -1\n  | x::ys =>\n    if p x then\n      0\n    else\n      have r := List.findIndex ys p\n      if r = -1 then -1 else r + 1\npartial_fixpoint\nThe error message on the recursive call is:Could not prove 'List.findIndex' to be monotone in its recursive calls:\n  Cannot eliminate recursive call `List.findIndex ys p` enclosed in\n    if ys✝.findIndex p = -1 then -1 else ys✝.findIndex p + 1\n  Tried to apply 'monotone_ite', but failed.\n  Possible cause: A missing `MonoBind` instance.\n  Use `set_option trace.Elab.Tactic.monotonicity true` to debug.\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","header":"7.6.4.1. Tail-Recursive Functions","id":"/Definitions/Recursive-Definitions/#partial-fixpoint-tailrec"},"/Definitions/Recursive-Definitions/#partial-unsafe":{"contents":"While most Lean functions can be reasoned about in Lean's type theory as well as compiled and run, definitions marked partial or unsafe cannot be meaningfully reasoned about.\nFrom the perspective of the logic, partial functions are opaque constants, and theorems that refer to unsafe definitions are summarily rejected.\nIn exchange for the inability to use these functions for reasoning, there are far fewer requirements placed on them; this can make it possible to write programs that would be impractical or cost-prohibitive to prove anything about, while not giving up formal reasoning for the rest.\nIn essence, the partial subset of Lean is a traditional functional programming language that is nonetheless deeply integrated with the theorem proving features, and the unsafe subset features the ability to break Lean's runtime invariants in certain rare situations, at the cost of less integration with Lean's theorem-proving features.\nAnalogously, noncomputable definitions may use features that don't make sense in programs, but are meaningful in the logic.\n\n\n\n\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","header":"7.6.5. Partial and Unsafe Definitions","id":"/Definitions/Recursive-Definitions/#partial-unsafe"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity":{"contents":"ac_nf normalizes equalities up to application of an associative and commutative operator.* ac_nf normalizes all hypotheses and the goal target of the goal.* ac_nf at l normalizes at location(s) l, where l is either * or a\nlist of hypotheses in the local context. In the latter case, a turnstile ⊢ or |-\ncan also be used, to signify the target of the goal.instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n\n\nImplementation of ac_nf (the full ac_nf calls trivial afterwards).\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","header":"13.5.5. Associativity and Commutativity","id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-associativity-commutativity"},"/Terms/Structures-and-Constructors/#The-Lean-Language-Reference--Terms--Structures-and-Constructors":{"contents":"Anonymous constructors and structure instance syntax are described in their respective sections.\n\n","context":"Lean Reference\u0009Terms","header":"10.6. Structures and Constructors","id":"/Terms/Structures-and-Constructors/#The-Lean-Language-Reference--Terms--Structures-and-Constructors"}});