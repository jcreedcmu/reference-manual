window.docContents[27].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants":{"contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the modules Std.HashSet.Raw and Std.HashSet.RawLemmas.\n\nHash sets without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer HashSet\nover HashSet.Raw. Lemmas about the operations on Std.Data.HashSet.Raw are available in the\nmodule Std.Data.HashSet.RawLemmas.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.Internal implementation detail of the hash set.\n\nWell-formedness predicate for hash sets. Users of HashSet will not need to interact with this.\nUsers of HashSet.Raw will need to provide proofs of WF to lemmas and should use lemmas like\nWF.empty and WF.insert (which are always named exactly like the operations they are about) to\nshow that set operations preserve well-formedness.Internal implementation detail of the hash set\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Sets","header":"19.17.6.7. Unbundled Variants","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Sets--Unbundled-Variants"},"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases":{"contents":"A number of aliases are provided for commonly-used typed syntax varieties.\nThese aliases allow code to be written at a higher level of abstraction.\n\nSyntax that represents a Lean term.\n\nSyntax that represents a command.\n\nSyntax that represents a universe level.\n\nSyntax that represents a tactic.\n\nSyntax that represents a precedence (e.g. for an operator).\n\nSyntax that represents a priority (e.g. for an instance declaration).\n\nSyntax that represents an identifier.\n\nSyntax that represents a string literal.\n\nSyntax that represents a character literal.\n\nSyntax that represents a quoted name literal that begins with a back-tick.\n\nSyntax that represents a numeric literal.\n\nSyntax that represents a scientific numeric literal that may have decimal and exponential parts.\n\nSyntax that represents macro hygiene info.\n\n","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","header":"20.4.8. Aliases","id":"/Notations-and-Macros/Defining-New-Syntax/#The-Lean-Language-Reference--Notations-and-Macros--Defining-New-Syntax--Aliases"}});