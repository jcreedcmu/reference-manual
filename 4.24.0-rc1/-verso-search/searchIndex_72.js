window.docContents[72].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification":{"contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Dependent Hash Maps","header":"19.17.5.4. Modification","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Dependent-Hash-Maps--Modification"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets":{"contents":"Targets are typically added to the set of default targets by applying the default_target attribute, rather than by explicitly listing them.\n\n\n\nSpecifying Default TargetsMarks a target as a default, to be built when no other target is specified.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","header":"22.1.3.2.4. Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets"},"/Interacting-with-Lean/#repr":{"contents":"A Repr instance describes how to represent a value as a Std.Format.\nBecause they should emit valid Lean syntax, these instances need to take precedence into account.\nInserting the maximal number of parentheses would work, but it makes it more difficult for humans to read the resulting output.\n\nThe standard way of turning values of some type into Format.When rendered this Format should be as close as possible to something that can be parsed as the\ninput value.Turn a value of type α into a Format at a given precedence. The precedence value can be used\nto avoid parentheses if they are not necessary.\n\nTurns a into a Format using its Repr instance. The precedence level is initially set to 0.\n\nTurns a into a String using its Repr instance, rendering the Format at the default width of\n120 columns.The precedence level is initially set to 0.\n\nMaximal ParenthesesThe type NatOrInt can contain a Nat or an Int:inductive NatOrInt where\n  | nat : Nat → NatOrInt\n  | int : Int → NatOrInt\nThis Repr NatOrInt instance ensures that the output is valid Lean syntax by inserting many parentheses:instance : Repr NatOrInt where\n  reprPrec x _ :=\n    .nestD <| .group <|\n      match x with\n      | .nat n =>\n          .text \"(\" ++ \"NatOrInt.nat\" ++ .line ++ \"(\" ++ repr n ++ \"))\"\n      | .int i =>\n          .text \"(\" ++ \"NatOrInt.int\" ++ .line ++ \"(\" ++ repr i ++ \"))\"\nWhether it contains a Nat, a non-negative Int, or a negative Int, the result can be parsed:open NatOrInt in\n#eval do\n  IO.println <| repr <| nat 3\n  IO.println <| repr <| int 5\n  IO.println <| repr <| int (-5)\n(NatOrInt.nat (3))\n(NatOrInt.int (5))\n(NatOrInt.int (-5))\nHowever, (NatOrInt.nat (3)) is not particularly idiomatic Lean, and redundant parentheses can make it difficult to read large expressions.\n\nThe method Repr.reprPrec has the following signature:\n\nRepr.reprPrec.{u} {α : Type u} [Repr α] : α → Nat → Std.Format\n\n\nThe first explicit parameter is the value to be represented, while the second is the precedence of the context in which it occurs.\nThis precedence can be used to decide whether to insert parentheses: if the precedence of the syntax being produced by the instance is greater than that of its context, parentheses are necessary.\n\n\n\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output","header":"3.7.2. Repr","id":"/Interacting-with-Lean/#repr"}});