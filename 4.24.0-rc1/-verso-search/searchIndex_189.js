window.docContents[189].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Conversion":{"contents":"Converts an optional value to an array with zero or one element.Examples:* (some \"value\").toArray = #[\"value\"]* none.toArray = #[]\n\nConverts an optional value to a list with zero or one element.Examples:* (some \"value\").toList = [\"value\"]* none.toList = []\n\nReturns a representation of an optional value that should be able to be parsed as an equivalent\noptional value.This function is typically accessed through the Repr (Option α) instance.\n\nFormats an optional value, with no expectation that the Lean parser should be able to parse the\nresult.This function is usually accessed through the ToFormat (Option α) instance.\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.3. Conversion","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Conversion"},"/Build-Tools-and-Distribution/Lake/#lake-vocab":{"contents":"A package is the basic unit of Lean code distribution.\nA single package may contain multiple libraries or executable programs.\nA package consist of a directory that contains a package configuration file together with source code.\nPackages may require other packages, in which case those packages' code (more specifically, their targets) are made available.\nThe direct dependencies of a package are those that it requires, and the transitive dependencies are the direct dependencies of a package together with their transitive dependencies.\nPackages may either be obtained from Reservoir, the Lean package repository, or from a manually-specified location.\nGit dependencies are specified by a Git repository URL along with a revision (branch, tag, or hash) and must be cloned locally prior to build, while local path dependencies are specified by a path relative to the package's directory.\n\nA workspace is a directory on disk that contains a working copy of a package's source code and the source code of all transitive dependencies that are not specified as local paths.\nThe package for which the workspace was created is the root package.\nThe workspace also contains any built artifacts for the package, enabling incremental builds.\nDependencies and artifacts do not need to be present for a directory to be considered a workspace; commands such as update and build produce them if they are missing.\nLake is typically used in a workspace.init and new, which create workspaces, are exceptions.\nWorkspaces typically have the following layout:* lean-toolchain - The toolchain file.* lakefile.toml or lakefile.lean - The package configuration file for the root package.* lake-manifest.json - The root package's manifest.* .lake/ - Intermediate state managed by Lake, such as built artifacts and dependency source code.* .lake/lakefile.olean - The root package's configuration, cached.* .lake/packages/ - The workspace's package directory, which contains copies of all non-local transitive dependencies of the root package, with their built artifacts in their own .lake directories.* .lake/build/ - The build directory, which contains built artifacts for the root package:* .lake/build/bin - The package's binary directory, which contains built executables.* .lake/build/lib - The package's library directory, which contains built libraries and .olean files.* .lake/build/ir - The package's intermediate result directory, which contains generated intermediate artifacts, primarily C code.\n\nWorkspace Layout \n\nA package configuration file specifies the dependencies, settings, and targets of a package.\nPackages can specify configuration options that apply to all their contained targets.\nThey can be written in two formats:* The TOML format (lakefile.toml) is used for fully declarative package configurations.* The Lean format (lakefile.lean) additionally supports the use of Lean code to configure the package in ways not supported by the declarative options.\n\nA manifest tracks the specific versions of other packages that are used in a package.\nTogether, a manifest and a package configuration file specify a unique set of transitive dependencies for the package.\nBefore building, Lake synchronizes the local copy of each dependency with the version specified in the manifest.\nIf no manifest is available, Lake fetches the latest matching versions of each dependency and creates a manifest.\nIt is an error if the package names listed in the manifest do not match those used by the package; the manifest must be updated using update prior to building.\nManifests should be considered part of the package's code and should normally be checked into source control.\n\nA target represents an output that can be requested by a user.\nA persistent build output, such as object code, an executable binary, or an .olean file, is called an artifact.\nIn the process of producing an artifact, Lake may need to produce further artifacts; for example, compiling a Lean program into an executable requires that it and its dependencies be compiled to object files, which are themselves produced from C source files, which result from elaborating Lean sourcefiles and producing .olean files.\nEach link in this chain is a target, and Lake arranges for each to be built in turn.\nAt the start of the chain are the initial targets:* Packages are units of Lean code that are distributed as a unit.* Libraries are collections of Lean modules, organized hierarchically under one or more module roots.* Executables consist of a single module that defines main.* External libraries are non-Lean static libraries that will be linked to the binaries of the package and its dependents, including both their shared libraries and executables.* Custom targets contain arbitrary code to run a build, written using Lake's internal API.In addition to their Lean code, packages, libraries, and executables contain configuration settings that affect subsequent build steps.\nPackages may specify a set of default targets.\nDefault targets are the initial targets in the package that are to be built in contexts where a package is specified but specific targets are not.\n\nThe log contains information produced during a build.\nLogs are saved so they can be replayed during incremental builds.\nMessages in the log have four levels, ordered by severity:1. Trace messages contain internal build details that are often specific to the machine on which the build is running, including the specific invocations of Lean and other tools that are passed to the shell.2. Informational messages contain general informational output that is not expected to indicate a problem with the code, such as the results of a #eval command.3. Warnings indicate potential problems, such as unused variable bindings.4. Errors explain why parsing and elaboration could not complete.By default, trace messages are hidden and the others are shown.\nThe threshold can be adjusted using the --log-level option, the --verbose flag, or the --quiet flag.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake","header":"22.1.1. Concepts and Terminology","id":"/Build-Tools-and-Distribution/Lake/#lake-vocab"},"/Introduction/#example-boxes":{"contents":"Illustrative examples are in callout boxes, as below:\n\nEven NumbersThis is an example of an example.One way to define even numbers is via an inductive predicate:inductive Even : Nat → Prop where\n  | zero : Even 0\n  | plusTwo : Even n → Even (n + 2)\n\n\n","context":"Lean Reference\u0009Introduction\u0009Typographical Conventions","header":"1.2.2. Examples","id":"/Introduction/#example-boxes"}});