window.docContents[78].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Conversions":{"contents":"Converts an Array α into a List α that contains the same elements in the same order.At runtime, this is implemented by Array.toListImpl and is O(n) in the length of the\narray.\n\nConverts an array to a list that contains the same elements in the opposite order.This is equivalent to, but more efficient than, Array.toList ∘ List.reverse.Examples:* #[1, 2, 3].toListRev = [3, 2, 1]* #[\"blue\", \"yellow\"].toListRev = [\"yellow\", \"blue\"]\n\nPrepends an array to a list. The elements of the array are at the beginning of the resulting list.Equivalent to as.toList ++ l.Examples:* #[1, 2].toListAppend [3, 4] = [1, 2, 3, 4]* #[1, 2].toListAppend [] = [1, 2]* #[].toListAppend [3, 4, 5] = [3, 4, 5]\n\nConverts an array to a vector. The resulting vector's size is the array's size.\n\nReturns a subarray of an array, with the given bounds.If start or stop are not valid bounds for a subarray, then they are clamped to array's size.\nAdditionally, the starting index is clamped to the ending index.\n\nAllocates a new array that contains the contents of the subarray.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009API Reference","header":"19.16.4.5. Conversions","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--API-Reference--Conversions"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic":{"contents":"If no decreasing_by clause is given, then the decreasing_tactic is used implicitly, and applied to each proof obligation separately.\n\nThe tactic decreasing_tactic mainly deals with lexicographic ordering of tuples, applying Prod.Lex.right if the left components of the product are definitionally equal, and Prod.Lex.left otherwise.\nAfter preprocessing tuples this way, it calls the decreasing_trivial tactic.\n\nExtensible helper tactic for decreasing_tactic. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.macro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\nThe tactic decreasing_trivial is an extensible tactic that applies a few common heuristics to solve a termination goal.\nIn particular, it tries the following tactics and theorems:* simp_arith* assumption* theorems Nat.sub_succ_lt_self, Nat.pred_lt_of_lt, and Nat.pred_lt, which handle common arithmetic goals* omega* array_get_dec and array_mem_dec, which prove that the size of array elements is less than the size of the array* sizeOf_list_dec that the size of list elements is less than the size of the list* String.Iterator.sizeOf_next_lt_of_hasNext and String.Iterator.sizeOf_next_lt_of_atEnd, to handle iteration through a string using  forThis tactic is intended to be extended with further heuristics using macro_rules.\n\nNo Backtracking of Lexicographic OrderA classic example of a recursive function that needs a more complex measure is the Ackermann function:def ack : Nat → Nat → Nat\n  | 0,     n     => n + 1\n  | m + 1, 0     => ack m 1\n  | m + 1, n + 1 => ack m (ack (m + 1) n)\ntermination_by m n => (m, n)\nThe measure is a tuple, so every recursive call has to be on arguments that are lexicographically smaller than the parameters.\nThe default decreasing_tactic can handle this.In particular, note that the third recursive call has a second argument that is smaller than the second parameter and a first argument that is definitionally equal to the first parameter.\nThis allowed  decreasing_tactic to apply Prod.Lex.right.Prod.Lex.right {α β} {ra : α → α → Prop} {rb : β → β → Prop}\n  (a : α) {b₁ b₂ : β}\n  (h : rb b₁ b₂) :\n  Prod.Lex ra rb (a, b₁) (a, b₂)\nIt fails, however, with the following modified function definition, where the third recursive call's first argument is provably smaller or equal to the first parameter, but not syntactically equal:def synack : Nat → Nat → Nat\n  | 0,     n     => n + 1\n  | m + 1, 0     => synack m 1\n  | m + 1, n + 1 => synack m (synack (m / 2 + 1) n)\ntermination_by m n => (m, n)\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\ncase h\nm n : Nat\n⊢ m / 2 + 1 < m + 1\nBecause Prod.Lex.right is not applicable, the tactic used Prod.Lex.left, which resulted in the unprovable goal above.This function definition may require a manual proof that uses the more general theorem Prod.Lex.right', which allows the first component of the tuple (which must be of type Nat) to be less or equal instead of strictly equal:Prod.Lex.right' {β} (rb : β → β → Prop)\n  {a₂ : Nat} {b₂ : β} {a₁ : Nat} {b₁ : β}\n  (h₁ : a₁ ≤ a₂) (h₂ : rb b₁ b₂) :\n  Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)\ndef synack : Nat → Nat → Nat\n  | 0, n => n + 1\n  | m + 1, 0 => synack m 1\n  | m + 1, n + 1 => synack m (synack (m / 2 + 1) n)\ntermination_by m n => (m, n)\ndecreasing_by\n  · apply Prod.Lex.left\n    omega\n  -- the next goal corresponds to the third recursive call\n  · apply Prod.Lex.right'\n    · omega\n    · omega\n  · apply Prod.Lex.left\n    omega\nThe decreasing_tactic tactic does not use the stronger Prod.Lex.right' because it would require backtracking on failure.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","header":"7.6.3.3. Default Termination Proof Tactic","id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Default-Termination-Proof-Tactic"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Interacting-with-the-Filesystem":{"contents":"Some operations on paths consult the filesystem.\n\nFile metadata.The metadata for a file can be accessed with System.FilePath.metadata/\nSystem.FilePath.symlinkMetadata.File access time.File modification time.The size of the file in bytes.Whether the file is an ordinary file, a directory, a symbolic link, or some other kind of file.\n\nReturns metadata for the indicated file, following symlinks. Throws an exception if the file does\nnot exist or the metadata cannot be accessed.\n\nChecks whether the indicated path points to a file that exists. This function will traverse\nsymlinks.\n\nChecks whether the indicated path can be read and is a directory. This function will traverse\nsymlinks.\n\nAn entry in a directory on a filesystem.The directory in which the entry is found.The name of the entry.\n\nThe path of the file indicated by the directory entry.\n\nReturns the contents of the indicated directory. Throws an exception if the file does not exist or\nis not a directory.\n\nTraverses a filesystem starting at the path p and exploring directories that satisfy enter,\nreturning the paths visited.The traversal is a preorder traversal, in which parent directories occur prior to any of their\nchildren. Symbolic links are followed.\n\nPOSIX-style file permissions.The FileRight structure describes these permissions for a file's owner, members of it's designated\ngroup, and all others.The file can be read.The file can be written to.The file can be executed.\n\nConverts individual POSIX-style file permissions to their conventional three-bit representation.This is the bitwise or of the following:* If the file can be read, 0x4, otherwise 0.* If the file can be written, 0x2, otherwise 0.* If the file can be executed, 0x1, otherwise 0.Examples:* {read := true : AccessRight}.flags = 4* {read := true, write := true : AccessRight}.flags = 6* {read := true, execution := true : AccessRight}.flags = 5\n\nPOSIX-style file permissions that describe access rights for a file's owner, members of its\nassigned group, and all others.The owner's permissions to access the file.The assigned group's permissions to access the file.The permissions that all others have to access the file.\n\nConverts POSIX-style file permissions to their numeric representation, with three bits each for the\nowner's permissions, the group's permissions, and others' permissions.\n\nSets the POSIX-style permissions for a file.\n\nRemoves (deletes) a file from the filesystem.To remove a directory, use IO.FS.removeDir or IO.FS.removeDirAll instead.\n\nMoves a file or directory old to the new location new.This function coincides with the POSIX rename\nfunction.\n\nRemoves (deletes) a directory.Removing a directory fails if the directory is not empty. Use IO.FS.removeDirAll to remove\ndirectories along with their contents.\n\nReturns the contents of a UTF-8-encoded text file as an array of lines.Newline markers are not included in the lines.\n\nCreates a temporary file in the most secure manner possible and calls f with both a Handle to\nthe already-opened file and its path. Afterwards, the temporary file is deleted.There are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.Use IO.FS.createTempFile to avoid the automatic deletion of the temporary file.\n\nCreates a temporary directory in the most secure manner possible, providing a its path to an IO\naction. Afterwards, all files in the temporary directory are recursively deleted, regardless of how\nor when they were created.There are no race conditions in the directory’s creation. The directory is readable and writable\nonly by the creating user ID. Use IO.FS.createTempDir to avoid the automatic deletion of the\ndirectory's contents.\n\nCreates a directory at the specified path, creating all missing parents as directories.\n\nWrite the provided bytes to a binary file at the specified path.\n\nOpens the file fn with the specified mode and passes the resulting file handle to f.The file handle is closed when the last reference to it is dropped. If references escape f, then\nthe file remains open even after IO.FS.withFile has finished.\n\nFully remove given directory by deleting all contained files and directories in an unspecified order.\nSymlinks are deleted but not followed. Fails if any contained entry cannot be deleted or was newly\ncreated during execution.\n\nCreates a temporary file in the most secure manner possible, returning both a Handle to the\nalready-opened file and its path.There are no race conditions in the file’s creation. The file is readable and writable only by the\ncreating user ID. Additionally on UNIX style platforms the file is executable by nobody.It is the caller's job to remove the file after use. Use withTempFile to ensure that the temporary\nfile is removed.\n\nCreates a temporary directory in the most secure manner possible, returning the new directory's\npath. There are no race conditions in the directory’s creation. The directory is readable and\nwritable only by the creating user ID.It is the caller's job to remove the directory after use. Use withTempDir to ensure that the\ntemporary directory is removed.\n\nReads the entire contents of the UTF-8-encoded file at the given path as a String.An exception is thrown if the contents of the file are not valid UTF-8. This is in addition to\nexceptions that may always be thrown as a result of failing to read files.\n\nResolves a path to an absolute path that contains no '.', '..', or symbolic links.This function coincides with the POSIX realpath\nfunction.\n\nWrite contents of a string to a file at the specified path using UTF-8 encoding.\n\nReads the entire contents of the binary file at the given path as an array of bytes.\n\nCreates a directory at the specified path. The parent directory must already exist.Throws an exception if the directory cannot be created.\n\n","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","header":"15.5.4. Interacting with the Filesystem","id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Interacting-with-the-Filesystem"}});