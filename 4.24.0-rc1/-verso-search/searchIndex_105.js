window.docContents[105].resolve({"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-cli":{"contents":"In addition to the proxies that automatically select, install, and invoke the correct versions of Lean tools, Elan provides a command-line interface for querying and configuring its settings.\nThis tool is called elan.\nLike Lake, its command-line interface is structured around subcommands.\n\nElan can be invoked with following flags:\n\n --help or -h\n\nDescribes the current subcommand in detail.\n\n --verbose or -v\n\nEnables verbose output.\n\n --version or -V\n\nDisplays the Elan version.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Elan","header":"22.2.3. Command-Line Interface","id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-cli"},"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--System-Randomness":{"contents":"Reads bytes from a system entropy source. It is not guaranteed to be cryptographically secure.If nBytes is 0, returns immediately with an empty buffer.\n\n","context":"Lean Reference\u0009IO\u0009Random Numbers","header":"15.10.2. System Randomness","id":"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--System-Randomness"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Priorities":{"contents":"Task priorities are used by the thread scheduler to assign tasks to threads.\nWithin the priority range default–max, higher-priority tasks always take precedence over lower-priority tasks.\nTasks spawned with priority dedicated are assigned their own dedicated threads and do not contend with other tasks for the threads in the thread pool.\n\nTask priority.Tasks with higher priority will always be scheduled before tasks with lower priority. Tasks with a\npriority greater than Task.Priority.max are scheduled on dedicated threads.\n\nThe default priority for spawned tasks, also the lowest priority: 0.\n\nThe highest regular priority for spawned tasks: 8.Spawning a task with a priority higher than Task.Priority.max is not an error but will spawn a\ndedicated worker for the task. This is indicated using Task.Priority.dedicated. Regular priority\ntasks are placed in a thread pool and worked on according to their priority order.\n\nIndicates that a task should be scheduled on a dedicated thread.Any priority higher than Task.Priority.max will result in the task being scheduled\nimmediately on a dedicated thread. This is particularly useful for long-running and/or\nI/O-bound tasks since Lean will, by default, allocate no more non-dedicated workers\nthan the number of cores to reduce context switches.\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Creating Tasks","header":"15.11.1.3. Priorities","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Creating-Tasks--Priorities"},"/The-Type-System/Inductive-Types/#strict-positivity":{"contents":"All occurrences of the type being defined in the types of the parameters of the constructors must be in strictly positive positions.\nA position is strictly positive if it is not in a function's argument type (no matter how many function types are nested around it) and it is not an argument of any expression other than type constructors of inductive types.\nThis restriction rules out unsound inductive type definitions, at the cost of also ruling out some unproblematic ones.\n\nNon-strictly-positive inductive typesThe type Bad would make Lean inconsistent if it were not rejected:inductive Bad where\n  | bad : (Bad → Bad) → Bad\n(kernel) arg #1 of 'Bad.bad' has a non positive occurrence of the datatypes being declared\nThis is because it would be possible to write a circular argument that proves False under the assumption Bad.\nBad.bad is rejected because the constructor's parameter has type Bad → Bad, which is a function type in which Bad occurs as an argument type.This declaration of a fixed point operator is rejected, because Fix occurs as an argument to f:inductive Fix (f : Type u → Type u) where\n  | fix : f (Fix f) → Fix f\n(kernel) arg #2 of 'Fix.fix' contains a non valid occurrence of the datatypes being declared\nFix.fix is rejected because f is not a type constructor of an inductive type, but Fix itself occurs as an argument to it.\nIn this case, Fix is also sufficient to construct a type equivalent to Bad:def Bad : Type := Fix fun t => t → t\n\n\n","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Well-Formedness Requirements","header":"4.4.3.2.2. Strict Positivity","id":"/The-Type-System/Inductive-Types/#strict-positivity"}});