window.docContents[74].resolve({"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties":{"contents":"Returns true if the tree set contains no mappings.\n\nReturns the number of mappings present in the map.\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","header":"19.17.10.2. Properties","id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties"},"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters":{"contents":"By default, otherwise-unbound names that occur in signatures are converted into implicit parameters when possible\nThese parameters are called automatic implicit parameters.\nThis is possible when they are not in the function position of an application and when there is sufficient information available in the signature to infer their type and any ordering constraints on them.\nThis process is iterated: if the inferred type for the freshly-inserted implicit parameter has dependencies that are not uniquely determined, then these dependencies are replaced with further implicit parameters.\n\nImplicit parameters that don't correspond to names written in signatures are assigned names akin to those of inaccessible hypotheses in proofs, which cannot be referred to.\nThey show up in signatures with a trailing dagger ('✝').\nThis prevents an arbitrary choice of name by Lean from becoming part of the API by being usable as a named argument.\n\nAutomatic Implicit ParametersIn this definition of map, α and β are not explicitly bound.\nRather than this being an error, they are converted into implicit parameters.\nBecause they must be types, but nothing constrains their universes, the universe parameters u and v are also inserted.def map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nThe full signature of map is:map.{u, v} {α : Type u} {β : Type v}\n  (f : α → β) (xs : List α) :\n  List β\n\n\nNo Automatic Implicit ParametersIn this definition, α and β are not explicitly bound.\nBecause autoImplicit is disabled, this is an error:set_option autoImplicit false\n\ndef map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nUnknown identifier `α`\nUnknown identifier `β`\nThe full signature allows the definition to be accepted:set_option autoImplicit false\n\ndef map.{u, v} {α : Type u} {β : Type v}\n    (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nUniverse parameters are inserted automatically for parameters without explicit type annotations.\nThe type parameters' universes can be inferred, and the appropriate universe parameters inserted, even when autoImplicit is disabled:set_option autoImplicit false\n\ndef map {α β} (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\n\n\nIterated Automatic Implicit ParametersGiven a number bounded by n, represented by the type Fin n, an AtLeast i is a natural number paired with a proof that it is at least as large as i.structure AtLeast (i : Fin n) where\n  val : Nat\n  val_gt_i : val ≥ i.val\nThese numbers can be added:def AtLeast.add (x y : AtLeast i) : AtLeast i :=\n  AtLeast.mk (x.val + y.val) <| by\n    cases x\n    cases y\n    dsimp only\n    omega\nThe signature of AtLeast.add requires multiple rounds of automatic implicit parameter insertion.\nFirst, i is inserted; but its type depends on the upper bound n of Fin n.\nIn the second round, n is inserted, using a machine-chosen name.\nBecause n's type is Nat, which has no dependencies, the process terminates.\nThe final signature can be seen with #check:#check AtLeast.add\nAtLeast.add {n✝ : Nat} {i : Fin n✝} (x y : AtLeast i) : AtLeast i\n\n\nAutomatic implicit parameter insertion takes place after the insertion of parameters due to section variables.\nParameters that correspond to section variables have the same name as the corresponding variable, even when they do not correspond to a name written directly in the signature, and disabling automatic implicit parameters has no effect the parameters that correspond to section variables.\nHowever, when automatic implicit parameters are enabled, section variable declarations that contain otherwise-unbound variables receive additional section variables that follow the same rules as those for implicit parameters.\n\nAutomatic implicit parameters insertion is controlled by two options.\nBy default, automatic implicit parameter insertion is relaxed, which means that any unbound identifier may be a candidate for automatic insertion.\nSetting the option relaxedAutoImplicit to false disables relaxed mode and causes only identifiers that consist of a single character followed by zero or more digits to be considered for automatic insertion.\n\nWhen \"relaxed\" mode is enabled, any atomic nonempty identifier is eligible for auto bound implicit locals (see option autoImplicit).\n\nUnbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, def f (x : Vector α n) : Vector α n := automatically introduces the implicit variables {α n}.\n\nRelaxed vs Non-Relaxed Automatic Implicit ParametersMisspelled identifiers or missing imports can end up as unwanted implicit parameters, as in this example:inductive Answer where\n  | yes\n  | maybe\n  | no\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nThe resulting error message states that the argument's type is not a constant, so dot notation cannot be used in the pattern:Invalid dotted identifier notation: The expected type of `.yes`\n  Asnwer\nis not of the form `C ...` or `... → C ...` where C is a constant\nThis is because the signature is:select.{u_1, u_2}\n  {α : Type u_1}\n  {Asnwer : Sort u_2}\n  (choices : α × α × α) :\n  Asnwer → α\nDisabling relaxed automatic implicit parameters makes the error more clear, while still allowing the type to be inserted automatically:set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nUnknown identifier `Asnwer`\nCorrecting the error allows the definition to be accepted.set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nTurning off automatic implicit parameters entirely leads to the definition being rejected:set_option autoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nUnknown identifier `α`\n\n\n","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","header":"7.2.4. Automatic Implicit Parameters","id":"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters"},"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed--Examples":{"contents":"Binder type requires new type variabledef identity x :=\n  x\nFailed to infer type of binder `x`\ndef identity (x : α) :=\n  x\nIn the code above, the type of x is unconstrained; as this example demonstrates, Lean does not\nautomatically generate fresh type variables for such binders. Instead, the type α of x must be\nspecified explicitly. Note that if automatic implicit parameter insertion is enabled (as it is by\ndefault), a binder for α itself need not be provided; Lean will insert an implicit binder for this\nparameter automatically.\n\nUninferred binder type due to resulting type annotationdef plusTwo x : Nat :=\n  x + 2\nFailed to infer type of binder `x`\n\nNote: Because this declaration's type has been explicitly provided, all parameter types and holes (e.g., `_`) in its header are resolved before its body is processed; information from the declaration body cannot be used to infer what these values should be\ndef plusTwo (x : Nat) : Nat :=\n  x + 2\nEven though x is inferred to have type Nat in the body of plusTwo, this information is not\navailable when elaborating the type of the definition because its resulting type (Nat) has been\nexplicitly specified. Considering only the information in the header, the type of x cannot be\ndetermined, resulting in the shown error. It is therefore necessary to include the type of x in\nits binder.\n\nAttempting to name an example declarationexample trivial_proof : True :=\n  trivial\nFailed to infer type of binder `trivial_proof`\n\nNote: Because this declaration's type has been explicitly provided, all parameter types and holes (e.g., `_`) in its header are resolved before its body is processed; information from the declaration body cannot be used to infer what these values should be\nexample : True :=\n  trivial\nThis code is invalid because it attempts to give a name to an example declaration. Examples cannot\nbe named, and an identifier written where a name would appear in other declaration forms is instead\nelaborated as a binder, whose type cannot be inferred. If a declaration must be named, it should be\ndefined using a declaration form that supports naming, such as def or theorem.\n\nAttempting to define multiple opaque constants at onceopaque m n : Nat\nFailed to infer type of binder `n`\n\nNote: Multiple constants cannot be declared in a single declaration. The identifier(s) `n` are being interpreted as parameters `(n : _)`.\nopaque m : Nat\nopaque n : Nat\nThis example incorrectly attempts to define multiple constants with a single opaque declaration.\nSuch a declaration can define only one constant: it is not possible to list multiple identifiers\nafter opaque or def to define them all to have the same type (or value). Such a declaration is\ninstead elaborated as defining a single constant (e.g., m above) with parameters given by the\nsubsequent identifiers (n), whose types are unspecified and cannot be inferred. To define multiple\nglobal constants, it is necessary to declare each separately.\n\nAttempting to define multiple structure fields on the same linestructure Person where\n  givenName familyName : String\n  age : Nat\nFailed to infer type of binder `familyName`\nstructure Person where\n  givenName : String\n  familyName : String\n  age : Nat\nstructure Person where\n  (givenName familyName : String)\n  age : Nat\nThis example incorrectly attempts to define multiple structure fields (givenName and familyName)\nof the same type by listing them consecutively on the same line. Lean instead interprets this as\ndefining a single field, givenName, parametrized by a binder familyName with no specified type.\nThe intended behavior can be achieved by either listing each field on a separate line, or enclosing\nthe line specifying multiple field names in parentheses (see the manual section on\nInductive Types for further details about structure\ndeclarations).\n\n","context":"Lean Reference\u0009Error Explanations\u0009lean.inferBinderTypeFailed","header":"Examples","id":"/Error-Explanations/lean___inferBinderTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferBinderTypeFailed--Examples"},"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes":{"contents":"The types and functions in this section are available after importing Std.Sync.Mutex.\n\nMutual exclusion primitive (lock) guarding shared state of type α.The type Mutex α is similar to IO.Ref α, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n\nCreates a new mutex.\n\nmutex.atomically k runs k with access to the mutex's state while locking the mutex.Calling mutex.atomically while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nmutex.atomicallyOnce condvar pred k runs k, waiting on condvar until pred returns true.\nBoth k and pred have access to the mutex's state.Calling mutex.atomicallyOnce while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nAtomicT α m is the monad that can be atomically executed inside mutual exclusion primitives like\nMutex α with outside monad m.\nThe action has access to the state α of the mutex (via get and set).\n\n","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Communication Between Tasks","header":"15.11.6.2. Mutexes","id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes"}});