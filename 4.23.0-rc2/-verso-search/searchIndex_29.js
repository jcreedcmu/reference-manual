window.docContents[29].resolve({"/Type-Classes/Basic-Classes/#decidable-propositions":{"id":"/Type-Classes/Basic-Classes/#decidable-propositions","header":"11.5.4. Decidability","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","contents":"A proposition is decidable if it can be checked algorithmically.\nThe Law of the Excluded Middle means that every proposition is true or false, but it provides no way to check which of the two cases holds, which can often be useful.\nBy default, only algorithmic Decidable instances for which code can be generated are in scope; opening the Classical namespace makes every proposition decidable.\n\nEither a proof that p is true or a proof that p is false. This is equivalent to a Bool paired\nwith a proof that the Bool is true if and only if p is true.Decidable instances are primarily used via if-expressions and the tactic decide. In\nconditional expressions, the Decidable instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\nBool-based conditional. In proofs, the tactic decide synthesizes an instance of Decidable p,\nattempts to reduce it to isTrue h, and then succeeds with the proof h if it can.Because Decidable carries data, when writing @[simp] lemmas which include a Decidable instance\non the LHS, it is best to use {_ : Decidable p} rather than [Decidable p] so that non-canonical\ninstances can be found via unification rather than instance synthesis.Proves that p is decidable by supplying a proof of ¬pProves that p is decidable by supplying a proof of p\n\nA decidable predicate.A predicate is decidable if the corresponding proposition is Decidable for each possible argument.\n\nA decidable relation.A relation is decidable if the corresponding proposition is Decidable for all possible arguments.\n\nPropositional equality is Decidable for all elements of a type.In other words, an instance of DecidableEq α is a means of deciding the proposition a = b is\nfor all a b : α.\n\nAbbreviation for DecidableRel (· < · : α → α → Prop).\n\nAbbreviation for DecidableRel (· ≤ · : α → α → Prop).\n\nConverts a decidable proposition into a Bool.If p : Prop is decidable, then decide p : Bool is the Boolean value\nthat is true if p is true and false if p is false.\n\nConstruct a q if some proposition p is decidable, and both the truth and falsity of p are\nsufficient to construct a q.This is a synonym for dite, the dependent if-then-else operator.\n\nExcluded Middle and DecidableThe equality of functions from Nat to Nat is not decidable:example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\nfailed to synthesize\n  Decidable (f = g)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nOpening Classical makes every proposition decidable; however, declarations and examples that use this fact must be marked noncomputable to indicate that code should not be generated for them.open Classical\nnoncomputable example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\n\n\n"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting":{"id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting","header":"4.3.2.3. Universe Lifting","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","contents":"When a type's universe is smaller than the one expected in some context, universe lifting operators can bridge the gap.\nThese are wrappers around terms of a given type that are in larger universes than the wrapped type.\nThere are two lifting operators:\n\n* PLift can lift any type, including propositions, by one level. It can be used to include proofs in data structures such as lists.* ULift can lift any non-proposition type by any number of levels.\n\nLifts a proposition or type to a higher universe level.PLift α wraps a proof or value of type α. The resulting type is in the next largest universe\nafter that of α. In particular, propositions become data.The related type ULift can be used to lift a non-proposition type by any number of levels.Examples:* (False : Prop)* (PLift False : Type)* ([.up (by trivial), .up (by simp), .up (by decide)] : List (PLift True))* (Nat : Type 0)* (PLift Nat : Type 1)Wraps a proof or value to increase its type's universe level by 1.Extracts a wrapped proof or value from a universe-lifted proposition or type.\n\nLifts a type to a higher universe level.ULift α wraps a value of type α. Instead of occupying the same universe as α, which would be\nthe minimal level, it takes a further level parameter and occupies their maximum. The resulting type\nmay occupy any universe that's at least as large as that of α.The resulting universe of the lifting operator is the first parameter, and may be written explicitly\nwhile allowing α's level to be inferred.The related type PLift can be used to lift a proposition or type by one level.Examples:* (Nat : Type 0)* (ULift Nat : Type 0)* (ULift Nat : Type 1)* (ULift Nat : Type 5)* (ULift.{7} (PUnit : Type 3) : Type 7)Wraps a value to increase its type's universe level.Extracts a wrapped value from a universe-lifted type.\n\n"},"/Basic-Types/Strings/#string-api-props":{"id":"/Basic-Types/Strings/#string-api-props","header":"19.8.4.3. Properties","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","contents":"Checks whether a string is empty.Empty strings are equal to \"\" and have length and end position 0.Examples:* \"\".isEmpty = true* \"empty\".isEmpty = false* \" \".isEmpty = false\n\nReturns the length of a string in Unicode code points.Examples:* \"\".length = 0* \"abc\".length = 3* \"L∃∀N\".length = 4\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion","header":"19.17.2.6. Conversion","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\nCreates a hash map from an array of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofArray, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\nCreates a hash map from a list of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofList, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\n"}});