window.docContents[111].resolve({"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-reduction":{"id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-reduction","header":"13.6.4.1. Reduction","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv\u0009Changing the Goal","contents":"Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, List.map f [a, b, c]\nweak head normalizes to f a :: List.map f [b, c].\n\nPuts term in normal form, this tactic is meant for debugging purposes only.\n\nExpands let-declarations and let-variables.\n\ndelta id1 id2 ... unfolds all occurrences of id1, id2, ... in the target.\nLike the delta tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer unfold for unfolding definitions.\n\n* unfold id unfolds all occurrences of definition id in the target.* unfold id1 id2 ... is equivalent to unfold id1; unfold id2; ....Definitions can be either global or local definitions.For non-recursive global definitions, this tactic is identical to delta.\nFor recursive global definitions, it uses the \"unfolding lemma\" id.eq_def,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to simp only [id], which unfolds definition id recursively.This is the conv version of the unfold tactic.\n\n"},"/Coercions/Implementation-Details/#coercion-chain-impl":{"id":"/Coercions/Implementation-Details/#coercion-chain-impl","header":"12.5.2. Coercion Chaining","context":"Lean Reference\u0009Coercions\u0009Implementation Details","contents":"Coercion chaining is implemented through a collection of auxiliary type classes.\nUsers should not write instances of these classes directly, but knowledge of their structure can be useful when diagnosing the reason why a coercion was not inserted as expected.\nThe specific rules governing the ordering of instances in the chain (namely, that it should match CoeHead﻿?CoeOut﻿*Coe﻿*CoeTail﻿?) are implemented by the following type classes:* CoeTC is the transitive closure of Coe instances.* CoeOTC is the middle of the chain, consisting of the transitive closure of CoeOut instances followed by CoeTC.* CoeHTC is the start of the chain, consisting of at most one CoeHead instance followed by CoeOTC.* CoeHTCT is the whole chain, consisting of CoeHTC followed by at most one CoeTail instance. Alternatively, it might be a NatCast instance.* CoeT represents the entire chain: it is either a CoeHTCT chain or a single CoeDep instance.\n\nAuxiliary Classes for Coercions \n\nAuxiliary class implementing CoeHead* Coe* CoeTail?.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing CoeHead CoeOut* Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing CoeOut* Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\nAuxiliary class implementing Coe*.\nUsers should generally not implement this directly.Coerces a value of type α to type β. Accessible by the notation ↑x,\nor by double type ascription ((x : α) : β).\n\n"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation":{"id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Proof-Automation","header":"19.5.5.10. Proof Automation","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","contents":"\n\n"}});