window.docContents[249].resolve({"/Definitions/Recursive-Definitions/#mutual-syntax":{"id":"/Definitions/Recursive-Definitions/#mutual-syntax","header":"7.6.1. Mutual Recursion","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions","contents":"Just as a recursive definition is one that mentions the name being defined in the body of the definition, mutually recursive definitions are definitions that may be recursive or mention one another.\nTo use mutual recursion between multiple declarations, they must be placed in a mutual block.\n\nMutual Declaration BlocksThe general syntax for mutual recursion is:where the declarations must be definitions or theorems.\n\nThe declarations in a mutual block are not in scope in each others' signatures, but they are in scope in each others' bodies.\nEven though the names are not in scope in signatures, they will not be inserted as auto-bound implicit parameters.\n\nMutual Block ScopeNames defined in a mutual block are not in scope in each others' signatures.mutual\n  abbrev NaturalNum : Type := Nat\n  def n : NaturalNum := 5\nend\nUnknown identifier `NaturalNum`\nWithout the mutual block, the definition succeeds:abbrev NaturalNum : Type := Nat\ndef n : NaturalNum := 5\n\n\nMutual Block Scope and Automatic Implicit ParametersNames defined in a mutual block are not in scope in each others' signatures.\nNonetheless, they cannot be used as automatic implicit parameters:mutual\n  abbrev Œ± : Type := Nat\n  def identity (x : Œ±) : Œ± := x\nend\nUnknown identifier `Œ±`\nWith a different name, the implicit parameter is automatically added:mutual\n  abbrev Œ± : Type := Nat\n  def identity (x : Œ≤) : Œ≤ := x\nend\n\n\nElaborating recursive definitions always occurs at the granularity of mutual blocks, as if there were a singleton mutual block around every declaration that is not itself part of such a block.\nLocal definitions introduced via let rec and\n where are lifted out of their context, introducing parameters for captured free variables as necessary, and treated as if they were separate definitions within the mutual block as well. \nThus, helpers defined in a where block may use mutual recursion both with one another and with the definition in which they occur, but they may not mention each other in their type signatures.\n\nAfter the first step of elaboration, in which definitions are still recursive, and before translating recursion using the techniques above, Lean identifies the actually (mutually) recursive cliques  among the definitions in the mutual block and processes them separately and in dependency order.\n\n"},"/Basic-Types/Strings/#string-api-build":{"id":"/Basic-Types/Strings/#string-api-build","header":"19.8.4.1. Constructing","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","contents":"Returns a new string that contains only the character c.Because strings are encoded in UTF-8, the resulting string may take multiple bytes.Examples:* String.singleton 'L' = \"L\"* String.singleton ' ' = \" \"* String.singleton '\"' = \"\\\"\"* String.singleton 'ùí´' = \"ùí´\"\n\nAppends two strings. Usually accessed via the ++ operator.The internal implementation will perform destructive updates if the string is not shared.Examples:* \"abc\".append \"def\" = \"abcdef\"* \"abc\" ++ \"def\" = \"abcdef\"* \"\" ++ \"\" = \"\"\n\nAppends all the strings in a list of strings, in order.Use String.intercalate to place a separator string between the strings in a list.Examples:* String.join [\"gr\", \"ee\", \"n\"] = \"green\"* String.join [\"b\", \"\", \"l\", \"\", \"ue\"] = \"blue\"* String.join [] = \"\"\n\nAppends the strings in a list of strings, placing the separator s between each pair.Examples:* \", \".intercalate [\"red\", \"green\", \"blue\"] = \"red, green, blue\"* \" and \".intercalate [\"tea\", \"coffee\"] = \"tea and coffee\"* \" | \".intercalate [\"M\", \"\", \"N\"] = \"M |  | N\"\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Tree-Based-Maps--Conversion","header":"19.17.9.6. Conversion","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Tree-Based Maps","contents":"Transforms a list of mappings into a tree map.\n\nTransforms the tree map into a list of mappings in ascending order.\n\nTransforms the tree map into a list of mappings in ascending order.\n\n"},"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference":{"id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference","header":"19.2.4. API Reference","context":"Lean Reference\u0009Basic Types\u0009Integers","contents":"\n\n\n\n\n\n\n\n\n\n"}});