window.docContents[170].resolve({"/The-Type-System/Inductive-Types/#inductive-declarations-deriving-instances":{"id":"/The-Type-System/Inductive-Types/#inductive-declarations-deriving-instances","header":"4.4.1.4. Deriving Instances","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Inductive Type Declarations","contents":"The optional deriving clause of an inductive type declaration can be used to derive instances of type classes.\nPlease refer to the section on instance deriving for more information.\n\n"},"/Notations-and-Macros/Macros/#quotation":{"id":"/Notations-and-Macros/Macros/#quotation","header":"20.5.3. Quotation","context":"Lean Reference\u0009Notations and Macros\u0009Macros","contents":"Quotation marks code for representation as data of type Syntax.\nQuoted code is parsed, but not elaborated—while it must be syntactically correct, it need not make sense.\nQuotation makes it much easier to programmatically generate code: rather than reverse-engineering the specific nesting of node values that Lean's parser would produce, the parser can be directly invoked to create them.\nThis is also more robust in the face of refactoring of the grammar that may change the internals of the parse tree without affecting the user-visible concrete syntax.\nQuotation in Lean is surrounded by `( and ).\n\nThe syntactic category or parser being quoted may be indicated by placing its name after the opening backtick and parenthesis, followed by a vertical bar (|).\nAs a special case, the name tactic may be used to parse either tactics or sequences of tactics.\nIf no syntactic category or parser is provided, Lean attempts to parse the quotation both as a term and as a non-empty sequence of commands.\nTerm quotations have higher priority than command quotations, so in cases of ambiguity, the interpretation as a term is chosen; this can be overridden by explicitly indicating that the quotation is of a command sequence.\n\nTerm vs Command Quotation SyntaxIn the following example, the contents of the quotation could either be a function application or a sequence of commands.\nBoth match the same region of the file, so the local longest-match rule is not relevant.\nTerm quotation has a higher priority than command quotation, so the quotation is interpreted as a term.\nTerms expect their antiquotations to have type TSyntax `term rather than TSyntax `command.example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) := `($cmd1 $cmd2)\nThe result is two type errors like the following:Application type mismatch: The argument\n  cmd1\nhas type\n  TSyntax `command\nbut is expected to have type\n  TSyntax `term\nin the application\n  cmd1.raw\nThe type of the quotation (MacroM (TSyntax `command)) is not used to select a result because syntax priorities are applied prior to elaboration.\nIn this case, specifying that the antiquotations are commands resolves the ambiguity because function application would require terms in these positions:example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) := `($cmd1:command $cmd2:command)\nSimilarly, inserting a command into the quotation eliminates the possibility that it could be a term:example (cmd1 cmd2 : TSyntax `command) : MacroM (TSyntax `command) := `($cmd1 $cmd2 #eval \"hello!\")\n\n\n\n\nQuotationsLean's syntax includes quotations for terms, commands, tactics, and sequences of tactics, as well as a general quotation syntax that allows any input that Lean can parse to be quoted.\nTerm quotations have the highest priority, followed by tactic quotations, general quotations, and finally command quotations.\n\n\n\nRather than having type Syntax, quotations are monadic actions with type m Syntax.\nQuotation is monadic because it implements hygiene by adding macro scopes and pre-resolving identifiers, as described in the section on hygiene.\nThe specific monad to be used is an implicit parameter to the quotation, and any monad for which there is an instance of the MonadQuotation type class is suitable.\nMonadQuotation extends MonadRef, which gives the quotation access to the source location of the syntax that the macro expander or elaborator is currently processing. MonadQuotation additionally includes the ability to add macro scopes to identifiers and use a fresh macro scope for a sub-task.\nMonads that support quotation include MacroM, TermElabM, CommandElabM, and TacticM.\n\n\n\n\n\n\n\n\n\n\n\n"},"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers":{"id":"/Notations-and-Macros/Defining-New-Syntax/#typed-syntax-helpers","header":"20.4.9. Helpers for Typed Syntax","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","contents":"For literals, Lean's parser produces a singleton node that contains an atom.\nThe inner atom contains a string with source information, while the node's kind specifies how the atom is to be interpreted.\nThis may involve decoding string escape sequences or interpreting base-16 numeric literals.\nThe helpers in this section perform the correct interpretation.\n\nExtracts the parsed name from the syntax of an identifier.Returns Name.anonymous if the syntax is malformed.\n\nDecodes a quoted name literal, returning the name.Returns Lean.Name.anonymous if the syntax is malformed.\n\nInterprets a numeric literal as a natural number.Returns 0 if the syntax is malformed.\n\nExtracts the components of a scientific numeric literal.Returns a triple (n, sign, e) : Nat × Bool × Nat; the number's value is given by:if sign then n * 10 ^ (-e) else n * 10 ^ e\nReturns (0, false, 0) if the syntax is malformed.\n\nDecodes a string literal, removing quotation marks and unescaping escaped characters.Returns \"\" if the syntax is malformed.\n\nDecodes a character literal.Returns (default : Char) if the syntax is malformed.\n\nDecodes macro hygiene information.\n\n"}});