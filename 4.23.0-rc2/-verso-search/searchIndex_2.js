window.docContents[2].resolve({"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith-classes":{"id":"/The--grind--tactic/Linear-Arithmetic-Solver/#grind-linarith-classes","header":"17.8.1. Supporting  linarith","context":"Lean Reference\u0009The  grind  tactic\u0009Linear Arithmetic Solver","contents":"To add support for a new type to linarith, the first step is to implement IntModule if possible, or NatModule otherwise.\nEvery Ring is already an IntModule, and every Semiring is already a NatModule, so implementing one of those instances is also sufficient.\nNext, one of the order classes (Preorder, PartialOrder, or LinearOrder) should be implemented.\nTypically a Preorder instance is enough when the context already includes a contradiction, but a LinearOrder instance is required in order to prove linear inequality goals.\nAdditional features are enabled by implementing OrderedAdd, which expresses that the additive structure in a module is compatible with the order, and OrderedRing, which improves support for constants.\n\nA module over the natural numbers, i.e. a type with zero, addition, and scalar multiplication by natural numbers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative monoid.Use IntModule if the type has negation.Scalar multiplication by natural numbers.Scalar multiplication by zero is zero.Scalar multiplication by a successor.\n\nA module over the integers, i.e. a type with zero, addition, negation, subtraction, and scalar multiplication by integers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative group.Scalar multiplication by natural numbers.Scalar multiplication by integers.Scalar multiplication by zero is zero.Scalar multiplication by one is the identity.Scalar multiplication is distributive over addition in the integers.Scalar multiplication by natural numbers is consistent with scalar multiplication by integers.\n\nA preorder is a reflexive, transitive relation ≤ with a < b defined in the obvious way.The less-than-or-equal relation is reflexive.The less-than-or-equal relation is transitive.The less-than relation is determined by the less-than-or-equal relation.\n\nA partial order is a preorder with the additional property that a ≤ b and b ≤ a implies a = b.The less-than-or-equal relation is antisymmetric.\n\nA linear order is a partial order with the additional property that every pair of elements is comparable.For every two elements a and b, either a ≤ b or b ≤ a.\n\nAddition is compatible with a preorder if a ≤ b ↔ a + c ≤ b + c.a + c ≤ b + c iff a ≤ b.\n\nA ring which is also equipped with a preorder is considered a strict ordered ring if addition, negation,\nand multiplication are compatible with the preorder, and 0 < 1.In a strict ordered semiring, we have 0 < 1.In a strict ordered semiring, we can multiply an inequality a < b on the left\nby a positive element 0 < c to obtain c * a < c * b.In a strict ordered semiring, we can multiply an inequality a < b on the right\nby a positive element 0 < c to obtain a * c < b * c.\n\n"},"/Basic-Types/Sum-Types/#sum-types":{"id":"/Basic-Types/Sum-Types/#sum-types","header":"19.14. Sum Types","context":"Lean Reference\u0009Basic Types","contents":"Sum types represent a choice between two types: an element of the sum is an element of one of the other types, paired with an indication of which type it came from.\nSums are also known as disjoint unions, discriminated unions, or tagged unions.\nThe constructors of a sum are also called injections; mathematically, they can be considered as injective functions from each summand to the sum.\n\nThere are two varieties of the sum type:* Sum is polymorphic over all Type universes, and is never a proposition.* PSum is allows the summands to be propositions or types. Unlike Or, the PSum of two propositions is still a type, and non-propositional code can check which injection was used to construct a given value.Manually-written Lean code almost always uses only Sum, while PSum is used as part of the implementation of proof automation.\nThis is because it imposes problematic constraints that universe level unification cannot solve.\nIn particular, this type is in the universe Sort (max 1 u v), which can cause problems for universe level unification because the equation max 1 u v = ?u + 1 has no solution in level arithmetic.\nPSum is usually only used in automation that constructs sums of arbitrary types.\n\nThe disjoint union of types α and β, ordinarily written α ⊕ β.An element of α ⊕ β is either an a : α wrapped in Sum.inl or a b : β wrapped in Sum.inr.\nα ⊕ β is not equivalent to the set-theoretic union of α and β because its values include an\nindication of which of the two types was chosen. The union of a singleton set with itself contains\none element, while Unit ⊕ Unit contains distinct values inl () and inr ().Left injection into the sum type α ⊕ β.Right injection into the sum type α ⊕ β.\n\nThe disjoint union of arbitrary sorts α β, or α ⊕' β.It differs from α ⊕ β in that it allows α and β to have arbitrary sorts Sort u and Sort v,\ninstead of restricting them to Type u and Type v. This means that it can be used in situations\nwhere one side is a proposition, like True ⊕' Nat. However, the resulting universe level\nconstraints are often more difficult to solve than those that result from Sum.Left injection into the sum type α ⊕' β.Right injection into the sum type α ⊕' β.\n\n\n\n\n\n"}});