window.docContents[92].resolve({"/The-Simplifier/Terminal-vs-Non-Terminal-Positions/#terminal-simp":{"id":"/The-Simplifier/Terminal-vs-Non-Terminal-Positions/#terminal-simp","header":"16.5. Terminal vs Non-Terminal Positions","context":"Lean Reference\u0009The Simplifier","contents":"To write maintainable proofs, avoid using simp without only unless it closes the goal.\nSuch uses of simp that do not close a goal are referred to as non-terminal simps.\nThis is because additions to the default simp set may make simp more powerful or just cause it to select a different sequence of rewrites and arrive at a different simp normal form.\nWhen only is specified, additional lemmas will not affect that invocation of the tactic.\nIn practice, terminal uses of simp are not nearly as likely to be broken by the addition of new simp lemmas, and when they are, it's easier to understand the issue and fix it.\n\nWhen working in non-terminal positions, simp? (or one of the other simplification tactics with ? in their names) can be used to generate an appropriate invocation with only.\nJust as apply? or rw? suggest the use of relevant lemmas, simp? suggests an invocation of simp with a minimal simp set that was used to reach the normal form.\n\nUsing simp?The non-terminal simp? in this proof suggests a smaller simp with only:example (xs : Array Unit) : xs.size = 2 → xs = #[(), ()] := by\n  intros\n  ext\n  simp?\n  assumption\nThe suggested rewrite is:Try this: simp only [List.size_toArray, List.length_cons, List.length_nil, Nat.zero_add, Nat.reduceAdd]\nwhich results in the more maintainable proof:example (xs : Array Unit) : xs.size = 2 → xs = #[(), ()] := by\n  intros\n  ext\n  simp only [List.size_toArray, List.length_cons, List.length_nil, Nat.zero_add, Nat.reduceAdd]\n  assumption\n\n\n"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion":{"id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Structural-Recursion--Explicit-Structural-Recursion","header":"7.6.2.1. Explicit Structural Recursion","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Structural Recursion","contents":"To explicitly use structural recursion, a function or theorem definition can be annotated with a termination_by structural clause that specifies the decreasing parameter.\nThe decreasing parameter may be a reference to a parameter named in the signature.\nWhen the signature specifies a function type, the decreasing parameter may additionally be a parameter not named in the signature; in this case, names for the remaining parameters may be introduced by writing them before an arrow (=>).\n\nSpecifying Decreasing ParametersWhen the decreasing parameter is a named parameter to the function, it can be specified by referring to its name.def half (n : Nat) : Nat :=\n  match n with\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ntermination_by structural n\nWhen the decreasing parameter is not named in the signature, a name can be introduced locally in the termination_by clause.def half : Nat → Nat\n  | 0 | 1 => 0\n  | n + 2 => half n + 1\ntermination_by structural n => n\n\n\nExplicit Structural RecursionThe termination_by structural clause introduces a decreasing parameter.The identifiers before the optional => can bring function parameters into scope that are not\nalready bound in the declaration header, and the mandatory term must indicate one of the function's parameters, whether introduced in the header or locally in the clause.\n\nThe decreasing parameter must satisfy the following conditions:\n\n* Its type must be an inductive type.* If its type is an indexed family, then all indices must be parameters of the function.* If the inductive or indexed family of the decreasing parameter has data type parameters, then these data type parameters may themselves only depend on function parameters that are part of the fixed prefix.\n\nA fixed parameter is a function parameter that is passed unmodified in all recursive calls and is not an index of the recursive parameter's type.\nThe fixed prefix is the longest prefix of the function's parameters in which all are fixed.\n\nIneligible decreasing parametersThe decreasing parameter's type must be an inductive type.\nIn notInductive, a function is specified as the decreasing parameter:def notInductive (x : Nat → Nat) : Nat :=\n  notInductive (fun n => x (n+1))\ntermination_by structural x\ncannot use specified measure for structural recursion:\n  its type is not an inductive\nIf the decreasing parameter is an indexed family, all the indices must be variables.\nIn constantIndex, the indexed family Fin' is instead applied to a constant value:inductive Fin' : Nat → Type where\n  | zero : Fin' (n+1)\n  | succ : Fin' n → Fin' (n+1)\n\ndef constantIndex (x : Fin' 100) : Nat := constantIndex .zero\ntermination_by structural x\ncannot use specified measure for structural recursion:\n  its type Fin' is an inductive family and indices are not variables\n    Fin' 100\nThe parameters of the decreasing parameter's type must not depend on function parameters that come after varying parameters or indices.\nIn afterVarying, the fixed prefix is empty, because the first parameter n varies, so p is not part of the fixed prefix:inductive WithParam' (p : Nat) : Nat → Type where\n  | zero : WithParam' p (n+1)\n  | succ : WithParam' p n → WithParam' p (n+1)\n\ndef afterVarying (n : Nat) (p : Nat) (x : WithParam' p n) : Nat :=\n  afterVarying (n+1) p .zero\ntermination_by structural x\nfailed to infer structural recursion:\nCannot use parameter x:\n  failed to eliminate recursive application\n    afterVarying (n + 1) p WithParam'.zero\n\n\nFurthermore, every recursive call of the functions must be on a strict sub-term of the decreasing\nparameter.\n\n* The decreasing parameter itself is a sub-term, but not a strict sub-term.* If a sub-term is the discriminant of a match expression or other pattern-matching syntax, the pattern that matches the discriminant is a sub-term in the right-hand side of each match alternative.\n   In particular, the rules of match generalization are used to connect the discriminant to the occurrences of the pattern term in the right-hand side; thus, it respects definitional equality.\n   The pattern is a strict sub-term if and only if the discriminant is a strict sub-term.* If a sub-term is a constructor applied to arguments, then its recursive arguments are strict sub-terms.\n\n\n\nNested Patterns and Sub-TermsIn the following example, the decreasing parameter n is matched against the nested pattern .succ (.succ n). Therefore .succ (.succ n) is a (non-strict) sub-term of n, and consequently  both n and .succ n are strict sub-terms, and the definition is accepted.def fib : Nat → Nat\n  | 0 | 1 => 1\n  | .succ (.succ n) =>  fib n + fib (.succ n)\ntermination_by structural n => n\nFor clarity, this example uses .succ n and .succ (.succ n) instead of the equivalent Nat-specific n+1 and n+2.\n\n\n\n\n\nMatching on Complex Expressions Can Prevent ElaborationIn the following example, the decreasing parameter n is not directly the discriminant of the match expression.\nTherefore, n' is not considered a sub-term of n.def half (n : Nat) : Nat :=\n  match Option.some n with\n  | .some (n' + 2) => half n' + 1\n  | _ => 0\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    half n'\nUsing well-founded recursion, and explicitly connecting the discriminant to the pattern of the match, this definition can be accepted.def half (n : Nat) : Nat :=\n  match h : Option.some n with\n  | .some (n' + 2) => half n' + 1\n  | _ => 0\ntermination_by n\ndecreasing_by simp_all; omega\nSimilarly, the following example fails: although xs.tail would reduce to a strict sub-term of xs, this is not visible to Lean according to the rules above.\nIn particular, xs.tail is not definitionally equal to a strict sub-term of xs.def listLen : List α → Nat\n  | [] => 0\n  | xs => listLen xs.tail + 1\ntermination_by structural xs => xs\n\n\n\n\nSimultaneous Matching vs Matching Pairs for Structural RecursionAn important consequence of the strategies that are used to prove termination is that simultaneous matching of two discriminants is not equivalent to matching a pair.\nSimultaneous matching maintains the connection between the discriminants and the patterns, allowing the pattern matching to refine the types of the assumptions in the local context as well as the expected type of the match.\nEssentially, the elaboration rules for match treat the discriminants specially, and changing discriminants in a way that preserves the run-time meaning of a program does not necessarily preserve the compile-time meaning.This function that finds the minimum of two natural numbers is defined by structural recursion on its first parameter:def min' (n k : Nat) : Nat :=\n  match n, k with\n  | 0, _ => 0\n  | _, 0 => 0\n  | n' + 1, k' + 1 => min' n' k' + 1\ntermination_by structural n\nReplacing the simultaneous pattern match on both parameters with a match on a pair causes termination analysis to fail:def min' (n k : Nat) : Nat :=\n  match (n, k) with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' n' k' + 1\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    min' n' k'\nThis is because the analysis only considers direct pattern matching on parameters when matching recursive calls to strictly-smaller argument values.\nWrapping the discriminants in a pair breaks the connection.\n\nStructural Recursion Under PairsThis function that finds the minimum of the two components of a pair can't be elaborated via structural recursion.def min' (nk : Nat × Nat) : Nat :=\n  match nk with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' (n', k') + 1\ntermination_by structural nk\nfailed to infer structural recursion:\nCannot use parameter nk:\n  the type Nat × Nat does not have a `.brecOn` recursor\nThis is because the parameter's type, Prod, is not recursive.\nThus, its constructor has no recursive parameters that can be exposed by pattern matching.This definition is accepted using well-founded recursion, however:def min' (nk : Nat × Nat) : Nat :=\n  match nk with\n  | (0, _) => 0\n  | (_, 0) => 0\n  | (n' + 1, k' + 1) => min' (n', k') + 1\ntermination_by nk\n\n\n\n\nStructural Recursion and Definitional EqualityEven though the recursive occurrence of countdown is applied to a term that is not a strict sub-term of the decreasing parameter, the following definition is accepted:def countdown (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown (n' + 0)\ntermination_by structural n\nThis is because n' + 0 is definitionally equal to n', which is a strict sub-term of n.\nSub-terms that result from pattern matching are connected to the discriminant using the rules for match generalization, which respect definitional equality.In countdown', the recursive occurrence is applied to 0 + n', which is not definitionally equal to n' because addition on natural numbers is structurally recursive in its second parameter:def countdown' (n : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n' + 1 => n' :: countdown' (0 + n')\ntermination_by structural n\nfailed to infer structural recursion:\nCannot use parameter n:\n  failed to eliminate recursive application\n    countdown' (0 + n')\n\n\n\n\n"}});