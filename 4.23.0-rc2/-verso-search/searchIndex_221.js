window.docContents[221].resolve({"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness":{"id":"/Run-Time-Code/Reference-Counting/#The-Lean-Language-Reference--Run-Time-Code--Reference-Counting--Observing-Uniqueness","header":"21.2.1. Observing Uniqueness","context":"Lean Reference\u0009Run-Time Code\u0009Reference Counting","contents":"Ensuring that arrays and strings are uniquely referenced is key to writing fast code in Lean.\nThe primitive dbgTraceIfShared can be used to check whether a data structure is aliased.\nWhen called, it returns its argument unchanged, printing the provided trace message if the argument's reference count is greater than one.\n\nDisplay the given message if a is shared, that is, RC(a) > 1\n\nDue to the specifics of how #eval is implemented, using dbgTraceIfShared with #eval can be misleading.\nInstead, it should be used in code that's explicitly compiled and run.\n\nObserving UniquenessThis program reads a line of input from the user, printing it after replacing its first character with a space.\nReplacing characters in a string uses an in-place update if the string is not shared and the characters are both contained in the 7-bit ASCII subset of Unicode.\nThe dbgTraceIfShared call does nothing, indicating that the string will indeed be updated in place rather than copied.def process (str : String) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).set 0 ' ')\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trim\n  process line\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nwith an empty standard error output:\nThis version of the program retains a reference to the original string, which necessitates copying the string in the call to String.set.\nThis fact is visible in its standard error output.def process (str : String) : IO Unit := do\n  IO.println ((dbgTraceIfShared \"String update\" str).set 0 ' ')\n\ndef main : IO Unit := do\n  let line := (← (← IO.getStdin).getLine).trim\n  process line\n  IO.println \"Original input:\"\n  IO.println line\nWhen run with this input:Here is input.\nthe program emits: ere is input.\nOriginal input:\nHere is input.\nIn its standard error, the message passed to dbgTraceIfShared is visible.shared RC String update\n\n\n"},"/Introduction/#typographical-conventions":{"id":"/Introduction/#typographical-conventions","header":"1.2. Typographical Conventions","context":"Lean Reference\u0009Introduction","contents":"This document makes use of a number of typographical and layout conventions to indicate various aspects of the information being presented.\n\n\n\n\n\n\n\n\n\n"},"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint":{"id":"/Definitions/Recursive-Definitions/#mutual-partial-fixpoint","header":"7.6.4.4. Mutual Recursion with Partial Fixpoints","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial Fixpoint Recursion","contents":"Lean supports the definition of mutually recursive functions using partial fixpoint.\nMutual recursion may be introduced using a mutual block, but it also results from let rec expressions and where blocks.\nThe rules for mutual well-founded recursion are applied to a group of actually mutually recursive, lifted definitions, that results from the elaboration steps for mutual groups.\n\nIf all functions in the mutual group have the partial_fixpoint clause, then this strategy is used.\n\n"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting":{"id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Sorting","header":"19.15.3.9. Sorting","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","contents":"A stable merge sort.This function is a simplified implementation that's designed to be easy to reason about, rather than\nfor efficiency. In particular, it uses the non-tail-recursive List.merge function and traverses\nlists unnecessarily.It is replaced at runtime by an efficient implementation that has been proven to be equivalent.\n\nMerges two lists, using le to select the first element of the resulting list if both are\nnon-empty.If both input lists are sorted according to le, then the resulting list is also sorted according\nto le. O(|xs| + |ys|).This implementation is not tail-recursive, but it is replaced at runtime by a proven-equivalent\ntail-recursive merge.\n\n"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference":{"id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--API-Reference","header":"19.11.4. API Reference","context":"Lean Reference\u0009Basic Types\u0009Booleans","contents":"\n\n\n\n\n\n"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing":{"id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Hashing","header":"19.5.5.5. Hashing","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","contents":"Computes a hash of a bitvector, combining 64-bit words using mixHash.\n\n"},"/Axioms/#print-axioms":{"id":"/Axioms/#print-axioms","header":"8.4. Displaying Axiom Dependencies","context":"Lean Reference\u0009Axioms","contents":"The command #print axioms displays all the axioms that a declaration transitively relies on.\nIn other words, if a proof uses another proof, which itself uses an axiom, then the axiom is reported by #print axioms for both.\nThis can be used to audit the assumptions made by a proof.\nTogether with #guard_msgs, it can also ensure that updates to libraries from other projects don't silently introduce unwanted dependencies on axioms.\n\n"}});