window.docContents[101].resolve({"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-parameters":{"id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-same-parameters","header":"4.4.5.1.2. Parameters Must Match","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","contents":"All inductive types in the mutual group must have the same parameters.\nTheir indices may differ.\n\nDiffering numbers of parametersEven though Both and OneOf are not mutually recursive, they are declared in the same mutual block and must therefore have identical parameters:mutual\n  inductive Both (α : Type u) (β : Type v) where\n    | mk : α → β → Both α β\n  inductive Optional (α : Type u) where\n    | none\n    | some : α → Optional α\nend\nInvalid mutually inductive types: `Optional` has 1 parameter(s), but the preceding type `Both` has 2\n\nNote: All inductive types declared in the same `mutual` block must have the same parameters\n\n\nDiffering parameter typesEven though Many and OneOf are not mutually recursive, they are declared in the same mutual block and must therefore have identical parameters.\nThey both have exactly one parameter, but Many's parameter is not necessarily in the same universe as Optional's:mutual\n  inductive Many (α : Type) : Type u where\n    | nil : Many α\n    | cons : α → Many α → Many α\n  inductive Optional (α : Type u) where\n    | none\n    | some : α → Optional α\nend\nInvalid mutually inductive types: Parameter `α` has type\n  Type u\nof sort `Type (u + 1)` but is expected to have type\n  Type\nof sort `Type 1`\n\n\n"},"/Terms/Pattern-Matching/#pattern-fun":{"id":"/Terms/Pattern-Matching/#pattern-fun","header":"10.8.3. Pattern Matching Functions","context":"Lean Reference\u0009Terms\u0009Pattern Matching","contents":"Pattern-Matching FunctionsFunctions may be specified via pattern matching by writing a sequence of patterns after fun, each preceded by a vertical bar (|).This desugars to a function that immediately pattern-matches on its arguments.\n\nPattern-Matching FunctionsisZero is defined using a pattern-matching function abstraction, while isZero' is defined using a pattern match expression:def isZero : Nat → Bool :=\n  fun\n    | 0 => true\n    | _ => false\n\ndef isZero' : Nat → Bool :=\n  fun n =>\n    match n with\n    | 0 => true\n    | _ => false\nBecause the former is syntactic sugar for the latter, they are definitionally equal:example : isZero = isZero' := rfl\nThe desugaring is visible in the output of #print:#print isZero\noutputsdef isZero : Nat → Bool :=\nfun x =>\n  match x with\n  | 0 => true\n  | x => false\nwhile#print isZero'\noutputsdef isZero' : Nat → Bool :=\nfun n =>\n  match n with\n  | 0 => true\n  | x => false\n\n\n"},"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Monad-Functors":{"id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts--Monad-Functors","header":"14.2.1.1. Monad Functors","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Lifting Monads\u0009Reversing Lifts","contents":"A way to interpret a fully-polymorphic function in m into n. Such a function can be thought of\nas one that may change the effects in m, but can't do so based on specific values that are\nprovided.Clients of MonadFunctor should typically use MonadFunctorT, which is the reflexive, transitive\nclosure of MonadFunctor. New instances should be defined for MonadFunctor.Lifts a fully-polymorphic transformation of m into n.\n\nA way to interpret a fully-polymorphic function in m into n. Such a function can be thought of\nas one that may change the effects in m, but can't do so based on specific values that are\nprovided.This is the reflexive, transitive closure of MonadFunctor. It automatically chains together\nMonadFunctor instances as needed. Clients of MonadFunctor should typically use MonadFunctorT,\nbut new instances should be defined for MonadFunctor.Lifts a fully-polymorphic transformation of m into n.\n\n"}});