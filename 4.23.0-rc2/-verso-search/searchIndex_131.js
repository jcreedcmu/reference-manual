window.docContents[131].resolve({"/Basic-Types/Strings/#string-api-lookup":{"id":"/Basic-Types/Strings/#string-api-lookup","header":"19.8.4.5. Lookups and Modifications","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","contents":"Returns the character at position p of a string. If p is not a valid position, returns the\nfallback value (default : Char), which is 'A', but does not panic.This function is overridden with an efficient implementation in runtime code. See\nString.utf8GetAux for the reference implementation.Examples:* \"abc\".get ⟨1⟩ = 'b'* \"abc\".get ⟨3⟩ = (default : Char) because byte 3 is at the end of the string.* \"L∃∀N\".get ⟨2⟩ = (default : Char) because byte 2 is in the middle of '∃'.\n\nReturns the character at position p of a string. If p is not a valid position, returns none.This function is overridden with an efficient implementation in runtime code. See\nString.utf8GetAux? for the reference implementation.Examples:* \"abc\".get? ⟨1⟩ = some 'b'* \"abc\".get? ⟨3⟩ = none* \"L∃∀N\".get? ⟨1⟩ = some '∃'* \"L∃∀N\".get? ⟨2⟩ = none\n\nReturns the character at position p of a string. Panics if p is not a valid position.See String.get? for a safer alternative.This function is overridden with an efficient implementation in runtime code. See\nString.utf8GetAux for the reference implementation.Examples* \"abc\".get! ⟨1⟩ = 'b'\n\nReturns the character at position p of a string. Returns (default : Char), which is 'A', if\np is not a valid position.Requires evidence, h, that p is within bounds instead of performing a run-time bounds check as\nin String.get.A typical pattern combines get' with a dependent if-expression to avoid the overhead of an\nadditional bounds check. For example:def getInBounds? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else some (s.get' p h)\nEven with evidence of ¬ s.atEnd p, p may be invalid if a byte index points into the middle of a\nmulti-byte UTF-8 character. For example, \"L∃∀N\".get' ⟨2⟩ (by decide) = (default : Char).Examples:* \"abc\".get' 0 (by decide) = 'a'* let lean := \"L∃∀N\"; lean.get' (0 |> lean.next |> lean.next) (by decide) = '∀'\n\nCreates a new string that consists of the region of the input string delimited by the two positions.The result is \"\" if the start position is greater than or equal to the end position or if the\nstart position is at the end of the string. If either position is invalid (that is, if either points\nat the middle of a multi-byte UTF-8 character) then the result is unspecified.Examples:* \"red green blue\".extract ⟨0⟩ ⟨3⟩ = \"red\"* \"red green blue\".extract ⟨3⟩ ⟨0⟩ = \"\"* \"red green blue\".extract ⟨0⟩ ⟨100⟩ = \"red green blue\"* \"red green blue\".extract ⟨4⟩ ⟨100⟩ = \"green blue\"* \"L∃∀N\".extract ⟨2⟩ ⟨100⟩ = \"green blue\"\n\nCreates a new string that contains the first n characters (Unicode code points) of s.If n is greater than s.length, returns s.Examples:* \"red green blue\".take 3 = \"red\"* \"red green blue\".take 1 = \"r\"* \"red green blue\".take 0 = \"\"* \"red green blue\".take 100 = \"red green blue\"\n\nCreates a new string that contains the longest prefix of s in which p returns true for all\ncharacters.Examples:* \"red green blue\".takeWhile (·.isLetter) = \"red\"* \"red green blue\".takeWhile (· == 'r') = \"r\"* \"red green blue\".takeWhile (· != 'n') = \"red gree\"* \"red green blue\".takeWhile (fun _ => true) = \"red green blue\"\n\nCreates a new string that contains the last n characters (Unicode code points) of s.If n is greater than s.length, returns s.Examples:* \"red green blue\".takeRight 4 = \"blue\"* \"red green blue\".takeRight 1 = \"e\"* \"red green blue\".takeRight 0 = \"\"* \"red green blue\".takeRight 100 = \"red green blue\"\n\nCreates a new string that contains the longest suffix of s in which p returns true for all\ncharacters.Examples:* \"red green blue\".takeRightWhile (·.isLetter) = \"blue\"* \"red green blue\".takeRightWhile (· == 'e') = \"e\"* \"red green blue\".takeRightWhile (· != 'n') = \" blue\"* \"red green blue\".takeRightWhile (fun _ => true) = \"red green blue\"\n\nRemoves the specified number of characters (Unicode code points) from the start of the string.If n is greater than s.length, returns \"\".Examples:* \"red green blue\".drop 4 = \"green blue\"* \"red green blue\".drop 10 = \"blue\"* \"red green blue\".drop 50 = \"\"\n\nCreates a new string by removing the longest prefix from s in which p returns true for all\ncharacters.Examples:* \"red green blue\".dropWhile (·.isLetter) = \" green blue\"* \"red green blue\".dropWhile (· == 'r') = \"ed green blue\"* \"red green blue\".dropWhile (· != 'n') = \"n blue\"* \"red green blue\".dropWhile (fun _ => true) = \"\"\n\nRemoves the specified number of characters (Unicode code points) from the end of the string.If n is greater than s.length, returns \"\".Examples:* \"red green blue\".dropRight 5 = \"red green\"* \"red green blue\".dropRight 11 = \"red\"* \"red green blue\".dropRight 50 = \"\"\n\nCreates a new string by removing the longest suffix from s in which p returns true for all\ncharacters.Examples:* \"red green blue\".dropRightWhile (·.isLetter) = \"red green \"* \"red green blue\".dropRightWhile (· == 'e') = \"red green blu\"* \"red green blue\".dropRightWhile (· != 'n') = \"red green\"* \"red green blue\".dropRightWhile (fun _ => true) = \"\"\n\nIf pre is a prefix of s, returns the remainder. Returns none otherwise.The string pre is a prefix of s if there exists a t : String such that s = pre ++ t. If so,\nthe result is some t.Use String.stripPrefix to return the string unchanged when pre is not a prefix.Examples:* \"red green blue\".dropPrefix? \"red \" = some \"green blue\"* \"red green blue\".dropPrefix? \"reed \" = none* \"red green blue\".dropPrefix? \"\" = some \"red green blue\"\n\nIf pre is a prefix of s, returns the remainder. Returns s unmodified otherwise.The string pre is a prefix of s if there exists a t : String such that s = pre ++ t. If so,\nthe result is t. Otherwise, it is s.Use String.dropPrefix? to return none when pre is not a prefix.Examples:* \"red green blue\".stripPrefix \"red \" = \"green blue\"* \"red green blue\".stripPrefix \"reed \" = \"red green blue\"* \"red green blue\".stripPrefix \"\" = \"red green blue\"\n\nIf suff is a suffix of s, returns the remainder. Returns none otherwise.The string suff is a suffix of s if there exists a t : String such that s = t ++ suff. If so,\nthe result is some t.Use String.stripSuffix to return the string unchanged when suff is not a suffix.Examples:* \"red green blue\".dropSuffix? \" blue\" = some \"red green\"* \"red green blue\".dropSuffix? \" blu \" = none* \"red green blue\".dropSuffix? \"\" = some \"red green blue\"\n\nIf suff is a suffix of s, returns the remainder. Returns s unmodified otherwise.The string suff is a suffix of s if there exists a t : String such that s = t ++ suff. If so,\nthe result is t. Otherwise, it is s.Use String.dropSuffix? to return none when suff is not a suffix.Examples:* \"red green blue\".stripSuffix \" blue\" = \"red green\"* \"red green blue\".stripSuffix \" blu \" = \"red green blue\"* \"red green blue\".stripSuffix \"\" = \"red green blue\"\n\nRemoves leading and trailing whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trim = \"abc\"* \"   abc\".trim = \"abc\"* \"abc \\t  \".trim = \"abc\"* \"  abc   \".trim = \"abc\"* \"abc\\ndef\\n\".trim = \"abc\\ndef\"\n\nRemoves leading whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimLeft = \"abc\"* \"   abc\".trimLeft = \"   abc\"* \"abc \\t  \".trimLeft = \"abc \\t  \"* \"  abc   \".trimLeft = \"abc   \"* \"abc\\ndef\\n\".trimLeft = \"abc\\ndef\\n\"\n\nRemoves trailing whitespace from a string.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \"abc\".trimRight = \"abc\"* \"   abc\".trimRight = \"   abc\"* \"abc \\t  \".trimRight = \"abc\"* \"  abc   \".trimRight = \"  abc\"* \"abc\\ndef\\n\".trimRight = \"abc\\ndef\"\n\nConsistently de-indents the lines in a string, removing the same amount of leading whitespace from\neach line such that the least-indented line has no leading whitespace.The number of leading whitespace characters to remove from each line is determined by counting the\nnumber of leading space (' ') and tab ('\\t') characters on lines after the first line that also\ncontain non-whitespace characters. No distinction is made between tab and space characters; both\ncount equally.The least number of leading whitespace characters found is then removed from the beginning of each\nline. The first line's leading whitespace is not counted when determining how far to de-indent the\nstring, but leading whitespace is removed from it.Examples:* \"Here:\\n  fun x =>\\n    x + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n  x + 1\"* \"Here:\\n\\t\\tfun x =>\\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n \\tx + 1\"* \"Here:\\n\\t\\tfun x =>\\n \\n\\t  \\tx + 1\".removeLeadingSpaces = \"Here:\\nfun x =>\\n\\n \\tx + 1\"\n\nReplaces the character at a specified position in a string with a new character. If the position is\ninvalid, the string is returned unchanged.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.Examples:* \"abc\".set ⟨1⟩ 'B' = \"aBc\"* \"abc\".set ⟨3⟩ 'D' = \"abc\"* \"L∃∀N\".set ⟨4⟩ 'X' = \"L∃XN\"* \"L∃∀N\".set ⟨2⟩ 'X' = \"L∃∀N\" because '∃' is a multi-byte character, so the byte index 2 is an\ninvalid position.\n\nReplaces the character at position p in the string s with the result of applying f to that\ncharacter. If p is an invalid position, the string is returned unchanged.If both the replacement character and the replaced character are 7-bit ASCII characters and the\nstring is not shared, then it is updated in-place and not copied.Examples:* \"abc\".modify ⟨1⟩ Char.toUpper = \"aBc\"* \"abc\".modify ⟨3⟩ Char.toUpper = \"abc\"\n\nReturns the first character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".front = 'a'* \"\".front = (default : Char)\n\nReturns the last character in s. If s = \"\", returns (default : Char).Examples:* \"abc\".back = 'c'* \"\".back = (default : Char)\n\nReturns the position of the first occurrence of a character, c, in a string s. If s does not\ncontain c, returns s.endPos.Examples:* \"abcba\".posOf 'a' = ⟨0⟩* \"abcba\".posOf 'z' = ⟨5⟩* \"L∃∀N\".posOf '∀' = ⟨4⟩\n\nReturns the position of the last occurrence of a character, c, in a string s. If s does not\ncontain c, returns none.Examples:* \"abcabc\".revPosOf 'a' = some ⟨3⟩* \"abcabc\".revPosOf 'z' = none* \"L∃∀N\".revPosOf '∀' = some ⟨4⟩\n\nChecks whether a string contains the specified character.Examples:* \"green\".contains 'e' = true* \"green\".contains 'x' = false* \"\".contains 'x' = false\n\nReturns the character index that corresponds to the provided position (i.e. UTF-8 byte index) in a\nstring.If the position is at the end of the string, then the string's length in characters is returned. If\nthe position is invalid due to pointing at the middle of a UTF-8 byte sequence, then the character\nindex of the next character after the position is returned.Examples:* \"L∃∀N\".offsetOfPos ⟨0⟩ = 0* \"L∃∀N\".offsetOfPos ⟨1⟩ = 1* \"L∃∀N\".offsetOfPos ⟨2⟩ = 2* \"L∃∀N\".offsetOfPos ⟨4⟩ = 2* \"L∃∀N\".offsetOfPos ⟨5⟩ = 3* \"L∃∀N\".offsetOfPos ⟨50⟩ = 4\n\nIn the string s, replaces all occurrences of pattern with replacement.Examples:* \"red green blue\".replace \"e\" \"\" = \"rd grn blu\"* \"red green blue\".replace \"ee\" \"E\" = \"red grEn blue\"* \"red green blue\".replace \"e\" \"E\" = \"rEd grEEn bluE\"\n\nReturns the position of the beginning of the line that contains the position pos.Lines are ended by '\\n', and the returned position is either 0 : String.Pos or immediately after\na '\\n' character.\n\nFinds the position of the first character in a string for which the Boolean predicate p returns\ntrue. If there is no such character in the string, then the end position of the string is\nreturned.Examples:* \"coffee tea water\".find (·.isWhitespace) = ⟨6⟩* \"tea\".find (· == 'X') = ⟨3⟩* \"\".find (· == 'X') = ⟨0⟩\n\nFinds the position of the last character in a string for which the Boolean predicate p returns\ntrue. If there is no such character in the string, then none is returned.Examples:* \"coffee tea water\".revFind (·.isWhitespace) = some ⟨10⟩* \"tea\".revFind (· == 'X') = none* \"\".revFind (· == 'X') = none\n\n"},"/Basic-Types/Maps-and-Sets/#DTreeMap":{"id":"/Basic-Types/Maps-and-Sets/#DTreeMap","header":"19.17.9. Dependent Tree-Based Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.DTreeMap.\n\nDependent tree maps.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present. The get operations of the dependent tree map additionally require a\nLawfulEqCmp instance to ensure that cmp a b = .eq always implies a = b, so that their\nrespective value types are equal.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.For use in proofs, the type Std.ExtDTreeMap of extensional dependent tree maps should be\npreferred. This type comes with several extensionality lemmas and provides the same functions but\nrequires a TransCmp instance to work with.These tree maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DTreeMap.Raw and\nStd.DTreeMap.Raw.WF unbundle the invariant from the tree map. When in doubt, prefer\nDTreeMap over DTreeMap.Raw.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size":{"id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Size","header":"19.16.5.1. Size","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","contents":"Computes the size of the subarray.\n\n"},"/Axioms/#axioms":{"id":"/Axioms/#axioms","header":"8. Axioms","context":"Lean Reference","contents":"Axioms are postulated constants.\nWhile the axiom's type must itself be a type (that is, it must have type Sort u), there are no further requirements.\nAxioms do not reduce to other terms.\n\nAxioms can be used to experiment with the consequences of an idea before investing the time required to construct a model or prove a theorem.\nThey can also be used to adopt reasoning principles that can't otherwise be accessed in Lean's type theory; Lean itself provides three such axioms that are known to be consistent.\nHowever, axioms should be used with caution: axioms that are inconsistent with one another, or just false, undermine the very foundations of proofs.\nLean automatically tracks the axioms that each proof depends on so that they can be audited.\n\n\n\n\n\n\n\n\n\n\n\n"}});