window.docContents[57].resolve({"/Terms/Literals/#The-Lean-Language-Reference--Terms--Literals--Scientific-Numbers":{"id":"/Terms/Literals/#The-Lean-Language-Reference--Terms--Literals--Scientific-Numbers","header":"10.5.2. Scientific Numbers","context":"Lean Reference\u0009Terms\u0009Literals","contents":"Scientific number literals consist of a sequence of digits followed by an optional period and decimal part and an optional exponent.\nIf no period or exponent is present, then the term is instead a natural number literal.\nScientific numbers are overloaded via the OfScientific type class.\n\nFor decimal and scientific numbers (e.g., 1.23, 3.12e10).\nExamples:* 1.23 is syntax for OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)* 121e100 is syntax for OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)Note the use of nat_lit; there is no wrapping OfNat.ofNat in the resulting term.Produces a value from the given mantissa, exponent sign, and decimal exponent. For the exponent\nsign, true indicates a negative exponent.Examples:* 1.23 is syntax for OfScientific.ofScientific (nat_lit 123) true (nat_lit 2)* 121e100 is syntax for OfScientific.ofScientific (nat_lit 121) false (nat_lit 100)Note the use of nat_lit; there is no wrapping OfNat.ofNat in the resulting term.\n\nThere are an OfScientific instances for Float and Float32, but no separate floating-point literals.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Lean-Install-Helpers":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Lean-Install-Helpers","header":"22.1.4.1.3. Lean Install Helpers","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference\u0009Accessing the Environment","contents":"Get the detected Lean installation.\n\nGet the root directory of the detected Lean installation.\n\nGet the Lean source directory of the detected Lean installation.\n\nGet the Lean library directory of the detected Lean installation.\n\nGet the C include directory of the detected Lean installation.\n\nGet the system library directory of the detected Lean installation.\n\nGet the path of the lean binary in the detected Lean installation.\n\nGet the path of the leanc binary in the detected Lean installation.\n\nGet the path of the libleanshared library in the detected Lean installation.\n\nGet the path of the ar binary in the detected Lean installation.\n\nGet the path of C compiler in the detected Lean installation.\n\nGet the optional LEAN_CC compiler override of the detected Lean installation.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Elan-Install-Helpers":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment--Elan-Install-Helpers","header":"22.1.4.1.2. Elan Install Helpers","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference\u0009Accessing the Environment","contents":"Get the detected Elan installation (if one).\n\nGet the root directory of the detected Elan installation (i.e., ELAN_HOME).\n\nGet the path of the elan binary in the detected Elan installation.\n\n"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Predicates-and-Relations":{"id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Predicates-and-Relations","header":"19.15.3.1. Predicates and Relations","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","contents":"The first list is a prefix of the second.IsPrefix l₁ l₂, written l₁ <+: l₂, means that there exists some t : List α such that l₂ has\nthe form l₁ ++ t.The function List.isPrefixOf is a Boolean equivalent.Conventions for notations in identifiers:* The recommended spelling of <+: in identifiers is prefix (not isPrefix).\n\nList PrefixThe first list is a prefix of the second.IsPrefix l₁ l₂, written l₁ <+: l₂, means that there exists some t : List α such that l₂ has\nthe form l₁ ++ t.The function List.isPrefixOf is a Boolean equivalent.Conventions for notations in identifiers:* The recommended spelling of <+: in identifiers is prefix (not isPrefix).\n\nThe first list is a suffix of the second.IsSuffix l₁ l₂, written l₁ <:+ l₂, means that there exists some t : List α such that l₂ has\nthe form t ++ l₁.The function List.isSuffixOf is a Boolean equivalent.Conventions for notations in identifiers:* The recommended spelling of <:+ in identifiers is suffix (not isSuffix).\n\nList SuffixThe first list is a suffix of the second.IsSuffix l₁ l₂, written l₁ <:+ l₂, means that there exists some t : List α such that l₂ has\nthe form t ++ l₁.The function List.isSuffixOf is a Boolean equivalent.Conventions for notations in identifiers:* The recommended spelling of <:+ in identifiers is suffix (not isSuffix).\n\nThe first list is a contiguous sub-list of the second list. Typically written with the <:+:\noperator.In other words, l₁ <:+: l₂ means that there exist lists s : List α and t : List α such that\nl₂ has the form s ++ l₁ ++ t.Conventions for notations in identifiers:* The recommended spelling of <:+: in identifiers is infix (not isInfix).\n\nList InfixThe first list is a contiguous sub-list of the second list. Typically written with the <:+:\noperator.In other words, l₁ <:+: l₂ means that there exist lists s : List α and t : List α such that\nl₂ has the form s ++ l₁ ++ t.Conventions for notations in identifiers:* The recommended spelling of <:+: in identifiers is infix (not isInfix).\n\nThe first list is a non-contiguous sub-list of the second list. Typically written with the <+\noperator.In other words, l₁ <+ l₂ means that l₁ can be transformed into l₂ by repeatedly inserting new\nelements.The base case: [] is a sublist of []If l₁ is a subsequence of l₂, then it is also a subsequence of a :: l₂.If l₁ is a subsequence of l₂, then a :: l₁ is a subsequence of a :: l₂.\n\nSublistsThe first list is a non-contiguous sub-list of the second list. Typically written with the <+\noperator.In other words, l₁ <+ l₂ means that l₁ can be transformed into l₂ by repeatedly inserting new\nelements.This syntax is only available when the List namespace is opened.\n\nTwo lists are permutations of each other if they contain the same elements, each occurring the same\nnumber of times but not necessarily in the same order.One list can be proven to be a permutation of another by showing how to transform one into the other\nby repeatedly swapping adjacent elements.List.isPerm is a Boolean equivalent of this relation.The empty list is a permutation of the empty list: [] ~ [].If one list is a permutation of the other, adding the same element as the head of each yields\nlists that are permutations of each other: l₁ ~ l₂ → x::l₁ ~ x::l₂.If two lists are identical except for having their first two elements swapped, then they are\npermutations of each other: x::y::l ~ y::x::l.Permutation is transitive: l₁ ~ l₂ → l₂ ~ l₃ → l₁ ~ l₃.\n\nList PermutationTwo lists are permutations of each other if they contain the same elements, each occurring the same\nnumber of times but not necessarily in the same order.One list can be proven to be a permutation of another by showing how to transform one into the other\nby repeatedly swapping adjacent elements.List.isPerm is a Boolean equivalent of this relation.This syntax is only available when the List namespace is opened.\n\nEach element of a list is related to all later elements of the list by R.Pairwise R l means that all the elements of l with earlier indexes are R-related to all the\nelements with later indexes.For example, Pairwise (· ≠ ·) l asserts that l has no duplicates, and if Pairwise (· < ·) l\nasserts that l is (strictly) sorted.Examples:* Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3* Pairwise (· = ·) [1, 2, 3] = False* Pairwise (· ≠ ·) [1, 2, 3] = TrueAll elements of the empty list are vacuously pairwise related.A nonempty list is pairwise related with R if the head is related to every element of the tail\nand the tail is itself pairwise related.That is, a :: l is Pairwise R if:* R relates a to every element of l* l is Pairwise R.\n\nThe list has no duplicates: it contains every element at most once.It is defined as Pairwise (· ≠ ·): each element is unequal to all other elements.\n\nLexicographic ordering for lists with respect to an ordering of elements.as is lexicographically smaller than bs if* as is empty and bs is non-empty, or* both as and bs are non-empty, and the head of as is less than the head of bs according to\nr, or* both as and bs are non-empty, their heads are equal, and the tail of as is less than the\ntail of bs.[] is the smallest element in the lexicographic order.If the head of the first list is smaller than the head of the second, then the first list is\nlexicographically smaller than the second list.If two lists have the same head, then their tails determine their lexicographic order. If the tail\nof the first list is lexicographically smaller than the tail of the second list, then the entire\nfirst list is lexicographically smaller than the entire second list.\n\nList membership, typically accessed via the ∈ operator.a ∈ l means that a is an element of the list l. Elements are compared according to Lean's\nlogical equality.The related function List.elem is a Boolean membership test that uses a BEq α instance.Examples:* a ∈ [x, y, z] ↔ a = x ∨ a = y ∨ a = zThe head of a list is a member: a ∈ a :: as.A member of the tail of a list is a member of the list: a ∈ l → a ∈ b :: l.\n\n"},"/Basic-Types/Arrays/#array-syntax":{"id":"/Basic-Types/Arrays/#array-syntax","header":"19.16.3. Syntax","context":"Lean Reference\u0009Basic Types\u0009Arrays","contents":"Array literals allow arrays to be written directly in code.\nThey may be used in expression or pattern contexts.\n\nArray LiteralsArray literals begin with #[ and contain a comma-separated sequence of terms, terminating with ].\n\nArray LiteralsArray literals may be used as expressions or as patterns.def oneTwoThree : Array Nat := #[1, 2, 3]\n\n#eval\n  match oneTwoThree with\n  | #[x, y, z] => some ((x + z) / y)\n  | _ => none\n\n\nAdditionally, sub-arrays may be extracted using the following syntax:\n\nSub-ArraysA start index followed by a colon constructs a sub-array that contains the values from the start index onwards (inclusive):Providing start and end indices  constructs a sub-array that contains the values from the start index (inclusive) to the end index (exclusive):\n\nSub-Array SyntaxThe array ten contains the first ten natural numbers.def ten : Array Nat :=\n  .range 10\nA sub-array that represents the second half of ten can be constructed using the sub-array syntax:#eval ten[5:]\n#[5, 6, 7, 8, 9].toSubarray\nSimilarly, sub-array that contains two through five can be constructed by providing a stopping point:#eval ten[2:6]\n#[2, 3, 4, 5].toSubarray\nBecause sub-arrays merely store the start and end indices of interest in the underlying array, the array itself can be recovered:#eval ten[2:6].array == ten\ntrue\n\n\n"}});