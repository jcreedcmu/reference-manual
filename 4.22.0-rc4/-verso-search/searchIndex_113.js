window.docContents[113].resolve({"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values":{"id":"/Type-Classes/Basic-Classes/#The-Lean-Language-Reference--Type-Classes--Basic-Classes--Minimum-and-Maximum-Values","header":"11.5.3. Minimum and Maximum Values","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","contents":"The classes Max and Min provide overloaded operators for choosing the greater or lesser of two values.\nThese should be in agreement with Ord, LT, and LE instances, if they exist, but there is no mechanism to enforce this.\n\nAn overloaded operation to find the lesser of two values of type α.Returns the lesser of its two arguments.\n\nAn overloaded operation to find the greater of two values of type α.Returns the greater of its two arguments.\n\nGiven an LE α instance for which LE.le is decidable, the helpers minOfLe and maxOfLe can be used to create suitable Min α and Max α instances.\nThey can be used as the right-hand side of an instance declaration.Constructs a Min instance from a decidable ≤ operation.Constructs a Max instance from a decidable ≤ operation.\n\n"},"/The--grind--tactic/Quick-Start/#The-Lean-Language-Reference--The--grind--tactic--Quick-Start":{"id":"/The--grind--tactic/Quick-Start/#The-Lean-Language-Reference--The--grind--tactic--Quick-Start","header":"17.1. Quick Start","context":"Lean Reference\u0009The  grind  tactic","contents":"* Availability – grind ships with Lean 4 (no extra installation) and is usable in any Lean file—just write by grind. No extra import is required beyond what your own definitions already need.* Library support – Lean’s standard library is already annotated with @[grind] attributes, so common lemmas are discovered automatically. Mathlib will be annotated gradually, starting with its most frequently used theories.* First proofexample (a b c : Nat) (h₁ : a = b) (h₂ : b = c) :\n    a = c := by\n  grind\nThis succeeds instantly using congruence closure.* Power examples – showcasing grind's satellite solvers:* Algebraic reasoning (commutative‑ring solver):example [CommRing α] [NoNatZeroDivisors α] (a b c : α)\n    : a + b + c = 3 →\n      a^2 + b^2 + c^2 = 5 →\n      a^3 + b^3 + c^3 = 7 →\n      a^4 + b^4 = 9 - c^4 := by\n  grind\n* Finite‑field style reasoning (works in Fin 11):example (x y : Fin 11) :\n    x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind\n* Linear integer arithmetic with case analysis:example (x y : Int) :\n    27 ≤ 11*x + 13*y →\n    11*x + 13*y ≤ 45 →\n    -10 ≤ 7*x - 9*y →\n    7*x - 9*y ≤ 4 → False := by\n  grind\n* Useful flags* by grind (splits := 3) (ematch := 2) – limit case splits / E‑matching rounds.\n\n"},"/Basic-Types/Strings/#string-api-modify":{"id":"/Basic-Types/Strings/#string-api-modify","header":"19.8.4.8. Manipulation","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","contents":"Splits a string at each character for which p returns true.The characters that satisfy p are not included in any of the resulting strings. If multiple\ncharacters in a row satisfy p, then the resulting list will contain empty strings.Examples:* \"coffee tea water\".split (·.isWhitespace) = [\"coffee\", \"tea\", \"water\"]* \"coffee  tea  water\".split (·.isWhitespace) = [\"coffee\", \"\", \"tea\", \"\", \"water\"]* \"fun x =>\\n  x + 1\\n\".split (· == '\\n') = [\"fun x =>\", \"  x + 1\", \"\"]\n\nSplits a string s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings.Examples:* \"here is some text \".splitOn = [\"here\", \"is\", \"some\", \"text\", \"\"]* \"here is some text \".splitOn \"some\" = [\"here is \", \" text \"]* \"here is some text \".splitOn \"\" = [\"here is some text \"]* \"ababacabac\".splitOn \"aba\" = [\"\", \"bac\", \"c\"]\n\nAdds a character to the end of a string.The internal implementation uses dynamic arrays and will perform destructive updates\nif the string is not shared.Examples:* \"abc\".push 'd' = \"abcd\"* \"\".push 'a' = \"a\"\n\nAdds multiple repetitions of a character to the end of a string.Returns s, with n repetitions of c at the end. Internally, the implementation repeatedly calls\nString.push, so the string is modified in-place if there is a unique reference to it.Examples:* \"indeed\".pushn '!' 2 = \"indeed!!\"* \"indeed\".pushn '!' 0 = \"indeed\"* \"\".pushn ' ' 4 = \"    \"\n\nReplaces the first character in s with the result of applying Char.toUpper to it. Returns the\nempty string if the string is empty.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".capitalize = \"Orange\"* \"ORANGE\".capitalize = \"ORANGE\"* \"\".capitalize = \"\"\n\nReplaces the first character in s with the result of applying Char.toLower to it. Returns the\nempty string if the string is empty.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"Orange\".decapitalize = \"orange\"* \"ORANGE\".decapitalize = \"oRANGE\"* \"\".decapitalize = \"\"\n\nReplaces each character in s with the result of applying Char.toUpper to it.Char.toUpper has no effect on characters outside of the range 'a'–'z'.Examples:* \"orange\".toUpper = \"ORANGE\"* \"abc123\".toUpper = \"ABC123\"\n\nReplaces each character in s with the result of applying Char.toLower to it.Char.toLower has no effect on characters outside of the range 'A'–'Z'.Examples:* \"ORANGE\".toLower = \"orange\"* \"Orange\".toLower = \"orange\"* \"ABc123\".toLower = \"abc123\"\n\n"}});