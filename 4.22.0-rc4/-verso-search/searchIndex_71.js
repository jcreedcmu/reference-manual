window.docContents[71].resolve({"/Type-Classes/Basic-Classes/#basic-classes":{"id":"/Type-Classes/Basic-Classes/#basic-classes","header":"11.5. Basic Classes","context":"Lean Reference\u0009Type Classes","contents":"Many Lean type classes exist in order to allow built-in notations such as addition or array indexing to be overloaded.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Terms/do--Notation/#The-Lean-Language-Reference--Terms--do--Notation":{"id":"/Terms/do--Notation/#The-Lean-Language-Reference--Terms--do--Notation","header":"10.12. do -Notation","context":"Lean Reference\u0009Terms","contents":"do-notation is described in the chapter on monads.\n\n"},"/Terms/Proofs/#The-Lean-Language-Reference--Terms--Proofs":{"id":"/Terms/Proofs/#The-Lean-Language-Reference--Terms--Proofs","header":"10.13. Proofs","context":"Lean Reference\u0009Terms","contents":"The syntax for invoking tactics (by) is described in the section on proofs.\n\n\n"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-search":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-search","header":"13.5.14. Library Search","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"The library search tactics are intended for interactive use.\nWhen run, they search the Lean library for lemmas or rewrite rules that could be applicable in the current situation, and suggests a new tactic.\nThese tactics should not be left in a proof; rather, their suggestions should be incorporated.\n\nSearches environment for definitions or theorems that can solve the goal using exact\nwith conditions resolved by solve_by_elim.The optional using clause provides identifiers in the local context that must be\nused by exact? when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n\nSearches environment for definitions or theorems that can refine the goal using apply\nwith conditions resolved when possible with solve_by_elim.The optional using clause provides identifiers in the local context that must be\nused when closing the goal.\n\nIn this proof state:i j k : Nat\nh1 : i < j\nh2 : j < k\n⊢ i < k\ninvoking apply? suggests:Try this: exact Nat.lt_trans h1 h2\n\n\nrw? tries to find a lemma which can rewrite the goal.rw? should not be left in proofs; it is a search tool, like apply?.Suggestions are printed as rw [h] or rw [← h].You can use rw? [-my_lemma, -my_theorem] to prevent rw? using the named lemmas.\n\n"},"/Notations-and-Macros/Macros/#macro-exceptions":{"id":"/Notations-and-Macros/Macros/#macro-exceptions","header":"20.5.2.1. Exceptions and Errors","context":"Lean Reference\u0009Notations and Macros\u0009Macros\u0009The Macro Monad","contents":"The unsupportedSyntax exception is used for control flow during macro expansion.\nIt indicates that the current macro is incapable of expanding the received syntax, but that an error has not occurred.\nThe exceptions thrown by throwError and throwErrorAt terminate macro expansion, reporting the error to the user.\n\nThrow an unsupportedSyntax exception.\n\nAn unsupported syntax exception. We keep this separate because it is\nused for control flow: if one macro does not support a syntax then we try\nthe next one.\n\nThrow an error with the given message,\nusing the ref for the location information.\n\nThrow an error with the given message and location information.\n\n"},"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Inhabited":{"id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Inhabited","header":"19.14.2.4. Inhabited","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","contents":"The Inhabited definitions for Sum and PSum are not registered as instances.\nThis is because there are two separate ways to construct a default value (via inl or inr), and instance synthesis might result in either choice.\nThe result could be situations where two identically-written terms elaborate differently and are not definitionally equal.\n\nBoth types have Nonempty instances, for which proof irrelevance makes the choice of inl or inr not matter.\nThis is enough to enable partial functions.\nFor situations that require an Inhabited instance, such as programs that use panic!, the instance can be explicitly used by adding it to the local context with have or let.\n\nInhabited Sum TypesIn Lean's logic, panic! is equivalent to the default value specified in its type's Inhabited instance.\nThis means that the type must have such an instance—a Nonempty instance combined with the axiom of choice would render the program non-computable.Products have the right instance:example : Nat × String := panic! \"Cant' find it\"\nSums do not, by default:example : Nat ⊕ String := panic! \"Cant' find it\"\nfailed to synthesize\n  Inhabited (Nat ⊕ String)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe desired instance can be made available to instance synthesis using have:example : Nat ⊕ String :=\n  have : Inhabited (Nat ⊕ String) := Sum.inhabitedLeft\n  panic! \"Cant' find it\"\n\n\nIf the left type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the right type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the left type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\nIf the right type in a sum is inhabited then the sum is inhabited.This is not an instance to avoid non-canonical instances when both the left and right types are\ninhabited.\n\n"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons":{"id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Comparisons","header":"19.6.2.4. Comparisons","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","contents":"Checks whether two floating-point numbers are equal according to IEEE 754.Floating-point equality does not correspond with propositional equality. In particular, it is not\nreflexive since NaN != NaN, and it is not a congruence because 0.0 == -0.0, but\n1.0 / 0.0 != 1.0 / -0.0.This function does not reduce in the kernel. It is compiled to the C equality operator.\n\nChecks whether two floating-point numbers are equal according to IEEE 754.Floating-point equality does not correspond with propositional equality. In particular, it is not\nreflexive since NaN != NaN, and it is not a congruence because 0.0 == -0.0, but\n1.0 / 0.0 != 1.0 / -0.0.This function does not reduce in the kernel. It is compiled to the C equality operator.\n\n\n\n"}});