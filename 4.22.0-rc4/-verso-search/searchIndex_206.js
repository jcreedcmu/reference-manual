window.docContents[206].resolve({"/releases/v4.9.0/#release-v4___9___0":{"id":"/releases/v4.9.0/#release-v4___9___0","header":"Lean 4.9.0 (2024-07-01)","context":"Lean Reference\u0009Release Notes","contents":"Language features, tactics, and metaprograms* Definition transparency* #4053 adds the seal and unseal commands, which make definitions locally be irreducible or semireducible.* #4061 marks functions defined by well-founded recursion with @[irreducible] by default,\nwhich should prevent the expensive and often unfruitful unfolding of such definitions (see breaking changes below).* Incrementality* #3940 extends incremental elaboration into various steps inside of declarations:\ndefinition headers, bodies, and tactics.Screen recording.* 250994\nand 67338b\nadd @[incremental] attribute to mark an elaborator as supporting incremental elaboration.* #4259 improves resilience by ensuring incremental commands and tactics are reached only in supported ways.* #4268 adds special handling for := by so that stray tokens in tactic blocks do not inhibit incrementality.* #4308 adds incremental have tactic.* #4340 fixes incorrect info tree reuse.* #4364 adds incrementality for careful command macros such as set_option in theorem, theorem foo.bar, and lemma.* #4395 adds conservative fix for whitespace handling to avoid incremental reuse leading to goals in front of the text cursor being shown.* #4407 fixes non-incremental commands in macros blocking further incremental reporting.* #4436 fixes incremental reporting when there are nested tactics in terms.* #4459 adds incrementality support for next and if tactics.* #4554 disables incrementality for tactics in terms in tactics.* Functional induction* #4135 ensures that the names used for functional induction are reserved.* #4327 adds support for structural recursion on reflexive types.\nFor example,inductive Many (α : Type u) where\n  | none : Many α\n  | more : α → (Unit → Many α) → Many α\n\ndef Many.map {α β : Type u} (f : α → β) : Many α → Many β\n  | .none => .none\n  | .more x xs => .more (f x) (fun _ => (xs ()).map f)\n\n#check Many.map.induct\n/-\nMany.map.induct {α β : Type u} (f : α → β) (motive : Many α → Prop)\n  (case1 : motive Many.none)\n  (case2 : ∀ (x : α) (xs : Unit → Many α), motive (xs ()) → motive (Many.more x xs)) :\n  ∀ (a : Many α), motive a\n-/\n* #3903 makes the Lean frontend normalize all line endings to LF before processing.\nThis lets Lean be insensitive to CRLF vs LF line endings, improving the cross-platform experience and making Lake hashes be faithful to what Lean processes.* #4130 makes the tactic framework be able to recover from runtime errors (for example, deterministic timeouts or maximum recursion depth errors).* split tactic* #4211 fixes split at h when h has forward dependencies.* #4349 allows split for if-expressions to work on non-propositional goals.* apply tactic* #3929 makes error message for apply show implicit arguments in unification errors as needed.\nModifies MessageData type (see breaking changes below).* cases tactic* #4224 adds support for unification of offsets such as x + 20000 = 20001 in cases tactic.* omega tactic* #4073 lets omega fall back to using classical Decidable instances when setting up contradiction proofs.* #4141 and #4184 fix bugs.* #4264 improves omega error message if no facts found in local context.* #4358 improves expression matching in omega by using match_expr.* simp tactic* #4176 makes names of erased lemmas clickable.* #4208 adds a pretty printer for discrimination tree keys.* #4202 adds Simp.Config.index configuration option,\nwhich controls whether to use the full discrimination tree when selecting candidate simp lemmas.\nWhen index := false, only the head function is taken into account, like in Lean 3.\nThis feature can help users diagnose tricky simp failures or issues in code from libraries\ndeveloped using Lean 3 and then ported to Lean 4.In the following example, it will report that foo is a problematic theorem.opaque f : Nat → Nat → Nat\n\n@[simp] theorem foo : f x (x, y).2 = y := by sorry\n\nexample : f a b ≤ b := by\n  set_option diagnostics true in\n  simp (config := { index := false })\n/-\n[simp] theorems with bad keys\n  foo, key: f _ (@Prod.mk ℕ ℕ _ _).2\n-/\nWith the information above, users can annotate theorems such as foo using no_index for problematic subterms. Example:opaque f : Nat → Nat → Nat\n\n@[simp] theorem foo : f x (no_index (x, y).2) = y := by sorry\n\nexample : f a b ≤ b := by\n  simp -- `foo` is still applied with `index := true`\n* #4274 prevents internal match equational theorems from appearing in simp trace.* #4177 and #4359 make simp continue even if a simp lemma does not elaborate, if the tactic state is in recovery mode.* #4341 fixes panic when applying @[simp] to malformed theorem syntax.* #4345 fixes simp so that it does not use the forward version of a user-specified backward theorem.* #4352 adds missing dsimp simplifications for fixed parameters of generated congruence theorems.* #4362 improves trace messages for simp so that constants are hoverable.* Elaboration* #4046 makes subst notation (he ▸ h) try rewriting in both directions even when there is no expected type available.* #3328 adds support for identifiers in autoparams (for example, rfl in (h : x = y := by exact rfl)).* #4096 changes how the type in let and have is elaborated, requiring that any tactics in the type be evaluated before proceeding, improving performance.* #4215 ensures the expression tree elaborator commits to the computed \"max type\" for the entire arithmetic expression.* #4267 cases signature elaboration errors to show even if there are parse errors in the body.* #4368 improves error messages when numeric literals fail to synthesize an OfNat instance,\nincluding special messages warning when the expected type of the numeral can be a proposition.* #4643 fixes issue leading to nested error messages and info trees vanishing, where snapshot subtrees were not restored on reuse.* #4657 calculates error suppression per snapshot, letting elaboration errors appear even when there are later parse errors (RFC #3556).* Metaprogramming* #4167 adds Lean.MVarId.revertAll to revert all free variables.* #4169 adds Lean.MVarId.ensureNoMVar to ensure the goal's target contains no expression metavariables.* #4180 adds cleanupAnnotations parameter to forallTelescope methods.* #4307 adds support for parser aliases in syntax quotations.* Work toward implementing grind tactic* 0a515e\nand #4164\nadd grind_norm and grind_norm_proc attributes and @[grind_norm] theorems.* #4170, #4221,\nand #4249 create grind preprocessor and core module.* #4235 and d6709e\nadd special cases tactic to grind along with @[grind_cases] attribute to mark types that this cases tactic should automatically apply to.* #4243 adds special injection? tactic to grind.* Other fixes or improvements* #4065 fixes a bug in the Nat.reduceLeDiff simproc.* #3969 makes deprecation warnings activate even for generalized field notation (\"dot notation\").* #4132 fixes the sorry term so that it does not activate the implicit lambda feature* 9803c5\nand 47c8e3\nmove cdot and calc parsers to Lean namespace.* #4252 fixes the case tactic so that it is usable in macros by having it erase macro scopes from the tag.* 26b671\nand cc33c3\nextract haveId syntax.* #4335 fixes bugs in partial calc tactic when there is mdata or metavariables.* #4329 makes termination_by? report unused each unused parameter as _.* Docs: #4238, #4294,\n#4338.Language server, widgets, and IDE extensions* #4066 fixes features like \"Find References\" when browsing core Lean sources.* #4254 allows embedding user widgets in structured messages.\nCompanion PR is vscode-lean4#449.* #4445 makes watchdog more resilient against badly behaving clients.Library* #4059 upstreams many List and Array operations and theorems from Batteries.* #4055 removes the unused Inhabited instance for Subtype.* #3967 adds dates in existing @[deprecated] attributes.* #4231 adds boilerplate Char, UInt, and Fin theorems.* #4205 fixes the MonadStore type classes to use semiOutParam.* #4350 renames IsLawfulSingleton to LawfulSingleton.* Nat* #4094 swaps Nat.zero_or and Nat.or_zero.* #4098 and #4145\nchange the definition of Nat.mod so that n % (m + n) reduces when n is literal without relying on well-founded recursion,\nwhich becomes irreducible by default in #4061.* #4188 redefines Nat.testBit to be more performant.* Theorems: #4199.* Array* #4074 improves the functional induction principle Array.feraseIdx.induct.* List* #4172 removes @[simp] from List.length_pos.* Option* #4037 adds theorems to simplify Option-valued dependent if-then-else.* #4314 removes @[simp] from Option.bind_eq_some.* BitVec* Theorems: #3920, #4095,\n#4075, #4148,\n#4165, #4178,\n#4200, #4201,\n#4298, #4299,\n#4257, #4179,\n#4321, #4187.* #4193 adds simprocs for reducing x >>> i and x <<< i where i is a bitvector literal.* #4194 adds simprocs for reducing (x <<< i) <<< j and (x >>> i) >>> j where i and j are natural number literals.* #4229 redefines rotateLeft/rotateRight to use modulo reduction of shift offset.* 0d3051 makes <num>#<term> bitvector literal notation global.* Char/String* #4143 modifies String.substrEq to avoid linter warnings in downstream code.* #4233 adds simprocs for Char and String inequalities.* #4348 upstreams Mathlib lemmas.* #4354 upstreams basic String lemmas.* HashMap* #4248 fixes implicitness of typeclass arguments in HashMap.ofList.* IO* #4036 adds IO.Process.getCurrentDir and IO.Process.setCurrentDir for adjusting the current process's working directory.* Cleanup: #4077, #4189,\n#4304.* Docs: #4001, #4166,\n#4332.Lean internals* Defeq and WHNF algorithms* #4029 remove unnecessary checkpointDefEq* #4206 fixes isReadOnlyOrSyntheticOpaque to respect metavariable depth.* #4217 fixes missing occurs check for delayed assignments.* Definition transparency* #4052 adds validation to application of @[reducible]/@[semireducible]/@[irreducible] attributes (with local/scoped modifiers as well).\nSetting set_option allowUnsafeReductibility true turns this validation off.* Inductive types* #3591 fixes a bug where indices could be incorrectly promoted to parameters.* #3398 fixes a bug in the injectivity theorem generator.* #4342 fixes elaboration of mutual inductives with instance parameters.* Diagnostics and profiling* #3986 adds option trace.profiler.useHeartbeats to switch trace.profiler.threshold to being in terms of heartbeats instead of milliseconds.* #4082 makes set_option diagnostics true report kernel diagnostic information.* Typeclass resolution* #4119 fixes multiple issues with TC caching interacting with synthPendingDepth, adds maxSynthPendingDepth option with default value 1.* #4210 ensures local instance cache does not contain multiple copies of the same instance.* #4216 fix handling of metavariables, to avoid needing to set the option backward.synthInstance.canonInstances to false.* Other fixes or improvements* #4080 fixes propagation of state for Lean.Elab.Command.liftCoreM and Lean.Elab.Command.liftTermElabM.* #3944 makes the Repr deriving handler be consistent between structure and inductive for how types and proofs are erased.* #4113 propagates maxHeartbeats to kernel to control \"(kernel) deterministic timeout\" error.* #4125 reverts #3970 (monadic generalization of FindExpr).* #4128 catches stack overflow in auto-bound implicits feature.* #4129 adds tryCatchRuntimeEx combinator to replace catchRuntimeEx reader state.* #4155 simplifies the expression canonicalizer.* #4151 and #4369\nadd many missing trace classes.* #4185 makes congruence theorem generators clean up type annotations of argument types.* #4192 fixes restoration of infotrees when auto-bound implicit feature is activated,\nfixing a pretty printing error in hovers and strengthening the unused variable linter.* dfb496 fixes declareBuiltin to allow it to be called multiple times per declaration.* #4569 fixes an issue introduced in a merge conflict, where the interrupt exception was swallowed by some tryCatchRuntimeEx uses.* #4584 (backported as b056a0) adapts kernel interruption to the new cancellation system.* Cleanup: #4112, #4126, #4091, #4139, #4153.* Tests: 030406, #4133.Compiler, runtime, and FFI* #4100 improves reset/reuse algorithm; it now runs a second pass relaxing the constraint that reused memory cells must only be for the exact same constructor.* #2903 fixes segfault in old compiler from mishandling noConfusion applications.* #4311 fixes bug in constant folding.* #3915 documents the runtime memory layout for inductive types.Lake* #4518 makes trace reading more robust. Lake now rebuilds if trace files are invalid or unreadable and is backwards compatible with previous pure numeric traces.* #4057 adds support for docstrings on require commands.* #4088 improves hovers for family_def and library_data commands.* #4147 adds default README.md to package templates* #4261 extends lake test help page, adds help page for lake check-test,\nadds lake lint and tag @[lint_driver], adds support for specifying test and lint drivers from dependencies,\nadds testDriverArgs and lintDriverArgs options, adds support for library test drivers,\nmakes lake check-test and lake check-lint only load the package without dependencies.* #4270 adds lake pack and lake unpack for packing and unpacking Lake build artifacts from an archive.* #4083\nSwitches the manifest format to use major.minor.patch semantic\nversions. Major version increments indicate breaking changes (e.g., new\nrequired fields and semantic changes to existing fields). Minor version\nincrements (after 0.x) indicate backwards-compatible extensions (e.g.,\nadding optional fields, removing fields). This change is backwards\ncompatible. Lake will still successfully read old manifests with numeric\nversions. It will treat the numeric version N as semantic version\n0.N.0. Lake will also accept manifest versions with - suffixes\n(e.g., x.y.z-foo) and then ignore the suffix.* #4273 adds a lift from JobM to FetchM for backwards compatibility reasons.* #4351 fixes LogIO-to-CliM-lifting performance issues.* #4343 make Lake store the dependency trace for a build in\nthe cached build long and then verifies that it matches the trace of the current build before replaying the log.* #4402 moves the cached log into the trace file (no more .log.json).\nThis means logs are no longer cached on fatal errors and this ensures that an out-of-date log is not associated with an up-to-date trace.\nSeparately, .hash file generation was changed to be more reliable as well.\nThe .hash files are deleted as part of the build and always regenerate with --rehash.* Other fixes or improvements* #4056 cleans up tests* #4244 fixes noRelease test when Lean repo is tagged* #4346 improves tests/serve* #4356 adds build log path to the warning for a missing or invalid build log.DevOps* #3984 adds a script (script/rebase-stage0.sh) for git rebase -i that automatically updates each stage0.* #4108 finishes renamings from transition to Std to Batteries.* #4109 adjusts the Github bug template to mention testing using live.lean-lang.org.* #4136 makes CI rerun only when full-ci label is added or removed.* #4175 and 72b345\nswitch to using #guard_msgs to run tests as much as possible.* #3125 explains the Lean4 pygments lexer.* #4247 sets up a procedure for preparing release notes.* #4032 modernizes build instructions and workflows.* #4255 moves some expensive checks from merge queue to releases.* #4265 adds aarch64 macOS as native compilation target for CI.* f05a82 restores macOS aarch64 install suffix in CI* #4317 updates build instructions for macOS.* #4333 adjusts workflow to update Batteries in manifest when creating lean-pr-testing-NNNN Mathlib branches.* #4355 simplifies lean4checker step of release checklist.* #4361 adds installing elan to pr-release CI step.* #4628 fixes the Windows build, which was missing an exported symbol.Breaking changesWhile most changes could be considered to be a breaking change, this section makes special note of API changes.* Nat.zero_or and Nat.or_zero have been swapped (#4094).* IsLawfulSingleton is now LawfulSingleton (#4350).* The BitVec literal notation is now <num>#<term> rather than <term>#<term>, and it is global rather than scoped. Use BitVec.ofNat w x rather than x#w when x is a not a numeric literal (0d3051).* BitVec.rotateLeft and BitVec.rotateRight now take the shift modulo the bitwidth (#4229).* These are no longer simp lemmas:\nList.length_pos (#4172),\nOption.bind_eq_some (#4314).* Types in let and have (both the expressions and tactics) may fail to elaborate due to new restrictions on what sorts of elaboration problems may be postponed (#4096).\nIn particular, tactics embedded in the type will no longer make use of the type of value in expressions such as let x : type := value; body.* Now functions defined by well-founded recursion are marked with @[irreducible] by default (#4061).\nExisting proofs that hold by definitional equality (e.g. rfl) can be\nrewritten to explicitly unfold the function definition (using simp,\nunfold, rw), or the recursive function can be temporarily made\nsemireducible (using unseal f in before the command), or the function\ndefinition itself can be marked as @[semireducible] to get the previous\nbehavior.* Due to #3929:* The MessageData.ofPPFormat constructor has been removed.\nIts functionality has been split into two:* for lazy structured messages, please use MessageData.lazy;* for embedding Format or FormatWithInfos, use MessageData.ofFormatWithInfos.An example migration can be found in #3929.* The MessageData.ofFormat constructor has been turned into a function.\nIf you need to inspect MessageData, you can pattern-match on MessageData.ofFormatWithInfos.\n\n"},"/Type-Classes/Instance-Synthesis/#class-output-parameters":{"id":"/Type-Classes/Instance-Synthesis/#class-output-parameters","header":"11.3.5. Output Parameters","context":"Lean Reference\u0009Type Classes\u0009Instance Synthesis","contents":"By default, the parameters of a type class are considered to be inputs to the search process.\nIf the parameters are not known, then the search process gets stuck, because choosing an instance would require the parameters to have values that match those in the instance, which cannot be determined on the basis of incomplete information.\nIn most cases, guessing instances would make instance synthesis unpredictable.\n\nIn some cases, however, the choice of one parameter should cause an automatic choice of another.\nFor example, the overloaded membership predicate type class Membership treats the type of elements of a data structure as an output, so that the type of element can be determined by the type of data structure at a use site, instead of requiring that there be sufficient type annotations to determine both types prior to starting instance synthesis.\nAn element of a List Nat can be concluded to be a Nat simply on the basis of its membership in the list.\n\n\n\nType class parameters can be declared as outputs by wrapping their types in the outParam gadget.\nWhen a class parameter is an output parameter, instance synthesis will not require that it be known; in fact, any existing value is ignored completely.\nThe first instance that matches the input parameters is selected, and that instance's assignment of the output parameter becomes its value.\nIf there was a pre-existing value, then it is compared with the assignment after synthesis is complete, and it is an error if they do not match.\n\nGadget for marking output parameters in type classes.For example, the Membership class is defined as:class Membership (α : outParam (Type u)) (γ : Type v)\nThis means that whenever a typeclass goal of the form Membership ?α ?γ comes\nup, Lean will wait to solve it until ?γ is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of ?α,\nwhich thereby determines what ?α should be.This expresses that in a term like a ∈ s, s might be a Set α or\nList α or some other type with a membership operation, and in each case\nthe \"member\" type α is determined by looking at the container type.\n\nOutput Parameters and Stuck SearchThis serialization framework provides a way to convert values to some underlying storage type:class Serialize (input output : Type) where\n  ser : input → output\nexport Serialize (ser)\n\ninstance : Serialize Nat String where\n  ser n := toString n\n\ninstance [Serialize α γ] [Serialize β γ] [Append γ] :\n    Serialize (α × β) γ where\n  ser\n    | (x, y) => ser x ++ ser y\nIn this example, the output type is unknown.example := ser (2, 3)\nInstance synthesis can't select the Serialize Nat String instance, and thus the Append String instance, because that would require instantiating the output type as String, so the search gets stuck:typeclass instance problem is stuck, it is often due to metavariables\n  Serialize (Nat × Nat) ?m.16\nOne way to fix the problem is to supply an expected type:example : String := ser (2, 3)\nThe other is to make the output type into an output parameter:class Serialize (input : Type) (output : outParam Type) where\n  ser : input → output\nexport Serialize (ser)\n\ninstance : Serialize Nat String where\n  ser n := toString n\n\ninstance [Serialize α γ] [Serialize β γ] [Append γ] :\n    Serialize (α × β) γ where\n  ser\n    | (x, y) => ser x ++ ser y\nNow, instance synthesis is free to select the Serialize Nat String instance, which solves the unknown implicit output parameter of ser:example := ser (2, 3)\n\n\nOutput Parameters with Pre-Existing ValuesThe class OneSmaller represents a way to transform non-maximal elements of a type into elements of a type that has one fewer elements.\nThere are two separate instances that can match an input type Option Bool, with different outputs:class OneSmaller (α : Type) (β : outParam Type) where\n  biggest : α\n  shrink : (x : α) → x ≠ biggest → β\n\ninstance : OneSmaller (Option α) α where\n  biggest := none\n  shrink\n    | some x, _ => x\n\ninstance : OneSmaller (Option Bool) (Option Unit) where\n  biggest := some true\n  shrink\n    | none, _ => none\n    | some false, _ => some ()\n\ninstance : OneSmaller Bool Unit where\n  biggest := true\n  shrink\n    | false, _ => ()\nBecause instance synthesis selects the most recently defined instance, the following code is an error:#check OneSmaller.shrink (β := Bool) (some false) sorry\nfailed to synthesize\n  OneSmaller (Option Bool) Bool\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nThe OneSmaller (Option Bool) (Option Unit) instance was selected during instance synthesis, without regard to the supplied value of β.\n\nSemi-output parameters are like output parameters in that they are not required to be known prior to synthesis commencing; unlike output parameters, their values are taken into account when selecting instances.\n\nGadget for marking semi output parameters in type classes.Semi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as [Mul β] : Add α (because β could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.For example, the Coe class is defined as:class Coe (α : semiOutParam (Sort u)) (β : Sort v)\nThis means that all Coe instances should provide a concrete value for α\n(i.e., not an assignable metavariable). An instance like Coe Nat Int or Coe α (Option α) is fine, but Coe α Nat is not since it does not provide a value\nfor α.\n\nSemi-output parameters impose a requirement on instances: each instance of a class with semi-output parameters should determine the values of its semi-output parameters.\n\n\n\nSemi-Output Parameters with Pre-Existing ValuesThe class OneSmaller represents a way to transform non-maximal elements of a type into elements of a type that one fewer elements.\nIt has two separate instances that can match an input type Option Bool, with different outputs:class OneSmaller (α : Type) (β : semiOutParam Type) where\n  biggest : α\n  shrink : (x : α) → x ≠ biggest → β\n\ninstance : OneSmaller (Option α) α where\n  biggest := none\n  shrink\n    | some x, _ => x\n\ninstance : OneSmaller (Option Bool) (Option Unit) where\n  biggest := some true\n  shrink\n    | none, _ => none\n    | some false, _ => some ()\n\ninstance : OneSmaller Bool Unit where\n  biggest := true\n  shrink\n    | false, _ => ()\nBecause instance synthesis takes semi-output parameters into account when selecting instances, the OneSmaller (Option Bool) (Option Unit) instance is passed over due to the supplied value for β:#check OneSmaller.shrink (β := Bool) (some false) sorry\nOneSmaller.shrink (some false) ⋯ : Bool\n\n\n"},"/The-Type-System/Inductive-Types/#inductive-types-ffi":{"id":"/The-Type-System/Inductive-Types/#inductive-types-ffi","header":"4.4.4.4.1. FFI","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Run-Time Representation\u0009Other Inductive Types","contents":"From the perspective of C, these other inductive types are represented by lean_object *.\nEach constructor is stored as a lean_ctor_object, and lean_is_ctor will return true.\nA lean_ctor_object stores the constructor index in its header, and the fields are stored in the m_objs portion of the object.\nLean assumes that sizeof(size_t) == sizeof(void*)—while this is not guaranteed by C, the Lean run-time system contains an assertion that fails if this is not the case.\n\nThe memory order of the fields is derived from the types and order of the fields in the declaration. They are ordered as follows:\n\n* Non-scalar fields stored as lean_object ** Fields of type USize* Other scalar fields, in decreasing order by size\n\nWithin each group the fields are ordered in declaration order. Warning: Trivial wrapper types still count toward a field being treated as non-scalar for this purpose.\n\n* To access fields of the first kind, use lean_ctor_get(val, i) to get the ith non-scalar field.* To access USize fields, use lean_ctor_get_usize(val, n+i) to get the ith USize field and n is the total number of fields of the first kind.* To access other scalar fields, use lean_ctor_get_uintN(val, off) or lean_ctor_get_usize(val, off) as appropriate. Here off is the byte offset of the field in the structure, starting at n*sizeof(void*) where n is the number of fields of the first two kinds.\n\nFor example, a structure such asstructure S where\n  ptr_1 : Array Nat\n  usize_1 : USize\n  sc64_1 : UInt64\n  -- wrappers don't count as scalars:\n  ptr_2 : { x : UInt64 // x > 0 }\n  sc64_2 : Float -- `Float` is 64 bit\n  sc8_1 : Bool\n  sc16_1 : UInt16\n  sc8_2 : UInt8\n  sc64_3 : UInt64\n  usize_2 : USize\n  -- trivial wrapper around `UInt32`\n  ptr_3 : Char\n  sc32_1 : UInt32\n  sc16_2 : UInt16\nwould get re-sorted into the following memory order:* S.ptr_1 - lean_ctor_get(val, 0)* S.ptr_2 - lean_ctor_get(val, 1)* S.ptr_3 - lean_ctor_get(val, 2)* S.usize_1 - lean_ctor_get_usize(val, 3)* S.usize_2 - lean_ctor_get_usize(val, 4)* S.sc64_1 - lean_ctor_get_uint64(val, sizeof(void*)*5)* S.sc64_2 - lean_ctor_get_float(val, sizeof(void*)*5 + 8)* S.sc64_3 - lean_ctor_get_uint64(val, sizeof(void*)*5 + 16)* S.sc32_1 - lean_ctor_get_uint32(val, sizeof(void*)*5 + 24)* S.sc16_1 - lean_ctor_get_uint16(val, sizeof(void*)*5 + 28)* S.sc16_2 - lean_ctor_get_uint16(val, sizeof(void*)*5 + 30)* S.sc8_1 - lean_ctor_get_uint8(val, sizeof(void*)*5 + 32)* S.sc8_2 - lean_ctor_get_uint8(val, sizeof(void*)*5 + 33)\n\n\n\n"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility":{"id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Controlling-Reduction--Modifying-Reducibility","header":"7.6.6.2. Modifying Reducibility","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Controlling Reduction","contents":"The reducibility of a definition can be globally modified in the module in which it is defined by applying the appropriate attribute with the attribute command.\nIn other modules, the reducibility of imported definitions can be modified by applying the attribute with the local modifier.\nThe seal and  unseal commands are a shorthand for this process.\n\nLocal IrreducibilityThe seal foo command ensures that the definition of foo is sealed, meaning it is marked as [irreducible].\nThis command is particularly useful in contexts where you want to prevent the reduction of foo in proofs.In terms of functionality, seal foo is equivalent to attribute [local irreducible] foo.\nThis attribute specifies that foo should be treated as irreducible only within the local scope,\nwhich helps in maintaining the desired abstraction level without affecting global settings.\n\nLocal ReducibilityThe unseal foo command ensures that the definition of foo is unsealed, meaning it is marked as [semireducible], the\ndefault reducibility setting. This command is useful when you need to allow some level of reduction of foo in proofs.Functionally, unseal foo is equivalent to attribute [local semireducible] foo.\nApplying this attribute makes foo semireducible only within the local scope.\n\n"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Transformation":{"id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Transformation","header":"19.15.3.11. Transformation","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","contents":"Applies a function to each element of the list, returning the resulting list of values.O(|l|).Examples:* [a, b, c].map f = [f a, f b, f c]* [].map Nat.succ = []* [\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]* [\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]\n\nApplies a function to each element of the list, returning the resulting list of values.O(|l|). This is the tail-recursive variant of List.map, used in runtime code.Examples:* [a, b, c].mapTR f = [f a, f b, f c]* [].mapTR Nat.succ = []* [\"one\", \"two\", \"three\"].mapTR (·.length) = [3, 3, 5]* [\"one\", \"two\", \"three\"].mapTR (·.reverse) = [\"eno\", \"owt\", \"eerht\"]\n\nApplies the monadic action f to every element in the list, left-to-right, and returns the list of\nresults.This implementation is tail recursive. List.mapM' is a a non-tail-recursive variant that may be\nmore convenient to reason about. List.forM is the variant that discards the results and\nList.mapA is the variant that works with Applicative.\n\nApplies the monadic action f on every element in the list, left-to-right, and returns the list of\nresults.This is a non-tail-recursive variant of List.mapM that's easier to reason about. It cannot be used\nas the main definition and replaced by the tail-recursive version because they can only be proved\nequal when m is a LawfulMonad.\n\nApplies the applicative action f on every element in the list, left-to-right, and returns the list\nof results.If m is also a Monad, then using mapM can be more efficient.See List.forA for the variant that discards the results. See List.mapM for the variant that\nworks with Monad.This function is not tail-recursive, so it may fail with a stack overflow on long lists.\n\nApplies a function to each element of the list along with the index at which that element is found,\nreturning the list of results. In addition to the index, the function is also provided with a proof\nthat the index is valid.List.mapIdx is a variant that does not provide the function with evidence that the index is valid.\n\nApplies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results. In addition to the index, the function is also provided with a\nproof that the index is valid.List.mapIdxM is a variant that does not provide the function with evidence that the index is\nvalid.\n\nApplies a function to each element of the list along with the index at which that element is found,\nreturning the list of results.List.mapFinIdx is a variant that additionally provides the function with a proof that the index\nis valid.\n\nApplies a monadic function to each element of the list along with the index at which that element is\nfound, returning the list of results.List.mapFinIdxM is a variant that additionally provides the function with a proof that the index\nis valid.\n\nApplies a function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.For verification purposes, List.mapMono = List.map.\n\nApplies a monadic function to each element of a list, returning the list of results. The function is\nmonomorphic: it is required to return a value of the same type. The internal implementation uses\npointer equality, and does not allocate a new list if the result of each function call is\npointer-equal to its argument.\n\nApplies a function that returns a list to each element of a list, and concatenates the resulting\nlists.Examples:* [2, 3, 2].flatMap List.range = [0, 1, 0, 1, 2, 0, 1]* [\"red\", \"blue\"].flatMap String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']\n\nApplies a function that returns a list to each element of a list, and concatenates the resulting\nlists.This is the tail-recursive version of List.flatMap that's used at runtime.Examples:* [2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]* [\"red\", \"blue\"].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']\n\nApplies a monadic function that returns a list to each element of a list, from left to right, and\nconcatenates the resulting lists.\n\nCombines two lists into a list of pairs in which the first and second components are the\ncorresponding elements of each list. The resulting list is the length of the shorter of the input\nlists.O(min |xs| |ys|).Examples:* [\"Mon\", \"Tue\", \"Wed\"].zip [1, 2, 3] = [(\"Mon\", 1), (\"Tue\", 2), (\"Wed\", 3)]* [\"Mon\", \"Tue\", \"Wed\"].zip [1, 2] = [(\"Mon\", 1), (\"Tue\", 2)]* [x₁, x₂, x₃].zip [y₁, y₂, y₃, y₄] = [(x₁, y₁), (x₂, y₂), (x₃, y₃)]\n\nPairs each element of a list with its index, optionally starting from an index other than 0.O(|l|).Examples:* [a, b, c].zipIdx = [(a, 0), (b, 1), (c, 2)]* [a, b, c].zipIdx 5 = [(a, 5), (b, 6), (c, 7)]\n\nPairs each element of a list with its index, optionally starting from an index other than 0.O(|l|). This is a tail-recursive version of List.zipIdx that's used at runtime.Examples:* [a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]* [a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]\n\nApplies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.O(min |xs| |ys|).Examples:* [1, 2].zipWith (· + ·) [5, 6] = [6, 8]* [1, 2, 3].zipWith (· + ·) [5, 6, 10] = [6, 8, 13]* [].zipWith (· + ·) [5, 6] = []* [x₁, x₂, x₃].zipWith f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]\n\nApplies a function to the corresponding elements of two lists, stopping at the end of the shorter\nlist.O(min |xs| |ys|). This is a tail-recursive version of List.zipWith that's used at runtime.Examples:* [1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]* [1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]* [].zipWithTR (· + ·) [5, 6] = []* [x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]\n\nApplies a function to the corresponding elements of both lists, stopping when there are no more\nelements in either list. If one list is shorter than the other, the function is passed none for\nthe missing elements.Examples:* [1, 6].zipWithAll min [5, 2] = [some 1, some 2]* [1, 2, 3].zipWithAll Prod.mk [5, 6] = [(some 1, some 5), (some 2, some 6), (some 3, none)]* [x₁, x₂].zipWithAll f [y] = [f (some x₁) (some y), f (some x₂) none]\n\nSeparates a list of pairs into two lists that contain the respective first and second components.O(|l|).Examples:* [(\"Monday\", 1), (\"Tuesday\", 2)].unzip = ([\"Monday\", \"Tuesday\"], [1, 2])* [(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzip = ([x₁, x₂, x₃], [y₁, y₂, y₃])* ([] : List (Nat × String)).unzip = (([], []) : List Nat × List String)\n\nSeparates a list of pairs into two lists that contain the respective first and second components.O(|l|). This is a tail-recursive version of List.unzip that's used at runtime.Examples:* [(\"Monday\", 1), (\"Tuesday\", 2)].unzipTR = ([\"Monday\", \"Tuesday\"], [1, 2])* [(x₁, y₁), (x₂, y₂), (x₃, y₃)].unzipTR = ([x₁, x₂, x₃], [y₁, y₂, y₃])* ([] : List (Nat × String)).unzipTR = (([], []) : List Nat × List String)\n\n"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Syntax":{"id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Syntax","header":"19.11.3. Syntax","context":"Lean Reference\u0009Basic Types\u0009Booleans","contents":"Boolean Infix OperatorsThe infix operators &&, ||, and ^^ are notations for Bool.and, Bool.or, and Bool.xor, respectively.\n\nBoolean NegationThe prefix operator ! is notation for Bool.not.\n\n"}});