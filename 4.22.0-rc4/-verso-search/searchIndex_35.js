window.docContents[35].resolve({"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-features___":{"id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--Integrating--grind-___s-features___","header":"17.12.1. Integrating  grind 's features.","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples","contents":"This example demonstrates how the various submodules of grind are seamlessly integrated. In particular we can\n\n* instantiate theorems from the library, using custom patterns,* perform case splitting,* do linear integer arithmetic reasoning, including modularity conditions, and* do Gröbner basis reasoning\nall without providing explicit instructions to drive the interactions between these modes of reasoning.\n\nFor this example we'll begin with a \"mocked up\" version of the real numbers, and the sin and cos functions.\nOf course, this example works without any changes using Mathlib's versions of these!\n\naxiom R : Type\n\n-- TODO: a `sorry` here was causing a run-time crash. It's unclear why.\n@[instance] axiom instCommRingR : Lean.Grind.CommRing R\n\naxiom sin : R → R\naxiom cos : R → R\naxiom trig_identity : ∀ x, (cos x)^2 + (sin x)^2 = 1\n\n\nOur first step is to tell grind to \"put the trig identity on the whiteboard\" whenever it sees a goal involving sin or cos:\n\ngrind_pattern trig_identity => cos x\ngrind_pattern trig_identity => sin x\n\n\nNote here we use two different patterns for the same theorem, so the theorem is instantiated even if grind sees just one of these functions.\nIf we preferred to more conservatively instantiate the theorem only when both sin and cos are present, we could have used a multi-pattern:\n\ngrind_pattern trig_identity => cos x, sin x\n\n\nFor this example, either approach will work.\n\nBecause grind immediately notices the trig identity, we can prove goals like this:\n\nexample : (cos x + sin x)^2 = 2 * cos x * sin x + 1 := by\n  grind\n\n\nHere grind:\n\n* Notices cos x and sin x, so instantiates the trig identity.* Notices that this is a polynomial in CommRing R, so sends it to the Gröbner basis module.\n  No calculation happens at this point: it's the first polynomial relation in this ring, so the Gröbner basis is updated to [(cos x)^2 + (sin x)^2 - 1].* Notices that the left and right hand sides of the goal are polynomials in CommRing R, so sends them to the Gröbner basis module for normalization.* Since their normal forms modulo (cos x)^2 + (sin x)^2 = 1 are equal, their equivalence classes are merged, and the goal is solved.\n\nWe can also do this sort of argument when congruence closure is needed:\n\nexample (f : R → Nat) :\n    f ((cos x + sin x)^2) = f (2 * cos x * sin x + 1) := by\n  grind\n\n\nAs before, grind instantiates the trig identity, notices that (cos x + sin x)^2 and 2 * cos x * sin x + 1 are equal modulo (cos x)^2 + (sin x)^2 = 1,\nputs those algebraic expressions in the same equivalence class, and then puts the function applications f((cos x + sin x)^2) and f(2 * cos x * sin x + 1) in the same equivalence class,\nand closes the goal.\n\nNotice that we've used arbitrary function f : R → Nat here; let's check that grind can use some linear integer arithmetic reasoning after the Gröbner basis steps:\n\nexample (f : R → Nat) :\n    4 * f ((cos x + sin x)^2) ≠ 2 + f (2 * cos x * sin x + 1) := by\n  grind\n\n\nHere grind first works out that this goal reduces to 4 * x ≠ 2 + x for some x : Nat (i.e. by identifying the two function applications as described above),\nand then uses modularity to derive a contradiction.\n\nFinally, we can also mix in some case splitting:\n\nexample (f : R → Nat) : max 3 (4 * f ((cos x + sin x)^2)) ≠ 2 + f (2 * cos x * sin x + 1) := by\n  grind\n\n\nAs before, grind first does the instantiation and Gröbner basis calculations required to identify the two function applications.\nHowever the cutsat algorithm by itself can't do anything with max 3 (4 * x) ≠ 2 + x.\nNext, instantiating Nat.max_def (automatically, because of an annotation in the standard library) which states max n m = if n ≤ m then m else n,\nwe then case split on the inequality.\nIn the branch 3 ≤ 4 * x, cutsat again uses modularity to prove 4 * x ≠ 2 + x.\nIn the branch 4 * x < 3, cutsat quickly determines x = 0, and then notices 4 * 0 ≠ 2 + 0.\n\nThis has been, of course, a quite artificial example! In practice this sort of automatic integration of different reasoning modes is very powerful:\nthe central \"whiteboard\" which tracks instantiated theorems and equivalence classes can hand off relevant terms and equalities to the appropriate modules (here, cutsat and Gröbner bases),\nwhich can then return new facts to the whiteboard.\n\n"},"/Terms/Conditionals/#if-then-else":{"id":"/Terms/Conditionals/#if-then-else","header":"10.7. Conditionals","context":"Lean Reference\u0009Terms","contents":"The conditional expression is used to check whether a proposition is true or false.Despite their syntactic similarity, the if used in the tactic language and the if used in do-notation are separate syntactic forms, documented in their own sections.\nThis requires that the proposition has a Decidable instance, because it's not possible to check whether arbitrary propositions are true or false.\nThere is also a coercion from Bool to Prop that results in a decidable proposition (namely, that the Bool in question is equal to true), described in the section on decidability.\n\nThere are two versions of the conditional expression: one simply performs a case distinction, while the other additionally adds an assumption about the proposition's truth or falsity to the local context.\nThis allows run-time checks to generate compile-time evidence that can be used to statically rule out errors.\n\nConditionalsWithout a name annotation, the conditional expression expresses only control flow.With the name annotation, the branches of the if have access to a local assumption that the proposition is respectively true or false.\n\nChecking Array BoundsArray indexing requires evidence that the index in question is within the bounds of the array, so getThird does not elaborate.def getThird (xs : Array α) : α := xs[2]\nfailed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nα : Type ?u.7\nxs : Array α\n⊢ 2 < xs.size\nRelaxing the return type to Option and adding a bounds check results the same error.\nThis is because the proof that the index is in bounds was not added to the local context.def getThird (xs : Array α) : Option α :=\n  if xs.size ≤ 2 then none\n  else xs[2]\nfailed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nα : Type ?u.7\nxs : Array α\n⊢ 2 < xs.size\nNaming the proof h is sufficient to enable the tactics that perform bounds checking to succeed, even though it does not occur explicitly in the text of the program.def getThird (xs : Array α) : Option α :=\n  if h : xs.size ≤ 2 then none\n  else xs[2]\n\n\nThere is also a pattern-matching version of if.\nIf the pattern matches, then it takes the first branch, binding the pattern variables.\nIf the pattern does not match, then it takes the second branch.\n\nPattern-Matching Conditionals\n\nIf a Bool-only conditional statement is ever needed, the bif variant can be used.\n\nBoolean-Only Conditional\n\n"},"/Tactic-Proofs/Reading-Proof-States/#proof-states":{"id":"/Tactic-Proofs/Reading-Proof-States/#proof-states","header":"13.2. Reading Proof States","context":"Lean Reference\u0009Tactic Proofs","contents":"The goals in a proof state are displayed in order, with the main goal on top.\nGoals may be either named or anonymous.\nNamed goals are indicated with case at the top (called a case label), while anonymous goals have no such indicator.\nTactics assign goal names, typically on the basis of constructor names, parameter names, structure field names, or the nature of the reasoning step implemented by the tactic.\n\nNamed goalsThis proof state contains four goals, all of which are named.\nThis is part of a proof that the Monad Option instance is lawful (that is, to provide the LawfulMonad Option instance), and the case names (highlighted below) come from the names of the fields of LawfulMonad.case bind_pure_comp\nα β : Type ?u.2428\nf : α → β\nx : Option α\n⊢ (do\n      let a ← x\n      pure (f a)) =\n    f <$> x\n\ncase bind_map\nα β : Type ?u.2428\nf : Option (α → β)\nx : Option α\n⊢ (do\n      let x_1 ← f\n      x_1 <$> x) =\n    f <*> x\n\ncase pure_bind\nα β : Type ?u.2428\nx : α\nf : α → Option β\n⊢ pure x >>= f = f x\n\ncase bind_assoc\nα β γ : Type ?u.2428\nx : Option α\nf : α → Option β\ng : β → Option γ\n⊢ x >>= f >>= g = x >>= fun x => f x >>= g\n\nAnonymous GoalsThis proof state contains a single anonymous goal.n k : Nat\n⊢ n + k = k + n\n\nThe case and case' tactics can be used to select a new main goal using the desired goal's name.\nWhen names are assigned in the context of a goal which itself has a name, the new goals' names are appended to the main goal's name with a dot ('.', Unicode FULL STOP (0x2e)) between them.\n\nHierarchical Goal NamesIn the course of an attempt to prove ∀ (n k : Nat), n + k = k + n, this proof state can occur:case zero\nk : Nat\n⊢ 0 + k = k + 0\n\ncase succ\nk n✝ : Nat\na✝ : n✝ + k = k + n✝\n⊢ n✝ + 1 + k = k + (n✝ + 1)\nAfter induction k, the two new cases' names have zero as a prefix, because they were created in a goal named zero:case zero.zero\n⊢ 0 + 0 = 0 + 0\n\ncase zero.succ\nn✝ : Nat\na✝ : 0 + n✝ = n✝ + 0\n⊢ 0 + (n✝ + 1) = n✝ + 1 + 0\n\ncase succ\nk n✝ : Nat\na✝ : n✝ + k = k + n✝\n⊢ n✝ + 1 + k = k + (n✝ + 1)\n\n\nEach goal consists of a sequence of assumptions and a desired conclusion.\nEach assumption has a name and a type; the conclusion is a type.\nAssumptions are either arbitrary elements of some type or statements that are presumed true.\n\nAssumption Names and ConclusionThis goal has four assumptions:case cons\nα : Type ?u.4507\nx : α\nxs : List α\nih : xs ++ [] = xs\n⊢ x :: xs ++ [] = x :: xsThey are:* α, an arbitrary type* x, an arbitrary α* xs, an arbitrary List α* ih, an induction hypothesis that asserts that appending the empty list to xs is equal to xs.The conclusion is the statement that prepending x to both sides of the equality in the induction hypothesis results in equal lists.\n\nSome assumptions are inaccessible,   which means that they cannot be referred to explicitly by name.\nInaccessible assumptions occur when an assumption is created without a specified name or when the assumption's name is shadowed by a later assumption.\nInaccessible assumptions should be regarded as anonymous; they are presented as if they had names because they may be referred to in later assumptions or in the conclusion, and displaying a name allows these references to be distinguished from one another.\nIn particular, inaccessible assumptions are presented with daggers (†) after their names.\n\nAccessible Assumption NamesIn this proof state, all assumptions are accessible.case bind_pure_comp\nα β : Type ?u.5456\nf : α → β\nx : Option α\n⊢ (do\n      let a ← x\n      pure (f a)) =\n    f <$> x\n\nInaccessible Assumption NamesIn this proof state, only the first and third assumptions are accessible.\nThe second and fourth are inaccessible, and their names include a dagger to indicate that they cannot be referenced.case bind_pure_comp\nα β✝ : Type ?u.5802\nf : α → β✝\nx✝ : Option α\n⊢ (do\n      let a ← x✝\n      pure (f a)) =\n    f <$> x✝\n\nInaccessible assumptions can still be used.\nTactics such as assumption or simp can scan the entire list of assumptions, finding one that is useful, and contradiction can eliminate the current goal by finding an impossible assumption without naming it.\nOther tactics, such as rename_i and next, can be used to name inaccessible assumptions, making them accessible.\nAdditionally, assumptions can be referred to by their type, by writing the type in single guillemets.\n\nAssumptions by TypeSingle guillemets around a term represent a reference to some term in scope with that type.This can be used to refer to local lemmas by their theorem statement rather than by name, or to refer to assumptions regardless of whether they have explicit names.\n\nAssumptions by TypeIn the following proof, cases is repeatedly used to analyze a number.\nAt the beginning of the proof, the number is named x, but cases generates an inaccessible name for subsequent numbers.\nRather than providing names, the proof takes advantage of the fact that there is a single assumption of type Nat at any given time and uses ‹Nat› to refer to it.\nAfter the iteration, there is an assumption that n + 3 < 3, which contradiction can use to remove the goal from consideration.example : x < 3 → x ∈ [0, 1, 2] := by\n  intros\n  iterate 3\n    cases ‹Nat›\n    . decide\n  contradiction\n\n\nAssumptions by Type, Outside ProofsSingle-guillemet syntax also works outside of proofs:#eval\n  let x := 1\n  let y := 2\n  ‹Nat›\n2\nThis is generally not a good idea for non-propositions, however—when it matters which element of a type is selected, it's better to select it explicitly.\n\n\n\n\n\n"}});