window.docContents[175].resolve({"/The-Type-System/Functions/#The-Lean-Language-Reference--The-Type-System--Functions--Function-Abstractions":{"id":"/The-Type-System/Functions/#The-Lean-Language-Reference--The-Type-System--Functions--Function-Abstractions","header":"4.1.1. Function Abstractions","context":"Lean Reference\u0009Type System\u0009Functions","contents":"In Lean's type theory, functions are created using function abstractions that bind a variable.\nIn various communities, function abstractions are also known as lambdas, due to Alonzo Church's notation for them, or anonymous functions because they don't need to be defined with a name in the global environment.\nWhen the function is applied, the result is found by β-reduction: substituting the argument for the bound variable.\nIn compiled code, this happens strictly: the argument must already be a value.\nWhen type checking, there are no such restrictions; the equational theory of definitional equality allows β-reduction with any term.\n\nIn Lean's term language, function abstractions may take multiple parameters or use pattern matching.\nThese features are translated to simpler operations in the core language, where all functions abstractions take exactly one parameter.\nNot all functions originate from abstractions: type constructors, constructors, and recursors may have function types, but they cannot be defined using function abstractions alone.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--External-Libraries":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--External-Libraries","header":"22.1.3.2.4.3. External Libraries","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","contents":"Because external libraries may be written in any language and require arbitrary build steps, they are defined as programs written in the FetchM monad that produce a Job.\nExternal library targets should produce a build job that carries out the build and then returns the location of the resulting static library.\nFor the external library to link properly when precompileModules is on, the static library produced by an extern_lib target must follow the platform's naming conventions for libraries (i.e., be named foo.a on Windows or libfoo.a on Unix-like systems).\nThe utility function Lake.nameToStaticLib converts a library name into its proper file name for current platform.\n\nExternal Library TargetsDefine a new external library target for the package. Has one form:extern_lib «target-name» (pkg : NPackage _package.name) :=\n  /- build term of type `FetchM (Job FilePath)` -/\nThe pkg parameter (and its type specifier) is optional.\nIt is of type NPackage _package.name to provably demonstrate the package\nprovided is the package in which the target is defined.The term should build the external library's static library.\n\n"},"/Basic-Types/Natural-Numbers/#nat-api-predicates":{"id":"/Basic-Types/Natural-Numbers/#nat-api-predicates","header":"19.1.4.5.3. Predicates","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Comparisons","contents":"Non-strict, or weak, inequality of natural numbers, usually accessed via the ≤ operator.Non-strict inequality is reflexive: n ≤ nIf n ≤ m, then n ≤ m + 1.\n\nStrict inequality of natural numbers, usually accessed via the < operator.It is defined as n < m = n + 1 ≤ m.\n\n"},"/Basic-Types/Arrays/#subarray":{"id":"/Basic-Types/Arrays/#subarray","header":"19.16.5. Sub-Arrays","context":"Lean Reference\u0009Basic Types\u0009Arrays","contents":"A region of some underlying array.A subarray contains an array together with the start and end indices of a region of interest.\nSubarrays can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to start and strictly less than stop.\n\nAllocates a new array that contains the contents of the subarray.\n\nThe empty subarray.This empty subarray is backed by an empty array.\n\n\n\n\n\n\n\n\n\n\n\n"}});