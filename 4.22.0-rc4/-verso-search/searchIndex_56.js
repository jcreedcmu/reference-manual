window.docContents[56].resolve({"/The-Simplifier/Simp-Normal-Forms/#simp-normal-forms":{"id":"/The-Simplifier/Simp-Normal-Forms/#simp-normal-forms","header":"16.4. Simp Normal Forms","context":"Lean Reference\u0009The Simplifier","contents":"The default simp set contains all the theorems and simplification procedures marked with the simp attribute.\nThe simp normal form of an expression is the result of applying the default simp set via the simp tactic until no more rules can be applied.\nWhen an expression is in simp normal form, it is as reduced as possible according to the default simp set, often making it easier to work with in proofs.\n\nThe simp tactic does not guarantee confluence, which means that the simp normal form of an expression may depend on the order in which the elements of the default simp set are applied.\nThe order in which the rules are applied can be changed by assigning priorities when setting the simp attribute.\n\nWhen designing a Lean library, it's important to think about what the appropriate simp normal form for the various combinations of the library's operators is.\nThis can serve as a guide when selecting which rules the library should add to the default simp set.\nIn particular, the right-hand side of simp lemmas should be in simp normal form; this helps ensure that simplification terminates.\nAdditionally, each concept in the library should be expressed through one simp normal form, even if there are multiple equivalent ways to state it.\nIf a concept is stated in two different ways in different simp lemmas, then some desired simplifications may not occur because the simplifier does not connect them.\n\nEven though simplification doesn't need to be confluent, striving for confluence is helpful because it makes the library more predictable and tends to reveal missing or poorly chosen simp lemmas.\nThe default simp set is as much a part of a library's interface as the type signatures of the constants that it exports.\n\nLibraries should not add rules to the default simp set that don't mention at least one constant defined in the library.\nOtherwise, importing a library could change the behavior of simp for some unrelated library.\nIf a library relies on additional simplification rules for definitions or declarations from other libraries, please create a custom simp set and either instruct users to use it or provide a dedicated tactic.\n\n"},"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Low-Level-File-API":{"id":"/IO/Files___-File-Handles___-and-Streams/#The-Lean-Language-Reference--IO--Files___-File-Handles___-and-Streams--Low-Level-File-API","header":"15.5.1. Low-Level File API","context":"Lean Reference\u0009IO\u0009Files, File Handles, and Streams","contents":"At the lowest level, files are explicitly opened using Handle.mk.\nWhen the last reference to the handle object is dropped, the file is closed.\nThere is no explicit way to close a file handle other than by ensuring that there are no references to it.\n\nA reference to an opened file.File handles wrap the underlying operating system's file descriptors. There is no explicit operation\nto close a file: when the last reference to a file handle is dropped, the file is closed\nautomatically.Handles have an associated read/write cursor that determines the where reads and writes occur in the\nfile.\n\nOpens the file at fn with the given mode.An exception is thrown if the file cannot be opened.\n\nWhether a file should be opened for reading, writing, creation and writing, or appending.At the operating system level, this translates to the mode of a file handle (i.e., a set of open\nflags and an fdopen mode).None of the modes represented by this datatype translate line endings (i.e. O_BINARY on Windows).\nFurthermore, they are not inherited across process creation (i.e. O_NOINHERIT on Windows and\nO_CLOEXEC elsewhere).Operating System Specifics:* Windows:\n_open,\n_fdopen* Linux: open, fdopenThe file should be opened for reading.The read/write cursor is positioned at the beginning of the file. It is an error if the file does\nnot exist.* open flags: O_RDONLY* fdopen mode: rThe file should be opened for writing.If the file already exists, it is truncated to zero length. Otherwise, a new file is created. The\nread/write cursor is positioned at the beginning of the file.* open flags: O_WRONLY | O_CREAT | O_TRUNC* fdopen mode: wA new file should be created for writing.It is an error if the file already exists. A new file is created, with the read/write cursor\npositioned at the start.* open flags: O_WRONLY | O_CREAT | O_TRUNC | O_EXCL* fdopen mode: wThe file should be opened for both reading and writing.It is an error if the file does not already exist. The read/write cursor is positioned at the\nstart of the file.* open flags: O_RDWR* fdopen mode: r+The file should be opened for writing.If the file does not already exist, it is created. If the file already exists, it is opened, and\nthe read/write cursor is positioned at the end of the file.* open flags: O_WRONLY | O_CREAT | O_APPEND* fdopen mode: a\n\nReads up to the given number of bytes from the handle. If the returned array is empty, an\nend-of-file marker (EOF) has been reached.Encountering an EOF does not close a handle. Subsequent reads may block and return more data.\n\nReads the entire remaining contents of the file handle as a UTF-8-encoded string. An exception is\nthrown if the contents are not valid UTF-8.The underlying file is not automatically closed, and subsequent reads from the handle may block\nand/or return data.\n\nReads the entire remaining contents of the file handle until an end-of-file marker (EOF) is\nencountered.The underlying file is not automatically closed upon encountering an EOF, and subsequent reads from\nthe handle may block and/or return data.\n\nReads the entire remaining contents of the file handle until an end-of-file marker (EOF) is\nencountered.The underlying file is not automatically closed upon encountering an EOF, and subsequent reads from\nthe handle may block and/or return data.\n\nReads UTF-8-encoded text up to and including the next line break from the handle. If the returned\nstring is empty, an end-of-file marker (EOF) has been reached.Encountering an EOF does not close a handle. Subsequent reads may block and return more data.\n\nWrites the provided bytes to the the handle.Writing to a handle is typically buffered, and may not immediately modify the file on disk. Use\nIO.FS.Handle.flush to write changes to buffers to the associated device.\n\nWrites the provided string to the file handle using the UTF-8 encoding.Writing to a handle is typically buffered, and may not immediately modify the file on disk. Use\nIO.FS.Handle.flush to write changes to buffers to the associated device.\n\nWrites the contents of the string to the handle, followed by a newline. Uses UTF-8.\n\nFlushes the output buffer associated with the handle, writing any unwritten data to the associated\noutput device.\n\nRewinds the read/write cursor to the beginning of the handle's file.\n\nTruncates the handle to its read/write cursor.This operation does not automatically flush output buffers, so the contents of the output device may\nnot reflect the change immediately. This does not usually lead to problems because the read/write\ncursor includes buffered writes. However, buffered writes followed by IO.FS.Handle.rewind, then\nIO.FS.Handle.truncate, and then closing the file may lead to a non-empty file. If unsure, call\nIO.FS.Handle.flush before truncating.\n\nReturns true if a handle refers to a Windows console or a Unix terminal.\n\nAcquires an exclusive or shared lock on the handle. Blocks to wait for the lock if necessary.Acquiring a exclusive lock while already possessing a shared lock will not reliably succeed: it\nworks on Unix-like systems but not on Windows.\n\nTries to acquire an exclusive or shared lock on the handle and returns true if successful. Will\nnot block if the lock cannot be acquired, but instead returns false.Acquiring a exclusive lock while already possessing a shared lock will not reliably succeed: it\nworks on Unix-like systems but not on Windows.\n\nReleases any previously-acquired lock on the handle. Succeeds even if no lock has been acquired.\n\nOne File, Multiple HandlesThis program has two handles to the same file.\nBecause file I/O may be buffered independently for each handle, Handle.flush should be called when the buffers need to be synchronized with the file's actual contents.\nHere, the two handles proceed in lock-step through the file, with one of them a single byte ahead of the other.\nThe first handle is used to count the number of occurrences of 'A', while the second is used to replace each 'A' with '!'.\nThe second handle is opened in readWrite mode rather than write mode because opening an existing file in write mode replaces it with an empty file.\nIn this case, the buffers don't need to be flushed during execution because modifications occur only to parts of the file that will not be read again, but the write handle should be flushed after the loop has completed.open IO.FS (Handle)\n\ndef main : IO Unit := do\n  IO.println s!\"Starting contents: '{(← IO.FS.readFile \"data\").trim}'\"\n\n  let h ← Handle.mk \"data\" .read\n  let h' ← Handle.mk \"data\" .readWrite\n  h'.rewind\n\n  let mut count := 0\n  let mut buf : ByteArray ← h.read 1\n  while ok : buf.size = 1 do\n    if Char.ofUInt8 buf[0] == 'A' then\n      count := count + 1\n      h'.write (ByteArray.empty.push '!'.toUInt8)\n    else\n      h'.write buf\n    buf ← h.read 1\n\n  h'.flush\n\n  IO.println s!\"Count: {count}\"\n  IO.println s!\"Contents: '{(← IO.FS.readFile \"data\").trim}'\"\nWhen run on this file:AABAABCDAB\nthe program outputs:Starting contents: 'AABAABCDAB'\nCount: 5\nContents: '!!B!!BCD!B'\nAfterwards, the file contains:!!B!!BCD!B\n\n\n"},"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Run-Time-Representation":{"id":"/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans--Run-Time-Representation","header":"19.11.1. Run-Time Representation","context":"Lean Reference\u0009Basic Types\u0009Booleans","contents":"Because Bool is an enum inductive type, it is represented by a single byte in compiled code.\n\n"}});