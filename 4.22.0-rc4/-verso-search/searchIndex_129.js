window.docContents[129].resolve({"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--Other-solutions":{"id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--Other-solutions","header":"17.12.2.3. Other solutions","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if-then-else normalization","contents":"At this point, it's worth pausing and doing at least one of the following:\n\n\n\n* Try to prove this yourself! It's quite challenging for a beginner!\n  You can have a go\n  in the Live Lean editor without any installation.* Read Chris Hughes's solution,\n  which is included in the Mathlib Archive.\n  This solution makes good use of Aesop, but is not ideal because1. It defines the solution using a subtype, simultaneously giving the construction and proving properties about it.\n     We think it's better stylistically to keep these separate.2. Even with Aesop automation, there's still about 15 lines of manual proof work before we can hand off to Aesop.* Read Wojciech Nawrocki's solution.\n  This one uses less automation, at about 300 lines of proof work.\n\n"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-unfolding":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-unfolding","header":"13.3.6.1. Controlling Unfolding","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Namespace and Option Management","contents":"By default, only definitions marked reducible are unfolded, except when checking definitional equality.\nThese operators allow this default to be adjusted for some part of a tactic script.\n\nwith_reducible_and_instances tacs executes tacs using the .instances transparency setting.\nIn this setting only definitions tagged as [reducible] or type class instances are unfolded.\n\nwith_reducible tacs executes tacs using the reducible transparency setting.\nIn this setting only definitions tagged as [reducible] are unfolded.\n\nwith_unfolding_all tacs executes tacs using the .all transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n\n"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-assumptions":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-assumptions","header":"13.3.2.1. Accessing Assumptions","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Names and Hygiene","contents":"Many tactics provide a means of specifying names for the assumptions that they introduce.\nFor example, intro and intros take assumption names as arguments, and induction's with-form allows simultaneous case selection, assumption naming, and focusing.\nWhen an assumption does not have a name, one can be assigned using next, case, or rename_i.\n\nrename_i x_1 ... x_n renames the last n inaccessible names using the given names.\n\n"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads--Implementations":{"id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--Combined-Error-and-State-Monads--Implementations","header":"14.5.8.2. Implementations","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009Combined Error and State Monads","contents":"These functions are typically not called directly, but rather are accessed through their corresponding type classes.\n\nTransforms the value returned from an EStateM ε σ action using a function.\n\nReturns a value without modifying the state or throwing an exception.\n\nSequences two EStateM ε σ actions, passing the returned value from the first into the second.\n\nFailure handling that does not depend on specific exception values.The Backtrackable δ σ instance is used to save a snapshot of part of the state prior to running\nx₁. If an exception is caught, the state is updated with the saved snapshot, rolling back part of\nthe state. If no instance of Backtrackable is provided, a fallback instance in which δ is Unit\nis used, and no information is rolled back.\n\nAlternative orElse operator that allows callers to select which exception should be used when both\noperations fail. The default is to use the first exception since the standard orElse uses the\nsecond.\n\nSequences two EStateM ε σ actions, running x before y. The first action's return value is\nignored.\n\nHandles exceptions thrown in the combined error and state monad.The Backtrackable δ σ instance is used to save a snapshot of part of the state prior to running\nx. If an exception is caught, the state is updated with the saved snapshot, rolling back part of\nthe state. If no instance of Backtrackable is provided, a fallback instance in which δ is Unit\nis used, and no information is rolled back.\n\nThrows an exception of type ε to the nearest enclosing handler.\n\nRetrieves the current value of the monad's mutable state.\n\nReplaces the current value of the mutable state with a new one.\n\nApplies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to do let (a, s) := f (← get); set s; pure a. However, using modifyGet may\nlead to higher performance because it doesn't add a new reference to the state value. Additional\nreferences can inhibit in-place updates of data.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Options":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Command-Line-Interface--Options","header":"22.1.2.2. Options","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","contents":"Lake's command-line interface provides a number of global options as well as subcommands that perform important tasks.\nSingle-character flags cannot be combined; -HR is not equivalent to -H -R.\n\n --version\n\nLake outputs its version and exits without doing anything else.\n\n --help or -h\n\nLake outputs its version along with usage information and exits without doing anything else.\n  Subcommands may be used with --help, in which case usage information for the subcommand is output.\n\n --dir or -d\n\nUse the provided directory as location of the package instead of the current working directory.\n  This is not always equivalent to changing to the directory first, because the version of lake indicated by the current directory's toolchain file will be used, rather than that of DIR.\n\n --file or -f\n\nUse the specified package configuration file instead of the default.\n\n --old\n\nOnly rebuild modified modules, ignoring transitive dependencies.\n  Modules that import the modified module will not be rebuilt.\n  In order to accomplish this, file modification times are used instead of hashes to determine whether a module has changed.\n\n --rehash or -H\n\nIgnored cached file hashes, recomputing them.\n  Lake uses hashes of dependencies to determine whether to rebuild an artifact.\n  These hashes are cached on disk whenever a module is built.\n  To save time during builds, these cached hashes are used instead of recomputing each hash unless --rehash is specified.\n\n --update\n\nUpdate dependencies after the package configuration is loaded but prior to performing other tasks, such as a build.\n  This is equivalent to running lake update before the selected command, but it may be faster due to not having to load the configuration twice.\n\n --packages\n\nUse the contents of FILE to specify the versions of some or all dependencies instead of the manifest.\n  FILE should be a syntactically valid manifest, but it does not need to be complete.\n\n  --reconfigure or -R\n\nNormally, the package configuration file is elaborated when a package is first configured, with the result cached to a .olean file that is used for future invocations until the package configuration\n  Providing this flag causes the configuration file to be re-elaborated.\n\n --keep-toolchain\n\nBy default, Lake attempts to update the local workspace's toolchain file.\n  Providing this flag disables automatic toolchain updates.\n\n --no-build\n\nLake exits immediately if a build target is not up-to-date, returning a non-zero exit code.\n\n --no-cache\n\nInstead of using available cloud build caches, build all packages locally.\n  Build caches are not downloaded.\n\n --try-cache\n\nattempt to download build caches for supported packages\n\n\n\n"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Termination-Helpers":{"id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Termination-Helpers","header":"19.15.3.15. Termination Helpers","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","contents":"“Attaches” the proof that the elements of l are in fact elements of l, producing a new list with\nthe same elements but in the subtype { x // x ∈ l }.O(1).This function is primarily used to allow definitions by well-founded\nrecursion that use higher-order functions (such as\nList.map) to prove that an value taken from a list is smaller than the list. This allows the\nwell-founded recursion mechanism to prove that the function terminates.\n\n“Attaches” individual proofs to a list of values that satisfy a predicate P, returning a list of\nelements in the corresponding subtype { x // P x }.O(1).\n\nMaps a list of terms in a subtype to the corresponding terms in the type by forgetting that they\nsatisfy the predicate.This is the inverse of List.attachWith and a synonym for l.map (·.val).Mostly this should not be needed by users. It is introduced as an intermediate step by lemmas such\nas map_subtype, and is ideally subsequently simplified away by unattach_attach.This function is usually inserted automatically by Lean as an intermediate step while proving\ntermination. It is rarely used explicitly in code. It is introduced as an intermediate step during\nthe elaboration of definitions by well-founded\nrecursion. If this function is encountered in a proof\nstate, the right approach is usually the tactic simp [List.unattach, -List.map_subtype].\n\nMaps a partially defined function (defined on those terms of α that satisfy a predicate P) over\na list l : List α, given a proof that every element of l in fact satisfies P.O(|l|). List.pmap, named for “partial map,” is the equivalent of List.map for such partial\nfunctions.\n\n"}});