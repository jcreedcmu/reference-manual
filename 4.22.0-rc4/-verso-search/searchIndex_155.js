window.docContents[155].resolve({"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts":{"id":"/Functors___-Monads-and--do--Notation/Lifting-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Lifting-Monads--Reversing-Lifts","header":"14.2.1. Reversing Lifts","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Lifting Monads","contents":"\n\nMonad lifting is not always sufficient to combine monads.\nMany operations provided by monads are higher order, taking an action in the same monad as a parameter.\nEven if these operations are lifted to some more powerful monad, their arguments are still restricted to the original monad.\n\nThere are two type classes that support this kind of “reverse lifting”: MonadFunctor and MonadControl.\nAn instance of MonadFunctor m n explains how to interpret a fully-polymorphic function in m into n.\nThis polymorphic function must work for all types α: it has type {α : Type u} → m α → m α.\nSuch a function can be thought of as one that may have effects, but can't do so based on specific values that are provided.\nAn instance of MonadControl m n explains how to interpret an arbitrary action from m into n, while at the same time providing a “reverse interpreter” that allows the m action to run n actions.\n\n\n\n\n\n"},"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering":{"id":"/Basic-Types/Linked-Lists/#The-Lean-Language-Reference--Basic-Types--Linked-Lists--API-Reference--Filtering","header":"19.15.3.12. Filtering","context":"Lean Reference\u0009Basic Types\u0009Linked Lists\u0009API Reference","contents":"Returns the list of elements in l for which p returns true.O(|l|).Examples:* [1, 2, 5, 2, 7, 7].filter (· > 2) = [5, 7, 7]* [1, 2, 5, 2, 7, 7].filter (fun _ => false) = []* [1, 2, 5, 2, 7, 7].filter (fun _ => true) = [1, 2, 5, 2, 7, 7]\n\nReturns the list of elements in l for which p returns true.O(|l|). This is a tail-recursive version of List.filter, used at runtime.Examples:* [1, 2, 5, 2, 7, 7].filterTR (· > 2)  = [5, 7, 7]* [1, 2, 5, 2, 7, 7].filterTR (fun _ => false) = []* [1, 2, 5, 2, 7, 7].filterTR (fun _ => true) = * [1, 2, 5, 2, 7, 7]\n\nApplies the monadic predicate p to every element in the list, in order from left to right, and\nreturns the list of elements for which p returns true.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterM fun x => do\n  IO.println s!\"Checking {x}\"\n  return x < 3\nChecking 1\nChecking 2\nChecking 5\nChecking 2\nChecking 7\nChecking 7\n[1, 2, 2]\n\n\nApplies the monadic predicate p on every element in the list in reverse order, from right to left,\nand returns those elements for which p returns true. The elements of the returned list are in\nthe same order as in the input list.Example:#eval [1, 2, 5, 2, 7, 7].filterRevM fun x => do\n  IO.println s!\"Checking {x}\"\n  return x < 3\nChecking 7\nChecking 7\nChecking 2\nChecking 5\nChecking 2\nChecking 1\n[1, 2, 2]\n\n\nApplies a function that returns an Option to each element of a list, collecting the non-none\nvalues.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterMap fun x =>\n  if x > 2 then some (2 * x) else none\n[10, 14, 14]\n\n\nApplies a function that returns an Option to each element of a list, collecting the non-none\nvalues.O(|l|). This is a tail-recursive version of List.filterMap, used at runtime.Example:#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =>\n  if x > 2 then some (2 * x) else none\n[10, 14, 14]\n\n\nApplies a monadic function that returns an Option to each element of a list, collecting the\nnon-none values.O(|l|).Example:#eval [1, 2, 5, 2, 7, 7].filterMapM fun x => do\n  IO.println s!\"Examining {x}\"\n  if x > 2 then return some (2 * x)\n  else return none\nExamining 1\nExamining 2\nExamining 5\nExamining 2\nExamining 7\nExamining 7\n[10, 14, 14]\n\n\n\n\n"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Int":{"id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--API-Reference--Conversions--To-and-From--Int","header":"19.4.4.3.1. To and From  Int","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers\u0009API Reference\u0009Conversions","contents":"Converts a word-sized signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts an 8-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 16-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 32-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts a 64-bit signed integer to an arbitrary-precision integer that denotes the same number.This function is overridden at runtime with an efficient implementation.\n\nConverts an arbitrary-precision integer to a word-sized signed integer, wrapping around on over- or\nunderflow.This function is overridden at runtime with an efficient implementation.\n\nConverts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int8.ofInt 48 = 48* Int8.ofInt (-115) = -115* Int8.ofInt (-129) = 127* Int8.ofInt (128) = -128\n\nConverts an arbitrary-precision integer to a 16-bit signed integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int16.ofInt 48 = 48* Int16.ofInt (-129) = -129* Int16.ofInt (128) = 128* Int16.ofInt 70000 = 4464* Int16.ofInt (-40000) = 25536\n\nConverts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int32.ofInt 48 = 48* Int32.ofInt (-129) = -129* Int32.ofInt 70000 = 70000* Int32.ofInt (-40000) = -40000* Int32.ofInt 2147483648 = -2147483648* Int32.ofInt (-2147483649) = 2147483647\n\nConverts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow.This function is overridden at runtime with an efficient implementation.Examples:* Int64.ofInt 48 = 48* Int64.ofInt (-40_000) = -40_000* Int64.ofInt 2_147_483_648 = 2_147_483_648* Int64.ofInt (-2_147_483_649) = -2_147_483_649* Int64.ofInt 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808* Int64.ofInt (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807\n\nConstructs an ISize from an Int, clamping if the value is too small or too large.\n\nConstructs an Int8 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int16 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int32 from an Int, clamping if the value is too small or too large.\n\nConstructs an Int64 from an Int, clamping if the value is too small or too large.\n\nConstructs an ISize from an Int that is known to be in bounds.\n\nConstructs an Int8 from an Int that is known to be in bounds.\n\nConstructs an Int16 from an Int that is known to be in bounds.\n\nConstructs an Int32 from an Int that is known to be in bounds.\n\nConstructs an Int64 from an Int that is known to be in bounds.\n\n"}});