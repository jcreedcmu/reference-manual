window.docContents[51].resolve({"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--The-formal-statement":{"id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--The-formal-statement","header":"17.12.2.2. The formal statement","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if-then-else normalization","contents":"\n\nTo formalize the statement in Lean, we use an inductive type IfExpr:\n\n/-- An if-expression is either boolean literal,\na numbered variable, or an if-then-else expression\nwhere each subexpression is an if-expression. -/\ninductive IfExpr\n  | lit : Bool → IfExpr\n  | var : Nat → IfExpr\n  | ite : IfExpr → IfExpr → IfExpr → IfExpr\nderiving DecidableEq\n\n\nand define some inductive predicates and an eval function, so we can state the four desired properties:\n\nnamespace IfExpr\n\n/--\nAn if-expression has a \"nested if\" if it contains\nan if-then-else where the \"if\" is itself an if-then-else.\n-/\ndef hasNestedIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (ite _ _ _) _ _ => true\n  | ite _ t e => t.hasNestedIf || e.hasNestedIf\n\n/--\nAn if-expression has a \"constant if\" if it contains\nan if-then-else where the \"if\" is itself a literal.\n-/\ndef hasConstantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (lit _) _ _ => true\n  | ite i t e =>\n    i.hasConstantIf || t.hasConstantIf || e.hasConstantIf\n\n/--\nAn if-expression has a \"redundant if\" if\nit contains an if-then-else where\nthe \"then\" and \"else\" clauses are identical.\n-/\ndef hasRedundantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite i t e => t == e || i.hasRedundantIf ||\n      t.hasRedundantIf || e.hasRedundantIf\n\n/--\nAll the variables appearing in an if-expressions,\nread left to right, without removing duplicates.\n-/\ndef vars : IfExpr → List Nat\n  | lit _ => []\n  | var i => [i]\n  | ite i t e => i.vars ++ t.vars ++ e.vars\n\n/--\nA helper function to specify that two lists are disjoint.\n-/\ndef _root_.List.disjoint {α} [DecidableEq α] :\n    List α → List α → Bool\n  | [], _ => true\n  | x::xs, ys => x ∉ ys && xs.disjoint ys\n\n/--\nAn if expression evaluates each variable at most once if\nfor each if-then-else the variables in the \"if\" clause\nare disjoint from the variables in the \"then\" clause\nand the variables in the \"if\" clause\nare disjoint from the variables in the \"else\" clause.\n-/\ndef disjoint : IfExpr → Bool\n  | lit _ => true\n  | var _ => true\n  | ite i t e =>\n      i.vars.disjoint t.vars && i.vars.disjoint e.vars &&\n        i.disjoint && t.disjoint && e.disjoint\n\n/--\nAn if expression is \"normalized\" if it has\nno nested, constant, or redundant ifs,\nand it evaluates each variable at most once.\n-/\ndef normalized (e : IfExpr) : Bool :=\n  !e.hasNestedIf && !e.hasConstantIf &&\n    !e.hasRedundantIf && e.disjoint\n\n/--\nThe evaluation of an if expression\nat some assignment of variables.\n-/\ndef eval (f : Nat → Bool) : IfExpr → Bool\n  | lit b => b\n  | var i => f i\n  | ite i t e => bif i.eval f then t.eval f else e.eval f\n\nend IfExpr\n\n\nUsing these we can state the problem. The challenge is to inhabit the following type (and to do so nicely!):\n\n\n\ndef IfNormalization : Type :=\n  { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }\n\n\n"},"/Basic-Types/Maps-and-Sets/#HashMap":{"id":"/Basic-Types/Maps-and-Sets/#HashMap","header":"19.17.2. Hash Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.HashMap.\n\nHash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.Data.HashMap.Raw and\nStd.Data.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nHashMap over HashMap.Raw.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.Data.DHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing":{"id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing","header":"19.16.5.2. Resizing","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","contents":"Removes the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nKeeps only the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nShrinks the subarray by incrementing its starting index if possible, returning it unchanged if not.Examples:* #[1,2,3].toSubarray.popFront.toArray = #[2, 3]* #[1,2,3].toSubarray.popFront.popFront.toArray = #[3]* #[1,2,3].toSubarray.popFront.popFront.popFront.toArray = #[]* #[1,2,3].toSubarray.popFront.popFront.popFront.popFront.toArray = #[]\n\nSplits a subarray into two parts, the first of which contains the first i elements and the second\nof which contains the remainder.\n\n"}});