window.docContents[214].resolve({"/The-Type-System/Quotients/#quotient-alternatives":{"id":"/The-Type-System/Quotients/#quotient-alternatives","header":"4.5.1. Alternatives to Quotient Types","context":"Lean Reference\u0009Type System\u0009Quotients","contents":"While Quotient is a convenient way to form quotients with reasonable computational properties, it is often possible to define quotients in other ways.\n\nIn general, a type Q is said to be the quotient of A by an equivalence relation \\sim if it respects the universal property of quotients: there is a function q:A\\to Q with the property that q(a)=q(b) if and only if a\\sim b for all a and b in A.\n\nQuotients formed with Quotient have this property up to propositional equality: elements of A that are related by \\sim are equal, so they cannot be distinguished.\nHowever, members of the same equivalence class are not necessarily definitionally equal in the quotient.\n\nQuotients may also be implemented by designating a single representative of each equivalence class in A itself, and then defining Q as pair of elements in A with proofs that they are such a canonical representative.\nTogether with a function that maps each a in A to its canonical representative, Q is a quotient of A.\nDue to proof irrelevance, representatives in Q of the same equivalence class are definitionally equal.\n\nSuch a manually implemented quotient Q can be easier to work with than Quotient.\nIn particular, because each equivalence class is represented by its single canonical representative, there's no need to prove that functions from the quotient respect the equivalence relation.\nIt can also have better computational properties due to the fact that the computations give normalized values (in contrast, elements of Quotient can be represented in multiple ways).\nFinally, because the manually implemented quotient is an inductive type, it can be used in contexts where other kinds of types cannot, such as when defining a nested inductive type.\nHowever, not all quotients can be manually implemented.\n\nManually Quotiented IntegersWhen implemented as pairs of Nats, each equivalence class according to the desired equality for integers has a canonical representative in which at least one of the Nats is zero.\nThis can be represented as a Lean structure:structure Z where\n  a : Nat\n  b : Nat\n  canonical : a = 0 ∨ b = 0\nDue to proof irrelevance, every value of this structure type that represents the same integer is already equal.\nConstructing a Z can be made more convenient with a wrapper that uses the fact that subtraction of natural numbers truncates at zero to automate the construction of the proof:def Z.mk' (n k : Nat) : Z where\n  a := n - k\n  b := k - n\n  canonical := by omega\nThis construction respects the equality demanded of integers:theorem Z_mk'_respects_eq :\n    (Z.mk' n k = Z.mk' n' k') ↔ (n + k' = n' + k) := by\n  simp [Z.mk']\n  omega\nTo use this type in examples, it's convenient to have Neg, OfNat, and ToString instances.\nThese instances make it easier to read or write examples.instance : Neg Z where\n  neg n := Z.mk' n.b n.a\n\ninstance : OfNat Z n where\n  ofNat := Z.mk' n 0\n\ninstance : ToString Z where\n  toString n :=\n    if n.a = 0 then\n      if n.b = 0 then \"0\"\n      else s!\"-{n.b}\"\n    else toString n.a\n#eval (5 : Z)\n5\n#eval (-5 : Z)\n-5\nAddition is addition of the underlying Nats:instance : Add Z where\n  add n k := Z.mk' (n.a + k.a) (n.b + k.b)\n#eval (-5 + 22: Z)\n17\nBecause each equivalence class is uniquely represented, there's no need to write a proof that these functions from Z respect the equivalence relation.\nHowever, in practice, the API for quotients should be implemented for manually-constructed quotients and proved to respect the universal property.\n\nBuilt-In Integers as QuotientsLean's built-in integer type Int satisfies the universal property of quotients, and can thus be thought of as a quotient of pairs of Nats.\nThe canonical representative of each equivalence class can be computed via comparison and subtraction:This toInt function is called Int.subNatNat in the standard library.def toInt (n k : Nat) : Int :=\n  if n < k then - (k - n : Nat)\n  else if n = k then 0\n  else (n - k : Nat)\nIt satisfies the universal property.\nTwo pairs of Nats are represent the same integer if and only if toInt computes the same Int for both pairs:theorem toInt_sound :\n    n + k' = k + n' ↔\n    toInt n k = toInt n' k' := by\n  simp only [toInt]\n  split <;> split <;> omega\n\n\n"},"/The--grind--tactic/Constraint___Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint___Propagation--Propagation___only-examples":{"id":"/The--grind--tactic/Constraint___Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint___Propagation--Propagation___only-examples","header":"17.6.1. Propagation‑only examples","context":"Lean Reference\u0009The  grind  tactic\u0009Constraint Propagation","contents":"These goals are closed purely by constraint propagation—no case splits, no theory solvers:\n\n-- Boolean connective: a && !a is always false.\nexample (a : Bool) : (a && !a) = false := by\n  grind\n\n-- Conditional (ite):\n-- once the condition is true, ite picks the 'then' branch.\nexample (c : Bool) (t e : Nat) (h : c = true) :\n    (if c then t else e) = t := by\n  grind\n\n-- Negation propagates truth downwards.\nexample (a : Bool) (h : (!a) = true) : a = false := by\n  grind\n\n\nThese snippets run instantly because the relevant propagators (propagateBoolAndUp, propagateIte, propagateBoolNotDown) fire as soon as the hypotheses are internalized.\n\nNote If you toggle set_option trace.grind.eqc true, grind will print a line every time two equivalence classes merge—handy for seeing propagation in action.\n\nImplementation tip  grind is still under active development. Until the API has stabilized we recommend refraining from custom elaborators or satellite solvers. If you really need a project‑local propagator, use the user‑facing grind_propagator command rather than builtin_grind_propagator (the latter is reserved for Lean’s own code). When adding new propagators keep them small and orthogonal—they should fire in ≤1 µs and either push one fact or close the goal. This keeps the propagation phase predictable and easy to debug.\n\nWe continuously expand and refine the rule set—expect the Info View to show increasingly rich True/False buckets over time. The full equivalence classes are displayed automatically only when grind fails, and only for the first subgoal it could not close—use this output to inspect missing facts and understand why the subgoal remains open.\n\n"},"/Functors___-Monads-and--do--Notation/Syntax/#do-notation":{"id":"/Functors___-Monads-and--do--Notation/Syntax/#do-notation","header":"14.3.2. do -Notation","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax","contents":"Monads are primarily used via do-notation, which is an embedded language for programming in an imperative style.\nIt provides familiar syntax for sequencing effectful operations, early return, local mutable variables, loops, and exception handling.\nAll of these features are translated to the operations of the Monad type class, with a few of them requiring addition instances of classes such as ForIn that specify iteration over containers.\nFor more details about the design of do-notation, please consult .\nA do term consists of the keyword do followed by a sequence of do items.\n\ndo-NotationThe items in a do may be separated by semicolons; otherwise, each should be on its own line and they should have equal indentation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Syntax":{"id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Syntax","header":"19.4.3. Syntax","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","contents":"All the fixed-width integer types have OfNat instances, which allow numerals to be used as literals, both in expression and in pattern contexts.\nThe signed types additionally have Neg instances, allowing negation to be applied.\n\nFixed-Width LiteralsLean allows both decimal and hexadecimal literals to be used for types with OfNat instances.\nIn this example, literal notation is used to define masks.structure Permissions where\n  readable : Bool\n  writable : Bool\n  executable : Bool\n\ndef Permissions.encode (p : Permissions) : UInt8 :=\n  let r := if p.readable then 0x01 else 0\n  let w := if p.writable then 0x02 else 0\n  let x := if p.executable then 0x04 else 0\n  r ||| w ||| x\n\ndef Permissions.decode (i : UInt8) : Permissions :=\n  ⟨i &&& 0x01 ≠ 0, i &&& 0x02 ≠ 0, i &&& 0x04 ≠ 0⟩\n\n\nLiterals that overflow their types' precision are interpreted modulus the precision.\nSigned types, are interpreted according to the underlying twos-complement representation.\n\nOverflowing Fixed-Width LiteralsThe following statements are all true:example : (255 : UInt8) = 255 := by rfl\nexample : (256 : UInt8) = 0   := by rfl\nexample : (257 : UInt8) = 1   := by rfl\n\nexample : (0x7f : Int8) = 127  := by rfl\nexample : (0x8f : Int8) = -113 := by rfl\nexample : (0xff : Int8) = -1   := by rfl\n\n\n"}});