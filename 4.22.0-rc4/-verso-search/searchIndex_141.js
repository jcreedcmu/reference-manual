window.docContents[141].resolve({"/The--grind--tactic/Constraint___Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint___Propagation":{"id":"/The--grind--tactic/Constraint___Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint___Propagation","header":"17.6. Constraint Propagation","context":"Lean Reference\u0009The  grind  tactic","contents":"Constraint propagation works on the True and False buckets of the white‑board.  Whenever a literal is added to one of those buckets, grind fires dozens of small forward rules to push its logical consequences:\n\n* Boolean connectives — e.g. if A is True, mark A ∨ B as True; if A ∧ B is True, mark both A and B as True; if A ∧ B is False, at least one of A, B becomes False.* Inductive datatypes — two different constructors (none vs some _) collapsing into the same class yields a contradiction; equal tuples yield equal components.* Projections and casts — from h : (x, y) = (x', y') we derive x = x' and y = y'; any term cast h a is merged with a immediately (using a heterogeneous equality) so both live in the same class.* Structural eta and definitional equalities — ⟨a, b⟩.1 propagates to a, etc.\n\nBelow is a representative slice of the propagators so you can see the style they follow.  Each follows the same skeleton: inspect the truth‑value of sub‑expressions, push equalities (pushEq) or truth‑values (pushEqTrue / pushEqFalse), and optionally close the goal if a contradiction (closeGoal) arises.  A few high‑signal examples:\n\n\n\n\n/-- Propagate equalities *upwards* for conjunctions. -/\nbuiltin_grind_propagator propagateAndUp ↑And := fun e => do\n  let_expr And a b := e | return ()\n  if (← isEqTrue a) then\n    -- a = True  ⇒  (a ∧ b) = b\n    pushEq e b <|\n      mkApp3 (mkConst ``Grind.and_eq_of_eq_true_left)\n        a b (← mkEqTrueProof a)\n  else if (← isEqTrue b) then\n    pushEq e a <|\n      mkApp3 (mkConst ``Grind.and_eq_of_eq_true_right)\n        a b (← mkEqTrueProof b)\n  else if (← isEqFalse a) then\n    pushEqFalse e <|\n      mkApp3 (mkConst ``Grind.and_eq_of_eq_false_left)\n        a b (← mkEqFalseProof a)\n  else if (← isEqFalse b) then\n    pushEqFalse e <|\n      mkApp3 (mkConst ``Grind.and_eq_of_eq_false_right)\n        a b (← mkEqFalseProof b)\n\n/--\nTruth flows *down* when the whole `And` is proven `True`.\n-/\nbuiltin_grind_propagator propagateAndDown ↓And :=\n  fun e => do\n  if (← isEqTrue e) then\n    let_expr And a b := e | return ()\n    let h ← mkEqTrueProof e\n    pushEqTrue a <| mkApp3\n      (mkConst ``Grind.eq_true_of_and_eq_true_left) a b h\n    pushEqTrue b <| mkApp3\n      (mkConst ``Grind.eq_true_of_and_eq_true_right) a b h\n\n\n\n\nOther frequently‑triggered propagators follow the same pattern:\n\n* Propagator* Handles* Notes\n* propagateOrUp / propagateOrDown* a ∨ b* True/False pushes for disjunctions\n* propagateNotUp / propagateNotDown* ¬ a* Links ¬ a with the Boolean of a\n* propagateEqUp / propagateEqDown* a = b* Bridges Booleans, detects constructor clash\n* propagateIte / propagateDIte* ite / dite* Replaces chosen branch once condition is fixed\n* propagateEtaStruct* structures tagged [grind ext]* Generates η‑expansion a = ⟨a.1, …⟩\n\n\n\nMany specialized variants for Bool mirror these rules exactly (e.g. propagateBoolAndUp).\n\n\n\n"},"/Interacting-with-Lean/#hash-print":{"id":"/Interacting-with-Lean/#hash-print","header":"3.5. Querying the Context","context":"Lean Reference\u0009Interacting with Lean","contents":"The #print family of commands are used to query Lean for information about definitions.\n\nPrinting DefinitionsPrints the definition of a constant.\n\nPrinting a definition with #print prints the definition as a term.\nTheorems that were proved using tactics may be very large when printed as terms.\n\nPrinting StringsAdds the string literal to Lean's message log.\n\nPrinting AxiomsLists all axioms that the constant transitively relies on.\n\nPrinting AxiomsThese two functions each swap the elements in a pair of bitvectors:def swap (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  (y, x)\n\ndef swap' (x y : BitVec 32) : BitVec 32 × BitVec 32 :=\n  let x := x ^^^ y\n  let y := x ^^^ y\n  let x := x ^^^ y\n  (x, y)\nThey can be proven equal using function extensionality, the simplifier, and bv_decide:theorem swap_eq_swap' : swap = swap' := by\n  funext x y\n  simp only [swap, swap', Prod.mk.injEq]\n  bv_decide\nThe resulting proof makes use of a number of axioms:#print axioms swap_eq_swap'\n'swap_eq_swap'' depends on axioms: [propext, Classical.choice, Lean.ofReduceBool, Quot.sound]\n\n\nPrinting EquationsThe command #print equations, which can be abbreviated #print eqns, displays the equational lemmas for a function.\n\nPrinting Equationsdef intersperse (x : α) : List α → List α\n  | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n  | xs => xs\n\n#print equations intersperse\nequations:\n@[defeq] theorem intersperse.eq_1.{u_1} : ∀ {α : Type u_1} (x y z : α) (zs : List α),\n  intersperse x (y :: z :: zs) = y :: x :: intersperse x (z :: zs)\ntheorem intersperse.eq_2.{u_1} : ∀ {α : Type u_1} (x : α) (x_1 : List α),\n  (∀ (y z : α) (zs : List α), x_1 = y :: z :: zs → False) → intersperse x x_1 = x_1\nIt does not print the defining equation, nor the unfolding equation:#check intersperse.eq_def\nintersperse.eq_def.{u_1} {α : Type u_1} (x : α) (x✝ : List α) :\n  intersperse x x✝ =\n    match x✝ with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n#check intersperse.eq_unfold\nintersperse.eq_unfold.{u_1} :\n  @intersperse = fun {α} x x_1 =>\n    match x_1 with\n    | y :: z :: zs => y :: x :: intersperse x (z :: zs)\n    | xs => xs\n\n\nScope Information#where gives a description of the state of the current scope scope.\nThis includes the current namespace, open namespaces, universe and variable commands,\nand options set with set_option.\n\nScope InformationThe #where command displays all the modifications made to the current section scope, both in the current scope and in the scopes in which it is nested.section\nopen Nat\n\nnamespace A\nvariable (n : Nat)\nnamespace B\n\nopen List\nset_option pp.funBinderTypes true\n\n#where\n\nend A.B\nend\nnamespace A.B\n\nopen Nat List\n\nvariable (n : Nat)\n\nset_option pp.funBinderTypes true\n\n\nChecking the Lean VersionShows the current Lean version. Prints Lean.versionString.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Packages","header":"22.1.3.2.2. Packages","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format","contents":"Package ConfigurationThere can only be one package declaration per Lake configuration file.\nThe defined package configuration will be available for reference as _package.\n\nPost-Update HooksDeclare a post-lake update hook for the package.\nRuns the monadic action is after a successful lake update execution\nin this package or one of its downstream dependents.ExampleThis feature enables Mathlib to synchronize the Lean toolchain and run\ncache get after a lake update:lean_exe cache\npost_update pkg do\n  let wsToolchainFile := (← getRootPackage).dir / \"lean-toolchain\"\n  let mathlibToolchain ← IO.FS.readFile <| pkg.dir / \"lean-toolchain\"\n  IO.FS.writeFile wsToolchainFile mathlibToolchain\n  let exeFile ← runBuild cache.fetch\n  let exitCode ← env exeFile.toString #[\"get\"]\n  if exitCode ≠ 0 then\n    error s!\"{pkg.name}: failed to fetch cache\"\n\n\n"},"/Basic-Types/Natural-Numbers/#nat-api-deceq":{"id":"/Basic-Types/Natural-Numbers/#nat-api-deceq","header":"19.1.4.5.2. Decidable Equality","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009API Reference\u0009Comparisons","contents":"A decision procedure for equality of natural numbers, usually accessed via the DecidableEq Nat\ninstance.This function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.Examples:* Nat.decEq 5 5 = isTrue rfl* (if 3 = 4 then \"yes\" else \"no\") = \"no\"* show 12 = 12 by decide\n\nA decision procedure for non-strict inequality of natural numbers, usually accessed via the\nDecidableLE Nat instance.Examples:* (if 3 ≤ 4 then \"yes\" else \"no\") = \"yes\"* (if 6 ≤ 4 then \"yes\" else \"no\") = \"no\"* show 12 ≤ 12 by decide* show 5 ≤ 12 by decide\n\nA decision procedure for strict inequality of natural numbers, usually accessed via the\nDecidableLT Nat instance.Examples:* (if 3 < 4 then \"yes\" else \"no\") = \"yes\"* (if 4 < 4 then \"yes\" else \"no\") = \"no\"* (if 6 < 4 then \"yes\" else \"no\") = \"no\"* show 5 < 12 by decide\n\n"}});