window.docContents[145].resolve({"/The-Type-System/Quotients/#quotient-reduction":{"id":"/The-Type-System/Quotients/#quotient-reduction","header":"4.5.5.1. Quotient Reduction","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Logical Model","contents":"\n\nIn addition to the above constants, Lean's kernel contains a reduction rule for Quot.lift that causes it to reduce when used with Quot.mk, analogous to ι-reduction for inductive types.\nGiven a relation r over α, a function f from α to β, and a proof resp that f respects r, the term Quot.lift f resp (Quot.mk r x) is definitionally equal to f x.\n\n\n\n\n\nvariable\n  (r : α → α → Prop)\n  (f : α → β)\n  (ok : ∀ x y, r x y → f x = f y)\n  (x : α)\n\nexample : Quot.lift f ok (Quot.mk r x) = f x := rfl\n\n\n\n\n"},"/The-Type-System/Inductive-Types/#recursor-elaboration-helpers":{"id":"/The-Type-System/Inductive-Types/#recursor-elaboration-helpers","header":"4.4.3.3. Constructions for Termination Checking","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model","contents":"In addition to the type constructor, constructors, and recursors that Lean's core type theory prescribes for inductive types, Lean constructs a number of useful helpers.\nFirst, the equation compiler (which translates recursive functions with pattern matching in to applications of recursors) makes use of these additional constructs:\n\n* recOn is a version of the recursor in which the major premise is prior to the minor premise for each constructor.* casesOn is a version of the recursor in which the major premise is prior to the minor premise for each constructor, and recursive arguments do not yield induction hypotheses. It expresses case analysis rather than primitive recursion.* below computes a type that, for some motive, expresses that all inhabitants of the inductive type that are subtrees of the major premise satisfy the motive. It transforms a motive for induction or primitive recursion into a motive for strong recursion or strong induction.* brecOn is a version of the recursor in which below is used to provide access to all subtrees, rather than just immediate recursive parameters. It represents strong induction.* noConfusion is a general statement from which injectivity and disjointness of constructors can be derived.* noConfusionType is the motive used for noConfusion that determines what the consequences of two constructors being equal would be. For separate constructors, this is False; if both constructors are the same, then the consequence is the equality of their respective parameters.\n\nFor well-founded recursion, it is frequently useful to have a generic notion of size available.\nThis is captured in the SizeOf class.\n\nSizeOf is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to Nat.\nThe default instance defines each constructor to be 1 plus the sum of the\nsizes of all the constructor fields.This is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the termination_by argument on the function definition.The \"size\" of an element, a natural number which decreases on fields of\neach inductive type.\n\n"},"/IO/Console-Output/#The-Lean-Language-Reference--IO--Console-Output":{"id":"/IO/Console-Output/#The-Lean-Language-Reference--IO--Console-Output","header":"15.3. Console Output","context":"Lean Reference\u0009IO","contents":"Lean includes convenience functions for writing to standard output and standard error.\nAll make use of ToString instances, and the varieties whose names end in -ln add a newline after the output.\nThese convenience functions only expose a part of the functionality available using the standard I/O streams.\nIn particular, to read a line from standard input, use a combination of IO.getStdin and IO.FS.Stream.getLine.\n\nConverts s to a string using its ToString α instance, and prints it to the current standard\noutput (as determined by IO.getStdout).\n\nConverts s to a string using its ToString α instance, and prints it with a trailing newline to\nthe current standard output (as determined by IO.getStdout).\n\nConverts s to a string using its ToString α instance, and prints it to the current standard\nerror (as determined by IO.getStderr).\n\nConverts s to a string using its ToString α instance, and prints it with a trailing newline to\nthe current standard error (as determined by IO.getStderr).\n\nPrintingThis program demonstrates all four convenience functions for console I/O.def main : IO Unit := do\n  IO.print \"This is the \"\n  IO.print \"Lean\"\n  IO.println \" language reference.\"\n  IO.println \"Thank you for reading it!\"\n  IO.eprint \"Please report any \"\n  IO.eprint \"errors\"\n  IO.eprintln \" so they can be corrected.\"\nIt outputs the following to the standard output:This is the Lean language reference.\nThank you for reading it!\nand the following to the standard error:Please report any errors so they can be corrected.\n\n\n"},"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent":{"id":"/Error-Explanations/lean___invalidDottedIdent/#The-Lean-Language-Reference--Error-Explanations--lean___invalidDottedIdent","header":"lean.invalidDottedIdent","context":"Lean Reference\u0009Error Explanations","contents":"\n\nThis error indicates that dotted identifier notation was used in an invalid or unsupported context.\nDotted identifier notation allows an identifier's namespace to be omitted, provided that it can be\ninferred by Lean based on type information. Details about this notation can be found in the manual\nsection on identifiers.\n\nThis notation can only be used in a term whose type Lean is able to infer. If there is insufficient\ntype information for Lean to do so, this error will be raised. The inferred type must not be a type\nuniverse (e.g., Prop or Type), as dotted-identifier notation is not supported on these types.\n\n\n\n"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-override":{"id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-override","header":"22.2.3.4. Managing Directory Overrides","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","contents":"Directory-specific toolchain overrides are a local configuration that takes precedence over lean-toolchain files.\nThe elan override commands manage overrides.\n\n\n\nLists all the currently configured directory overrides in two columns.\nThe left column contains the directories in which the Lean version is overridden, and the right column lists the toolchain version.\n\nSets toolchain as an override for the current directory.\n\nIf --nonexistent flag is provided, all overrides that are configured for directories that don't currently exist are removed.\nIf --path is provided, then the override set for path is removed.\nOtherwise, the override for the current directory is removed.\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Modification","header":"19.17.3.4. Modification","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","contents":"Modifies in place the value associated with a given key,\nallowing creating new values and deleting values via an Option valued replacement function.This function ensures that the value is used linearly.\n\nModifies in place the value associated with a given key.This function ensures that the value is used linearly.\n\nChecks whether a key is present in a map, and unconditionally inserts a value for the key.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nChecks whether a key is present in a map and inserts a value for the key if it was not found.If the returned Bool is true, then the returned map is unaltered. If the Bool is false, then\nthe returned map has a new value inserted.Equivalent to (but potentially faster than) calling contains followed by insertIfNew.\n\nRemoves the mapping for the given key if it exists.\n\nRemoves all mappings of the hash map for which the given function returns false.\n\nUpdates the values of the hash map by applying the given function to all mappings, keeping\nonly those mappings where the function returns some value.\n\nInserts the given mapping into the map. If there is already a mapping for the given key, then both\nkey and value will be replaced.Note: this replacement behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insert function on HashSet and HashSet.Raw behaves differently: it will return the set\nunchanged if a matching key is already present.\n\nIf there is no mapping for the given key, inserts the given mapping into the map. Otherwise,\nreturns the map unaltered.\n\nChecks whether a key is present in a map, returning the associated value, and inserts a value for\nthe key if it was not found.If the returned value is some v, then the returned map is unaltered. If it is none, then the\nreturned map has a new value inserted.Equivalent to (but potentially faster than) calling get? followed by insertIfNew.Uses the LawfulBEq instance to cast the retrieved value to the correct type.\n\nInserts multiple mappings into the hash map by iterating over the given collection and calling\ninsert. If the same key appears multiple times, the last occurrence takes precedence.Note: this precedence behavior is true for HashMap, DHashMap, HashMap.Raw and DHashMap.Raw.\nThe insertMany function on HashSet and HashSet.Raw behaves differently: it will prefer the first\nappearance.\n\nPartition a hash map into two hash map based on a predicate.\n\nComputes the union of the given hash maps, by traversing m₂ and inserting its elements into m₁.\n\n"},"/Basic-Types/Integers/#int-runtime":{"id":"/Basic-Types/Integers/#int-runtime","header":"19.2.2. Run-Time Representation","context":"Lean Reference\u0009Basic Types\u0009Integers","contents":"Like natural numbers, sufficiently-small integers are represented without pointers: the lowest-order bit in an object pointer is used to indicate that the value is not, in fact, a pointer.\nIf an integer is too large to fit in the remaining bits, it is instead allocated as an ordinary Lean object that consists of an object header and an arbitrary-precision integer.\n\n"}});