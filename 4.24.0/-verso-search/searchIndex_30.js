window.docContents[30].resolve({"/Coercions/Coercing-to-Sorts/#sort-coercion":{"contents":"The Lean elaborator expects types in certain positions without necessarily being able to determine the type's universe ahead of time.\nFor example, the term following the colon in a definition header might be a proposition or a type.\nThe ordinary coercion mechanism is not applicable because it requires a specific expected type, and there's no way to express that the expected type could be any universe in the Coe class.\n\nWhen a term is elaborated in a position where a proposition or type is expected, but the inferred type of the elaborated term is not a proposition or type, Lean  attempts to recover from the error by synthesizing an instance of CoeSort.\nIf the instance is found, and the resulting type is itself a type, then it the coercion is inserted and unfolded.\n\nNot every situation in which the elaborator expects a universe requires CoeSort.\nIn some cases, a particular universe is available as an expected type.\nIn these situations, ordinary coercion insertion using CoeT is used.\nInstances of CoeSort can be used to synthesize instances of CoeOut, so no separate instance is needed to support this use case.\nIn general, coercions to types should be implemented as CoeSort.\n\nCoeSort α β is a coercion to a sort. β must be a universe, and this is\ntriggered when a : α appears in a place where a type is expected, like\n(x : a) or a → a.\nCoeSort instances apply to CoeOut as well.Coerces a value of type α to β, which must be a universe.\n\nExplicit Coercion to SortsCoercions to sorts can be explicitly triggered using the ↥ prefix operator.\n\nSort CoercionsA monoid is a type equipped with an associative binary operation and an identity element.\nWhile monoid structure can be defined as a type class, it can also be defined as a structure that “bundles up” the structure with the type:structure Monoid where\n  Carrier : Type u\n  op : Carrier → Carrier → Carrier\n  id : Carrier\n  op_assoc :\n    ∀ (x y z : Carrier), op x (op y z) = op (op x y) z\n  id_op_identity : ∀ (x : Carrier), op id x = x\n  op_id_identity : ∀ (x : Carrier), op x id = x\nThe type Monoid does not indicate the carrier:def StringMonoid : Monoid where\n  Carrier := String\n  op := (· ++ ·)\n  id := \"\"\n  op_assoc := by intros; simp [String.append_assoc]\n  id_op_identity := by intros; simp\n  op_id_identity := by intros; simp\nHowever, a CoeSort instance can be implemented that applies the Monoid.Carrier projection when a monoid is used in a position where Lean would expect a type:instance : CoeSort Monoid (Type u) where\n  coe m := m.Carrier\n\nexample : StringMonoid := \"hello\"\n\n\nSort Coercions as Ordinary CoercionsThe inductive type NatOrBool represents the types Nat and Bool.\nThey can be coerced to the actual types Nat and Bool:inductive NatOrBool where\n  | nat | bool\n\n@[coe]\nabbrev NatOrBool.asType : NatOrBool → Type\n  | .nat => Nat\n  | .bool => Bool\n\ninstance : CoeSort NatOrBool Type where\n  coe := NatOrBool.asType\n\nopen NatOrBool\nThe CoeSort instance is used when nat occurs to the right of a colon:def x : nat := 5\nWhen an expected type is available, ordinary coercion insertion is used.\nIn this case, the CoeSort instance is used to synthesize a CoeOut NatOrBool Type instance, which chains with the Coe Type (Option Type) instance to recover from the type error.def y : Option Type := bool\n\n\n","context":"Lean Reference\u0009Coercions","header":"12.3. Coercing to Sorts","id":"/Coercions/Coercing-to-Sorts/#sort-coercion"},"/Run-Time-Code/#runtime":{"contents":"Compiled Lean code uses services provided by the Lean runtime.\nThe runtime contains efficient, low-level primitives that bridge the gap between the Lean language and the supported platforms.\nThese services include:\n\n Memory management\n\nLean does not require programmers to manually manage memory.\n    Space is allocated when needed to store a value, and values that can no longer be reached (and are thus irrelevant) are deallocated.\n    In particular, Lean uses reference counting, where each allocated object maintains a count of incoming references.\n    The compiler emits calls to memory management routines that allocate memory and modify reference counts, and these routines are provided by the runtime, along with the data structures that represent Lean values in compiled code.\n\n Multiple Threads\n\nThe Task API provides the ability to write parallel and concurrent code.\n    The runtime is responsible for scheduling Lean tasks across operating-system threads.\n\n Primitive operators\n\nMany built-in types, including Nat, Array, String, and fixed-width integers, have special representations for reasons of efficiency.\n    The runtime provides implementations of these types' primitive operators that take advantage of these optimized representations.\n\n\n\nThere are many primitive operators.\nThey are described in their respective sections under Basic Types.\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference","header":"21. Run-Time Code","id":"/Run-Time-Code/#runtime"},"/The-Type-System/Universes/#level-expressions":{"contents":"Levels that occur in a definition are not restricted to just variables and addition of constants.\nMore complex relationships between universes can be defined using level expressions.\n\nLevel ::= 0 | 1 | 2 | ...  -- Concrete levels\n        | u, v             -- Variables\n        | Level + n        -- Addition of constants\n        | max Level Level  -- Least upper bound\n        | imax Level Level -- Impredicative LUB\n\n\nGiven an assignment of level variables to concrete numbers, evaluating these expressions follows the usual rules of arithmetic.\nThe imax operation is defined as follows:\n\n\\mathtt{imax}\\ u\\ v = \\begin{cases}0 & \\mathrm{when\\ }v = 0\\\\\\mathtt{max}\\ u\\ v&\\mathrm{otherwise}\\end{cases}\n\nimax is used to implement impredicative quantification for Prop.\nIn particular, if A : Sort u and B : Sort v, then (x : A) → B : Sort (imax u v).\nIf B : Prop, then the function type is itself a Prop; otherwise, the function type's level is the maximum of u and v.\n\n","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","header":"4.3.2.1. Level Expressions","id":"/The-Type-System/Universes/#level-expressions"},"/releases/v4.10.0/#release-v4___10___0":{"contents":"Language features, tactics, and metaprograms* split tactic:* #4401 improves the strategy split uses to generalize discriminants of matches and adds trace.split.failure trace class for diagnosing issues.* rw tactic:* #4385 prevents the tactic from claiming pre-existing goals are new subgoals.* dac1da adds configuration for ordering new goals, like for apply.* simp tactic:* #4430 adds dsimprocs for if expressions (ite and dite).* #4434 improves heuristics for unfolding. Equational lemmas now have priorities where more-specific equationals lemmas are tried first before a possible catch-all.* #4481 fixes an issue where function-valued OfNat numeric literals would become denormalized.* #4467 fixes an issue where dsimp theorems might not apply to literals.* #4484 fixes the source position for the warning for deprecated simp arguments.* #4258 adds docstrings for dsimp configuration.* #4567 improves the accuracy of used simp lemmas reported by simp?.* fb9727 adds (but does not implement) the simp configuration option implicitDefEqProofs, which will enable including rfl-theorems in proof terms.* omega tactic:* #4360 makes the tactic generate error messages lazily, improving its performance when used in tactic combinators.* bv_omega tactic:* #4579 works around changes to the definition of Fin.sub in this release.* #4490 sets up groundwork for a tactic index in generated documentation, as there was in Lean 3. See PR description for details.* Commands* #4370 makes the variable command fully elaborate binders during validation, fixing an issue where some errors would be reported only at the next declaration.* #4408 fixes a discrepancy in universe parameter order between theorem and def declarations.* #4493 and\n#4482 fix a discrepancy in the elaborators for theorem, def, and example,\nmaking Prop-valued examples and other definition commands elaborate like theorems.* 8f023b, 3c4d6b and 0783d0 change the #reduce command to be able to control what gets reduced.\nFor example, #reduce (proofs := true) (types := false) e reduces both proofs and types in the expression e.\nBy default, neither proofs or types are reduced.* #4489 fixes an elaboration bug in #check_tactic.* #4505 adds support for open _root_.<namespace>.* Options* #4576 adds the debug.byAsSorry option. Setting set_option debug.byAsSorry true causes all by ... terms to elaborate as sorry.* 7b56eb and d8e719 add the debug.skipKernelTC option. Setting set_option debug.skipKernelTC true turns off kernel typechecking. This is meant for temporarily working around kernel performance issues, and it compromises soundness since buggy tactics may produce invalid proofs, which will not be caught if this option is set to true.* #4301\nadds a linter to flag situations where a local variable's name is one of\nthe argumentless constructors of its type. This can arise when a user either\ndoesn't open a namespace or doesn't add a dot or leading qualifier, as\nin the following:inductive Tree (α : Type) where\n  | leaf\n  | branch (left : Tree α) (val : α) (right : Tree α)\n\ndef depth : Tree α → Nat\n  | leaf => 0\nWith this linter, the leaf pattern is highlighted as a local\nvariable whose name overlaps with the constructor Tree.leaf.The linter can be disabled with set_option linter.constructorNameAsVariable false.Additionally, the error message that occurs when a name in a pattern that takes arguments isn't valid now suggests similar names that would be valid. This means that the following definition:def length (list : List α) : Nat :=\n  match list with\n  | nil => 0\n  | cons x xs => length xs + 1\nnow results in the following warning:warning: Local variable 'nil' resembles constructor 'List.nil' - write '.nil' (with a dot) or 'List.nil' to use the constructor.\nnote: this linter can be disabled with `set_option linter.constructorNameAsVariable false`\nand error:invalid pattern, constructor or constant marked with '[match_pattern]' expected\n\nSuggestion: 'List.cons' is similar\n* Metaprogramming* #4454 adds public Name.isInternalDetail function for filtering declarations using naming conventions for internal names.* Other fixes or improvements* #4416 sorts the output of #print axioms for determinism.* #4528 fixes error message range for the cdot focusing tactic.Language server, widgets, and IDE extensions* #4443 makes the watchdog be more resilient against badly behaving clients.Pretty printing* #4433 restores fallback pretty printers when context is not available, and documents addMessageContext.* #4556 introduces pp.maxSteps option and sets the default value of pp.deepTerms to false. Together, these keep excessively large or deep terms from overwhelming the Infoview.Library* #4560 splits GetElem class into GetElem and GetElem?.\nThis enables removing Decidable instance arguments from GetElem.getElem? and GetElem.getElem!, improving their rewritability.\nSee the docstrings for these classes for more information.* Array* #4389 makes Array.toArrayAux_eq be a simp lemma.* #4399 improves robustness of the proof for Array.reverse_data.* List* #4469 and #4475 improve the organization of the List API.* #4470 improves the List.set and List.concat API.* #4472 upstreams lemmas about List.filter from Batteries.* #4473 adjusts @[simp] attributes.* #4488 makes List.getElem?_eq_getElem be a simp lemma.* #4487 adds missing List.replicate API.* #4521 adds lemmas about List.map.* #4500 changes List.length_cons to use as.length + 1 instead of as.length.succ.* #4524 fixes the statement of List.filter_congr.* #4525 changes binder explicitness in List.bind_map.* #4550 adds maximum?_eq_some_iff' and minimum?_eq_some_iff?.* #4400 switches the normal forms for indexing List and Array to xs[n] and xs[n]?.* HashMap* #4372 fixes linearity in HashMap.insert and HashMap.erase, leading to a 40% speedup in a replace-heavy workload.* Option* #4403 generalizes type of Option.forM from Unit to PUnit.* #4504 remove simp attribute from Option.elim and instead adds it to individual reduction lemmas, making unfolding less aggressive.* Nat* #4242 adds missing theorems for n + 1 and n - 1 normal forms.* #4486 makes Nat.min_assoc be a simp lemma.* #4522 moves @[simp] from Nat.pred_le to Nat.sub_one_le.* #4532 changes various Nat.succ n to n + 1.* Int* #3850 adds complete div/mod simprocs for Int.* String/Char* #4357 make the byte size interface be Nat-valued with functions Char.utf8Size and String.utf8ByteSize.* #4438 upstreams Char.ext from Batteries and adds some Char documentation to the manual.* Fin* #4421 adjusts Fin.sub to be more performant in definitional equality checks.* Prod* #4526 adds missing Prod.map lemmas.* #4533 fixes binder explicitness in lemmas.* BitVec* #4428 adds missing simproc for BitVec equality.* #4417 adds BitVec.twoPow and lemmas, toward bitblasting multiplication for LeanSAT.* Std library* #4499 introduces Std, a library situated between Init and Lean, providing functionality not in the prelude both to Lean's implementation and to external users.* Other fixes or improvements* #3056 standardizes on using (· == a) over (a == ·).* #4502 fixes errors reported by running the library through the the Batteries linters.Lean internals* #4391 makes getBitVecValue? recognize BitVec.ofNatLt.* #4410 adjusts instantiateMVars algorithm to zeta reduce let expressions while beta reducing instantiated metavariables.* #4420 fixes occurs check for metavariable assignments to also take metavariable types into account.* #4425 fixes forEachModuleInDir to iterate over each Lean file exactly once.* #3886 adds support to build Lean core oleans using Lake.* Defeq and WHNF algorithms* #4387 improves performance of isDefEq by eta reducing lambda-abstracted terms during metavariable assignments, since these are beta reduced during metavariable instantiation anyway.* #4388 removes redundant code in isDefEqQuickOther.* Typeclass inference* #4530 fixes handling of metavariables when caching results at synthInstance?.* Elaboration* #4426 makes feature where the \"don't know how to synthesize implicit argument\" error reports the name of the argument more reliable.* #4497 fixes a name resolution bug for generalized field notation (dot notation).* #4536 blocks the implicit lambda feature for (e :) notation.* #4562 makes it be an error for there to be two functions with the same name in a where/let rec block.* Recursion principles* #4549 refactors findRecArg, extracting withRecArgInfo.\nErrors are now reported in parameter order rather than the order they are tried (non-indices are tried first).\nFor every argument, it will say why it wasn't tried, even if the reason is obvious (e.g. a fixed prefix or is Prop-typed, etc.).* Porting core C++ to Lean* #4474 takes a step to refactor constructions toward a future port to Lean.* #4498 ports mk_definition_inferring_unsafe to Lean.* #4516 ports recOn construction to Lean.* #4517, #4653, and #4651 port below and brecOn construction to Lean.* Documentation* #4501 adds a more-detailed docstring for PersistentEnvExtension.* Other fixes or improvements* #4382 removes @[inline] attribute from NameMap.find?, which caused respecialization at each call site.* 5f9ded improves output of trace.Elab.snapshotTree.* #4424 removes \"you might need to open '{dir}' in your editor\" message that is now handled by Lake and the VS Code extension.* #4451 improves the performance of CollectMVars and FindMVar.* #4479 adds missing DecidableEq and Repr instances for intermediate structures used by the BitVec and Fin simprocs.* #4492 adds tests for a previous isDefEq issue.* 9096d6 removes PersistentHashMap.size.* #4508 fixes @[implemented_by] for functions defined by well-founded recursion.* #4509 adds additional tests for apply? tactic.* d6eab3 fixes a benchmark.* #4563 adds a workaround for a bug in IndPredBelow.mkBelowMatcher.* Cleanup: #4380, #4431, #4494, e8f768, de2690, d3a756, #4404, #4537.Compiler, runtime, and FFI* d85d3d fixes criterion for tail-calls in ownership calculation.* #3963 adds validation of UTF-8 at the C++-to-Lean boundary in the runtime.* #4512 fixes missing unboxing in interpreter when loading initialized value.* #4477 exposes the compiler flags for the bundled C compiler (clang).Lake* #4384 deprecates inputFile and replaces it with inputBinFile and inputTextFile. Unlike inputBinFile (and inputFile), inputTextFile normalizes line endings, which helps ensure text file traces are platform-independent.* #4371 simplifies dependency resolution code.* #4439 touches up the Lake configuration DSL and makes other improvements:\nstring literals can now be used instead of identifiers for names,\navoids using French quotes in lake new and lake init templates,\nchanges the exe template to use Main for the main module,\nimproves the math template error if lean-toolchain fails to download,\nand downgrades unknown configuration fields from an error to a warning to improve cross-version compatibility.* #4496 tweaks require syntax and updates docs. Now require in TOML for a package name such as doc-gen4 does not need French quotes.* #4485 fixes a bug where package versions in indirect dependencies would take precedence over direct dependencies.* #4478 fixes a bug where Lake incorrectly included the module dynamic library in a platform-independent trace.* #4529 fixes some issues with bad import errors.\nA bad import in an executable no longer prevents the executable's root\nmodule from being built. This also fixes a problem where the location\nof a transitive bad import would not been shown.\nThe root module of the executable now respects nativeFacets.* #4564 fixes a bug where non-identifier script names could not be entered on the CLI without French quotes.* #4566 addresses a few issues with precompiled libraries.* Fixes a bug where Lake would always precompile the package of a module.* If a module is precompiled, it now precompiles its imports. Previously, it would only do this if imported.* #4495, #4692, #4849\nadd a new type of require that fetches package metadata from a\nregistry API endpoint (e.g. Reservoir) and then clones a Git package\nusing the information provided. To require such a dependency, the new\nsyntax is:require <scope> / <pkg-name> [@ git <rev>]\n-- Examples:\nrequire \"leanprover\" / \"doc-gen4\"\nrequire \"leanprover-community\" / \"proofwidgets\" @ git \"v0.0.39\"\nOr in TOML:[[require]]\nname = \"<pkg-name>\"\nscope = \"<scope>\"\nrev = \"<rev>\"\nUnlike with Git dependencies, Lake can make use of the richer\ninformation provided by the registry to determine the default branch of\nthe package. This means for repositories of packages like doc-gen4\nwhich have a default branch that is not master, Lake will now use said\ndefault branch (e.g., in doc-gen4's case, main).Lake also supports configuring the registry endpoint via an environment\nvariable: RESERVIOR_API_URL. Thus, any server providing a similar\ninterface to Reservoir can be used as the registry. Further\nconfiguration options paralleling those of Cargo's Alternative Registries\nand Source Replacement\nwill come in the future.DevOps/CI* #4427 uses Namespace runners for CI for leanprover/lean4.* #4440 fixes speedcenter tests in CI.* #4441 fixes that workflow change would break CI for unrebased PRs.* #4442 fixes Wasm release-ci.* 6d265b fixes for github.event.pull_request.merge_commit_sha sometimes not being available.* 16cad2 adds optimization for CI to not fetch complete history.* #4544 causes releases to be marked as prerelease on GitHub.* #4446 switches Lake to using src/lake/lakefile.toml to avoid needing to load a version of Lake to build Lake.* Nix* 5eb5fa fixes update-stage0-commit for Nix.* #4476 adds gdb to Nix shell.* e665a0 fixes update-stage0 for Nix.* 4808eb fixes cacheRoots for Nix.* #3811 adds platform-dependent flag to lib target.* #4587 adds linking of -lStd back into nix build flags on darwin.Breaking changes* Char.csize is replaced by Char.utf8Size (#4357).* Library lemmas now are in terms of (· == a) over (a == ·) (#3056).* Now the normal forms for indexing into List and Array is xs[n] and xs[n]? rather than using functions like List.get (#4400).* Sometimes terms created via a sequence of unifications will be more eta reduced than before and proofs will require adaptation (#4387).* The GetElem class has been split into two; see the docstrings for GetElem and GetElem? for more information (#4560).\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.10.0 (2024-07-31)","id":"/releases/v4.10.0/#release-v4___10___0"}});