window.docContents[252].resolve({"/Functors___-Monads-and--do--Notation/Syntax/#do-control-structures":{"contents":"There are do items that correspond to most of Lean's term-level control structures.\nWhen they occur as a step in a do block, they are interpreted as do items rather than terms.\nEach branch of the control structures is a sequence of do items, rather than a term, and some of them are more syntactically flexible than their corresponding terms.\n\nConditionalsIn a do block, if statements may omit their else branch.\nOmitting an else branch is equivalent to using pure () as the contents of the branch.\n\nSyntactically, the then branch cannot be omitted.\nFor these cases, unless only executes its body when the condition is false.\nThe do in unless is part of its syntax and does not induce a nested do block.\n\nReverse Conditionals\n\nWhen match is used in a do block, each branch is considered to be part of the same block.\nOtherwise, it is equivalent to the match term.\n\nPattern Matching\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009do -Notation","header":"14.3.2.4. Control Structures","id":"/Functors___-Monads-and--do--Notation/Syntax/#do-control-structures"},"/IO/Processes/#The-Lean-Language-Reference--IO--Processes--Running-Processes":{"contents":"There are three primary ways to run other programs from Lean:\n\n1. IO.Process.run synchronously executes another program, returning its standard output as a string. It throws an error if the process exits with an error code other than 0.2. IO.Process.output synchronously executes another program with an empty standard input, capturing its standard output, standard error, and exit code. No error is thrown if the process terminates unsuccessfully.3. IO.Process.spawn starts another program asynchronously and returns a data structure that can be used to access the process's standard input, output, and error streams.\n\nRuns a process to completion, blocking until it terminates.\nThe child process is run with a null standard input or the specified input if provided,\nIf the child process terminates successfully with exit code 0, its standard output is returned.\nAn exception is thrown if it terminates with any other exit code.The specifications of standard input, output, and error handles in args are ignored.\n\nRunning a ProgramWhen run, this program concatenates its own source code with itself twice using the Unix tool cat.-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\nIts output is:-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\n-- Main.lean begins here\ndef main : IO Unit := do\n  let src2 ← IO.Process.run {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  IO.println src2\n-- Main.lean ends here\n\n\nRunning a Program on a FileThis program uses the Unix utility grep as a filter to find four-digit palindromes.\nIt creates a file that contains all numbers from 0 through 9999, and then invokes grep on it, reading the result from its standard output.def main : IO Unit := do\n  -- Feed the input to the subprocess\n  IO.FS.withFile \"numbers.txt\" .write fun h =>\n    for i in [0:10000] do\n      h.putStrLn (toString i)\n\n  let palindromes ← IO.Process.run {\n    cmd := \"grep\",\n    args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#, \"numbers.txt\"]\n  }\n\n  let count := palindromes.trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\nIts output is:There are 90 four-digit palindromes.\n\n\nRuns a process to completion and captures its output and exit code.\nThe child process is run with a null standard input or the specified input if provided,\nand the current process blocks until it has run to completion.The specifications of standard input, output, and error handles in args are ignored.\n\nChecking Exit CodesWhen run, this program first invokes cat on a nonexistent file and displays the resulting error code.\nIt then concatenates its own source code with itself twice using the Unix tool cat.-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\nIts output is:Exit code from failed process: 1\n-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\n-- Main.lean begins here\ndef main : IO UInt32 := do\n  let src1 ← IO.Process.output {cmd := \"cat\", args := #[\"Nonexistent.lean\"]}\n  IO.println s!\"Exit code from failed process: {src1.exitCode}\"\n\n  let src2 ← IO.Process.output {cmd := \"cat\", args := #[\"Main.lean\", \"Main.lean\"]}\n  if src2.exitCode == 0 then\n    IO.println src2.stdout\n  else\n    IO.eprintln \"Concatenation failed\"\n    return 1\n\n  return 0\n-- Main.lean ends here\n\n\n\nStarts a child process with the provided configuration. The child process is spawned using operating\nsystem primitives, and it can be written in any language.The child process runs in parallel with the parent.If the child process's standard input is a pipe, use IO.Process.Child.takeStdin to make it\npossible to close the child's standard input before the process terminates, which provides the child with an end-of-file marker.\n\nAsynchronous SubprocessesThis program uses the Unix utility grep as a filter to find four-digit palindromes.\nIt feeds all numbers from 0 through 9999 to the grep process and then reads its result.\nThis code is only correct when grep is sufficiently fast and when the output pipe is large enough to contain all 90 four-digit palindromes.def main : IO Unit := do\n  let grep ← IO.Process.spawn {\n    cmd := \"grep\",\n    args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#],\n    stdin := .piped,\n    stdout := .piped,\n    stderr := .null\n  }\n\n  -- Feed the input to the subprocess\n  for i in [0:10000] do\n    grep.stdin.putStrLn (toString i)\n\n  -- Consume its output, after waiting 100ms for grep to process the data.\n  IO.sleep 100\n  let count := (← grep.stdout.readToEnd).trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\nIts output is:There are 90 four-digit palindromes.\n\n\nConfiguration for a child process to be spawned.Use IO.Process.spawn to start the child process. IO.Process.output and IO.Process.run can be\nused when the child process should be run to completion, with its output and/or error code captured.Command name.Arguments for the command.The child process's working directory. Inherited from the parent current process if none.Add or remove environment variables for the child process.The child process inherits the parent's environment, as modified by env. Keys in the array are\nthe names of environment variables. A none, causes the entry to be removed from the environment,\nand some sets the variable to the new value, adding it if necessary. Variables are processed from left to right.Inherit environment variables from the spawning process.Starts the child process in a new session and process group using setsid. Currently a no-op on\nnon-POSIX platforms.\n\nConfiguration for the standard input, output, and error handles of a child process.Configuration for the process' stdin handle.Configuration for the process' stdout handle.Configuration for the process' stderr handle.\n\nWhether the standard input, output, and error handles of a child process should be attached to\npipes, inherited from the parent, or null.If the stream is a pipe, then the parent process can use it to communicate with the child.The stream should be attached to a pipe.The stream should be inherited from the parent process.The stream should be empty.\n\nThe type of handles that can be used to communicate with a child process on its standard input,\noutput, or error streams.For IO.Process.Stdio.piped, this type is IO.FS.Handle. Otherwise, it is Unit, because no\ncommunication is possible.\n\nA child process that was spawned with configuration cfg.The configuration determines whether the child process's standard input, standard output, and\nstandard error are IO.FS.Handles or Unit.The child process's standard input handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.The child process's standard output handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.The child process's standard error handle, if it was configured as IO.Process.Stdio.piped, or\n() otherwise.\n\nBlocks until the child process has exited and return its exit code.\n\nChecks whether the child has exited. Returns none if the process has not exited, or its exit code\nif it has.\n\nTerminates the child process using the SIGTERM signal or a platform analogue.If the process was started using SpawnArgs.setsid, terminates the entire process group instead.\n\nExtracts the stdin field from a Child object, allowing the handle to be closed while maintaining\na reference to the child process.File handles are closed when the last reference to them is dropped. Closing the child's standard\ninput causes an end-of-file marker. Because the Child object has a reference to the standard\ninput, this operation is necessary in order to close the stream while the process is running (e.g.\nto extract its exit code after calling Child.wait). Many processes do not terminate until their\nstandard input is exhausted.\n\nClosing a Subprocess's Standard InputThis program uses the Unix utility grep as a filter to find four-digit palindromes, ensuring that the subprocess terminates successfully.\nIt feeds all numbers from 0 through 9999 to the grep process, then closes the process's standard input, which causes it to terminate.\nAfter checking grep's exit code, the program extracts its result.def main : IO UInt32 := do\n  let grep ← do\n    let (stdin, child) ← (← IO.Process.spawn {\n      cmd := \"grep\",\n      args := #[r#\"^\\([0-9]\\)\\([0-9]\\)\\2\\1$\"#],\n      stdin := .piped,\n      stdout := .piped,\n      stderr := .null\n    }).takeStdin\n\n    -- Feed the input to the subprocess\n    for i in [0:10000] do\n      stdin.putStrLn (toString i)\n\n    -- Return the child without its stdin handle.\n    -- This closes the handle, because there are\n    -- no more references to it.\n    pure child\n\n  -- Wait for grep to terminate\n  if (← grep.wait) != 0 then\n    IO.eprintln s!\"grep terminated unsuccessfully\"\n    return 1\n\n  -- Consume its output\n  let count := (← grep.stdout.readToEnd).trim.splitOn \"\\n\" |>.length\n\n  IO.println s!\"There are {count} four-digit palindromes.\"\n  return 0\nIts output is:There are 90 four-digit palindromes.\n\n\nThe result of running a process to completion.The process's exit code.Everything that was written to the process's standard output.Everything that was written to the process's standard error.\n\n","context":"Lean Reference\u0009IO\u0009Processes","header":"15.9.2. Running Processes","id":"/IO/Processes/#The-Lean-Language-Reference--IO--Processes--Running-Processes"}});