window.docContents[158].resolve({"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Logical-Model":{"contents":"Array α is the type of dynamic arrays with elements\nfrom α. This type has special support in the runtime.Arrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed destructively. This results in performance comparable to mutable\narrays in imperative programming languages.An array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\nArray.size, but the capacity is not observable from Lean code. Array.emptyWithCapacity n creates\nan array which is equal to #[], but internally allocates an array of capacity n. When the size\nexceeds the capacity, allocation is required to grow the array.From the point of view of proofs, Array α is just a wrapper around List α.Converts a List α into an Array α.The function List.toArray is preferred.At runtime, this constructor is overridden by List.toArrayImpl and is O(n) in the length of\nthe list.Converts an Array α into a List α that contains the same elements in the same order.At runtime, this is implemented by Array.toListImpl and is O(n) in the length of the\narray.\n\nThe logical model of arrays is a structure that contains a single field, which is a list of elements.\nThis is convenient when specifying and proving properties of array-processing functions at a low level.\n\n","context":"Lean Reference\u0009Basic Types\u0009Arrays","header":"19.16.1. Logical Model","id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Logical-Model"},"/Basic-Types/Integers/#int-model":{"contents":"Integers are represented either as a natural number or as the negation of the successor of a natural number.\n\nThe integers.This type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for Int that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\nGMP). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).A natural number is an integer.This constructor covers the non-negative integers (from 0 to ∞).The negation of the successor of a natural number is an integer.This constructor covers the negative integers (from -1 to -∞).\n\nThis representation of the integers has a number of useful properties.\nIt is relatively simple to use and to understand.\nUnlike a pair of a sign and a Nat, there is a unique representation for 0, which simplifies reasoning about equality.\nIntegers can also be represented as a pair of natural numbers in which one is subtracted from the other, but this requires a quotient type to be well-behaved, and quotient types can be laborious to work with due to the need to prove that functions respect the equivalence relation.\n\n","context":"Lean Reference\u0009Basic Types\u0009Integers","header":"19.2.1. Logical Model","id":"/Basic-Types/Integers/#int-model"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#exception-monads":{"contents":"Exception monads describe computations that terminate early (fail).\nFailing computations provide their caller with an exception value that describes why they failed.\nIn other words, computations either return a value or an exception.\nThe inductive type Except captures this pattern, and is itself a monad.\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads","header":"14.5.7. Exceptions","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#exception-monads"},"/The-Type-System/Functions/#function-extensionality":{"contents":"Definitional equality of functions in Lean is intensional.\nThis means that definitional equality is defined syntactically, modulo renaming of bound variables and reduction.\nTo a first approximation, this means that two functions are definitionally equal if they implement the same algorithm, rather than the usual mathematical notion of equality that states that two functions are equal if they map equal elements of the domain to equal elements of the codomain.\n\nDefinitional equality is used by the type checker, so it's important that it be predictable.\nThe syntactic character of intensional equality means that the algorithm to check it can be feasibly specified.\nChecking extensional equality involves proving essentially arbitrary theorems about equality of functions, and there is no clear specification for an algorithm to check it.\nThis makes extensional equality a poor choice for a type checker.\nFunction extensionality is instead made available as a reasoning principle that can be invoked when proving the proposition that two functions are equal.\n\nIn addition to reduction and renaming of bound variables, definitional equality does support one limited form of extensionality, called η-equivalence, in which functions are equal to abstractions whose bodies apply them to the argument.\nGiven f with type (x : α) → β x, f is definitionally equal to fun x => f x.\n\nWhen reasoning about functions, the theorem funextUnlike some intensional type theories, funext is a theorem in Lean. It can be proved using quotient types. or the corresponding tactics funext or ext can be used to prove that two functions are equal if they map equal inputs to equal outputs.\n\nFunction extensionality. If two functions return equal results for all possible arguments, then\nthey are equal.It is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be proved using quotient\ntypes.\n\n","context":"Lean Reference\u0009Type System\u0009Functions","header":"4.1.3. Extensionality","id":"/The-Type-System/Functions/#function-extensionality"}});