window.docContents[95].resolve({"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Comparisons":{"contents":"One character is less than or equal to another if its code point is less than or equal to the\nother's.\n\nOne character is less than another if its code point is strictly less than the other's.\n\n","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","header":"19.7.4.4. Comparisons","id":"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Comparisons"},"/Basic-Types/Strings/#string-iterators":{"contents":"Fundamentally, a String.Iterator is a pair of a string and a valid position in the string.\nIterators provide functions for getting the current character (curr), replacing the current character (setCurr), checking whether the iterator can move to the left or the right (hasPrev and hasNext, respectively), and moving the iterator (prev and next, respectively).\nClients are responsible for checking whether they've reached the beginning or end of the string; otherwise, the iterator ensures that its position always points at a character.\n\nAn iterator over the characters (Unicode code points) in a String. Typically created by\nString.iter.String iterators pair a string with a valid byte index. This allows efficient character-by-character\nprocessing of strings while avoiding the need to manually ensure that byte indices are used with the\ncorrect strings.An iterator is valid if the position i is valid for the string s, meaning 0 ≤ i ≤ s.endPos\nand i lies on a UTF8 byte boundary. If i = s.endPos, the iterator is at the end of the string.Most operations on iterators return unspecified values if the iterator is not valid. The functions\nin the String.Iterator API rule out the creation of invalid iterators, with two exceptions:* Iterator.next iter is invalid if iter is already at the end of the string (iter.atEnd is\ntrue), and* Iterator.forward iter n/Iterator.nextn iter n is invalid if n is strictly greater than the\nnumber of remaining characters.The string being iterated over.The current UTF-8 byte position in the string s.This position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is (default : Char), similar to String.get on an invalid position.\n\nCreates an iterator at the beginning of the string.\n\nCreates an iterator at the beginning of the string.\n\nGets the character at the iterator's current position.A run-time bounds check is performed. Use String.Iterator.curr' to avoid redundant bounds checks.If the position is invalid, returns (default : Char).\n\nChecks whether the iterator is at or before the string's last character.\n\nMoves the iterator's position forward by one character, unconditionally.It is only valid to call this function if the iterator is not at the end of the string (i.e.\nif Iterator.atEnd is false); otherwise, the resulting iterator will be invalid.\n\nMoves the iterator's position forward by the specified number of characters.The resulting iterator is only valid if the number of characters to skip is less than or equal\nto the number of characters left in the iterator.\n\nMoves the iterator's position forward by the specified number of characters.The resulting iterator is only valid if the number of characters to skip is less than or equal\nto the number of characters left in the iterator.\n\nChecks whether the iterator is after the beginning of the string.\n\nMoves the iterator's position backward by one character, unconditionally.The position is not changed if the iterator is at the beginning of the string.\n\nMoves the iterator's position back by the specified number of characters, stopping at the beginning\nof the string.\n\nChecks whether the iterator is past its string's last character.\n\nMoves the iterator's position to the end of the string, just past the last character.\n\nReplaces the current character in the string.Does nothing if the iterator is at the end of the string. If both the replacement character and the\nreplaced character are 7-bit ASCII characters and the string is not shared, then it is updated\nin-place and not copied.\n\nExtracts the substring between the positions of two iterators. The first iterator's position is the\nstart of the substring, and the second iterator's position is the end.Returns the empty string if the iterators are for different strings, or if the position of the first\niterator is past the position of the second iterator.\n\nThe remaining characters in an iterator, as a string.\n\nThe number of UTF-8 bytes remaining in the iterator.\n\nThe current UTF-8 byte position in the string s.This position is not guaranteed to be valid for the string. If the position is not valid, then the\ncurrent character is (default : Char), similar to String.get on an invalid position.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.9. Iterators","id":"/Basic-Types/Strings/#string-iterators"},"/Type-Classes/Class-Declarations/#class":{"contents":"Type classes are declared with the class keyword.\n\nType Class DeclarationsDeclares a new type class.\n\n\n\nThe class declaration creates a new single-constructor inductive type, just as if the structure command had been used instead.\nIn fact, the results of the class and structure commands are almost identical, and features such as default values may be used the same way in both.\nPlease refer to the documentation for structures for more information about default values, inheritance, and other features of structures.\nThe differences between structure and class declarations are:\n\n Methods instead of fields\n\nInstead of creating field projections that take a value of the structure type as an explicit parameter, methods are created. Each method takes the corresponding instance as an instance-implicit parameter.\n\n Instance-implicit parent classes\n\nThe constructor of a class that extends other classes takes its class parents' instances as instance-implicit parameters, rather than explicit parameters.\n  When instances of this class are defined, instance synthesis is used to find the values of inherited fields.\n  Parents that are not classes are still explicit parameters to the underlying constructor.\n\n Parent projections via instance synthesis\n\nStructure field projections make use of inheritance information to project parent structure fields from child structure values.\n  Classes instead use instance synthesis: given a child class instance, synthesis will construct the parent; thus, methods are not added to child classes in the same way that projections are added to child structures.\n\n Registered as class\n\nThe resulting inductive type is registered as a type class, for which instances may be defined and that may be used as the type of instance-implicit arguments.\n\n Out and semi-out parameters are considered\n\nThe outParam and semiOutParam gadgets have no meaning in structure definitions, but they are used in class definitions to control instance search.\n\n\n\nWhile deriving clauses are allowed for class definitions to maintain the parallel between class and structure elaboration, they are not frequently used and should be considered an advanced feature.\n\nNo Instances of Non-ClassesLean rejects instance-implicit parameters of types that are not classes:def f [n : Nat] : n = n := rfl\ninvalid binder annotation, type is not a class instance\n  Nat\n\nNote: Use the command `set_option checkBinderAnnotations false` to disable the check\n\n\nClass vs Structure ConstructorsA very small algebraic hierarchy can be represented either as structures (S.Magma, S.Semigroup, and S.Monoid below), a mix of structures and classes (C1.Monoid), or only using classes (C2.Magma, C2.Semigroup, and C2.Monoid):namespace S\nstructure Magma (α : Type u) where\n  op : α → α → α\n\nstructure Semigroup (α : Type u) extends Magma α where\n  op_assoc : ∀ x y z, op (op x y) z = op x (op y z)\n\nstructure Monoid (α : Type u) extends Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend S\n\nnamespace C1\nclass Monoid (α : Type u) extends S.Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend C1\n\nnamespace C2\nclass Magma (α : Type u) where\n  op : α → α → α\n\nclass Semigroup (α : Type u) extends Magma α where\n  op_assoc : ∀ x y z, op (op x y) z = op x (op y z)\n\nclass Monoid (α : Type u) extends Semigroup α where\n  ident : α\n  ident_left : ∀ x, op ident x = x\n  ident_right : ∀ x, op x ident = x\nend C2\nS.Monoid.mk and C1.Monoid.mk have identical signatures, because the parent of the class C1.Monoid is not itself a class:S.Monoid.mk.{u} {α : Type u}\n  (toSemigroup : S.Semigroup α)\n  (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x)\n  (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  S.Monoid α\nC1.Monoid.mk.{u} {α : Type u}\n  (toSemigroup : S.Semigroup α)\n  (ident : α)\n  (ident_left : ∀ (x : α), toSemigroup.op ident x = x)\n  (ident_right : ∀ (x : α), toSemigroup.op x ident = x) :\n  C1.Monoid α\nSimilarly, because neither S.Magma nor C2.Magma inherits from another structure or class, their constructors are identical:S.Magma.mk.{u} {α : Type u} (op : α → α → α) : S.Magma α\nC2.Magma.mk.{u} {α : Type u} (op : α → α → α) : C2.Magma α\nS.Semigroup.mk, however, takes its parent as an ordinary parameter, while C2.Semigroup.mk takes its parent as an instance implicit parameter:S.Semigroup.mk.{u} {α : Type u}\n  (toMagma : S.Magma α)\n  (op_assoc : ∀ (x y z : α),\n    toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) :\n  S.Semigroup α\nC2.Semigroup.mk.{u} {α : Type u} [toMagma : C2.Magma α]\n  (op_assoc : ∀ (x y z : α),\n    toMagma.op (toMagma.op x y) z = toMagma.op x (toMagma.op y z)) :\n  C2.Semigroup α\nFinally, C2.Monoid.mk takes its semigroup parent as an instance implicit parameter.\nThe references to op become references to the method C2.Magma.op, relying on instance synthesis to recover the implementation from the C2.Semigroup instance-implicit parameter via its parent projection:C2.Monoid.mk.{u} {α : Type u}\n  [toSemigroup : C2.Semigroup α]\n  (ident : α)\n  (ident_left : ∀ (x : α), C2.Magma.op ident x = x)\n  (ident_right : ∀ (x : α), C2.Magma.op x ident = x) :\n  C2.Monoid α\n\n\nParameters to type classes may be marked with gadgets, which are special versions of the identity function that cause the elaborator to treat a value differently.\nGadgets never change the meaning of a term, but they may cause it to be treated differently in elaboration-time search procedures.\nThe gadgets outParam and semiOutParam affect instance synthesis, so they are documented in that section.\n\nWhether a type is a class or not has no effect on definitional equality.\nTwo instances of the same class with the same parameters are not necessarily identical and may in fact be very different.\n\nInstances are Not UniqueThis implementation of binary heap insertion is buggy:structure Heap (α : Type u) where\n  contents : Array α\nderiving Repr\n\ndef Heap.bubbleUp [Ord α] (i : Nat) (xs : Heap α) : Heap α :=\n  if h : i = 0 then xs\n  else if h : i ≥ xs.contents.size then xs\n  else\n    let j := i / 2\n    if Ord.compare xs.contents[i] xs.contents[j] == .lt then\n      Heap.bubbleUp j { xs with contents := xs.contents.swap i j }\n    else xs\n\ndef Heap.insert [Ord α] (x : α) (xs : Heap α) : Heap α :=\n  let i := xs.contents.size\n  {xs with contents := xs.contents.push x}.bubbleUp i\nThe problem is that a heap constructed with one Ord instance may later be used with another, leading to the breaking of the heap invariant.One way to correct this is to make the heap type depend on the selected Ord instance:structure Heap' (α : Type u) [Ord α] where\n  contents : Array α\n\ndef Heap'.bubbleUp [inst : Ord α]\n    (i : Nat) (xs : @Heap' α inst) :\n    @Heap' α inst :=\n  if h : i = 0 then xs\n  else if h : i ≥ xs.contents.size then xs\n  else\n    let j := i / 2\n    if inst.compare xs.contents[i] xs.contents[j] == .lt then\n      Heap'.bubbleUp j {xs with contents := xs.contents.swap i j}\n    else xs\n\ndef Heap'.insert [Ord α] (x : α) (xs : Heap' α) : Heap' α :=\n  let i := xs.contents.size\n  {xs with contents := xs.contents.push x}.bubbleUp i\nIn the improved definitions, Heap'.bubbleUp is needlessly explicit; the instance does not need to be explicitly named here because Lean would select the indicated instances nonetheless, but it does bring the correctness invariant front and center for readers.\n\n\n\n\n\n","context":"Lean Reference\u0009Type Classes","header":"11.1. Class Declarations","id":"/Type-Classes/Class-Declarations/#class"}});