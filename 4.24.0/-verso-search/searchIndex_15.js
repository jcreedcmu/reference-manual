window.docContents[15].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Runtime-Representation":{"contents":"Bitvectors are represented as a Fin with the corresponding range.\nBecause BitVec is a trivial wrapper around Fin and Fin is a trivial wrapper around Nat, bitvectors use the same runtime representation as Nat in compiled code.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","header":"19.5.2. Runtime Representation","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--Runtime-Representation"},"/Definitions/Recursive-Definitions/#unsafe":{"contents":"Unsafe definitions have even fewer safeguards than partial functions.\nTheir codomains do not need to be inhabited, they are not restricted to function definitions, and they have access to features of Lean that might violate internal invariants or break abstractions.\nAs a result, they cannot be used at all as part of mathematical reasoning.\n\nWhile partial functions are treated as opaque constants by the type theory, unsafe definitions may only be referenced from other unsafe definitions.\nAs a consequence, any function that calls an unsafe function must be unsafe itself.\nTheorems are not allowed to be declared unsafe.\n\nIn addition to unrestricted use of recursion, unsafe functions can cast from one type to another, check whether two values are the very same object in memory, retrieve pointer values, and run IO actions from otherwise-pure code.\nUsing these operators requires a thorough understanding of the Lean implementation.\n\nThis function will cast a value of type α to type β, and is a no-op in the\ncompiler. This function is extremely dangerous because there is no guarantee\nthat types α and β have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\nTrue to False. For all those reasons this function is marked as unsafe.It is implemented by lifting both α and β into a common universe, and then\nusing cast (lcProof : ULift (PLift α) = ULift (PLift β)) to actually perform\nthe cast. All these operations are no-ops in the compiler.Using this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:* Array α to Array β where α and β have compatible representations,\nor more generally for other inductive types.* Quot α r and α.* @Subtype α p and α, or generally any structure containing only one\nnon-Prop field of type α.* Casting α to/from NonScalar when α is a boxed generic type\n(i.e. a function that accepts an arbitrary type α and is not specialized to\na scalar type like UInt8).\n\nCompares two objects for pointer equality.Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This\nfunction is unsafe because it can distinguish between definitionally equal values.\n\nCompares two lists of objects for element-wise pointer equality. Returns true if both lists are\nthe same length and the objects at the corresponding indices of each list are pointer-equal.Two objects are pointer-equal if, at runtime, they are allocated at exactly the same address. This\nfunction is unsafe because it can distinguish between definitionally equal values.\n\nReturns the address at which an object is allocated.This function is unsafe because it can distinguish between definitionally equal values.\n\nReturns true if a is an exclusive object.An object is exclusive if it is single-threaded and its reference counter is 1. This function is\nunsafe because it can distinguish between definitionally equal values.\n\nA monad that can have side effects on the external world or throw exceptions of type ε.BaseIO is a version of this monad that cannot throw exceptions. IO sets the exception type to\nIO.Error.\n\nExecutes arbitrary side effects in a pure context, with exceptions indicated via Except. This a\ndangerous operation that can easily undermine important assumptions about the meaning of Lean\nprograms, and it should only be used with great care and a thorough understanding of compiler\ninternals, and even then only to implement observationally pure operations.This function is not a good way to convert an EIO α or IO α into an α. Instead, use\ndo-notation.Because the resulting value is treated as a side-effect-free term, the compiler may re-order,\nduplicate, or delete calls to this function. The side effect may even be hoisted into a constant,\ncausing the side effect to occur at initialization time, even if it would otherwise never be called.\n\nExecutes arbitrary side effects in a pure context. This a dangerous operation that can easily\nundermine important assumptions about the meaning of Lean programs, and it should only be used with\ngreat care and a thorough understanding of compiler internals, and even then only to implement\nobservationally pure operations.This function is not a good way to convert a BaseIO α into an α. Instead, use\ndo-notation.Because the resulting value is treated as a side-effect-free term, the compiler may re-order,\nduplicate, or delete calls to this function. The side effect may even be hoisted into a constant,\ncausing the side effect to occur at initialization time, even if it would otherwise never be called.\n\nFrequently, unsafe operators are used to write fast code that takes advantage of low-level details.\nJust as Lean code may be replaced at runtime with C code via the FFI, safe Lean code may be replaced with unsafe Lean code for runtime programs.\nThis is accomplished by adding the implemented_by attribute to the function that is to be replaced, which is often an opaque definition.\nWhile this does not threaten Lean's soundness as a logic because the constant to be replaced has already been checked by the kernel and the unsafe replacement is only used in run-time code, it is still risky.\nBoth C code and unsafe code may execute arbitrary side effects.\n\nReplacing Run-Time ImplementationsThe implemented_by attribute instructs the compiler to replace one constant with another in compiled code.\nThe replacement constant may be unsafe.\n\nChecking Equality with PointersOrdinarily, a BEq instance's equality predicate must fully traverse both of its arguments to determine whether they are equal.\nIf they are, in fact, the very same object in memory, this is wasteful indeed.\nA pointer equality test can be used prior to the traversal to catch this case.The type being compared is Tree, a type of binary trees.inductive Tree α where\n  | empty\n  | branch (left : Tree α) (val : α) (right : Tree α)\nAn unsafe function may use pointer equality to terminate the structural equality test more quickly, falling back to structural checks when pointer equality fails.unsafe def Tree.fastBEq [BEq α] (t1 t2 : Tree α) : Bool :=\n  if ptrEq t1 t2 then\n    true\n  else\n    match t1, t2 with\n    | .empty, .empty => true\n    | .branch l1 x r1, .branch l2 y r2 =>\n      if ptrEq x y || x == y then\n        l1.fastBEq l2 && r1.fastBEq r2\n      else false\n    | _, _ => false\nAn implemented_by attribute on an opaque definition bridges the worlds of safe and unsafe code.@[implemented_by Tree.fastBEq]\nopaque Tree.beq [BEq α] (t1 t2 : Tree α) : Bool\n\ninstance [BEq α] : BEq (Tree α) where\n  beq := Tree.beq\n\n\nTaking Advantage of Run-Time RepresentationsBecause a Fin is represented identically to its underlying Nat, List.map Fin.val can be replaced by unsafeCast to avoid a linear-time traversal that, in practice, does nothing:unsafe def unFinImpl (xs : List (Fin n)) : List Nat :=\n  unsafeCast xs\n\n@[implemented_by unFinImpl]\ndef unFin (xs : List (Fin n)) : List Nat :=\n  xs.map Fin.val\nFrom the perspective of the Lean kernel, unFin is defined using List.map:theorem unFin_length_eq_length {xs : List (Fin n)} :\n    (unFin xs).length = xs.length := by\n  simp [unFin]\nIn compiled code, there is no traversal of the list.This kind of replacement is risky: the correspondence between the proof and the compiled code depends fully on the equivalence of the two implementations, which cannot be proved in Lean.\nThe correspondence relies on details of Lean's implementation.\nThese “escape hatches” should be used very carefully.\n\n","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Partial and Unsafe Definitions","header":"7.6.5.2. Unsafe Definitions","id":"/Definitions/Recursive-Definitions/#unsafe"}});