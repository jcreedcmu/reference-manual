window.docContents[65].resolve({"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Conversion":{"contents":"Converts a bitvector into a fixed-width hexadecimal number with enough digits to represent it.If n is 0, then one digit is returned. Otherwise, ⌊(n + 3) / 4⌋ digits are returned.\n\nInterprets the bitvector as an integer stored in two's complement form.\n\nReturn the underlying Nat that represents a bitvector.This is O(1) because BitVec is a (zero-cost) wrapper around a Nat.\n\nTurns a Bool into a bitvector of length 1.\n\nConverts a list of Bools into a big-endian BitVec.\n\nConverts a list of Bools into a little-endian BitVec.\n\nConverts an integer to its two's complement representation as a bitvector of the given width n,\nover- and underflowing as needed.The underlying Nat is (2^n + (i mod 2^n)) mod 2^n. Converting the bitvector back to an Int\nwith BitVec.toInt results in the value i.bmod (2^n).\n\nThe bitvector with value i mod 2^n.Conventions for notations in identifiers:* The recommended spelling of 0#n in identifiers is zero (not ofNat_zero).* The recommended spelling of 1#n in identifiers is one (not ofNat_one).\n\nThe BitVec with value i, given a proof that i < 2^w.\n\nIf two natural numbers n and m are equal, then a bitvector of width n is also a bitvector of\nwidth m.Using x.cast eq should be preferred over eq ▸ x because there are special-purpose simp lemmas\nthat can more consistently simplify BitVec.cast away.\n\n","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","header":"19.5.5.3. Conversion","id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Conversion"},"/Basic-Types/Maps-and-Sets/#HashSet":{"contents":"Hash sets.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.Data.HashSet.Raw and\nStd.Data.HashSet.Raw.WF unbundle the invariant from the hash set. When in doubt, prefer\nHashSet over HashSet.Raw.Internal implementation detail of the hash set.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","header":"19.17.6. Hash Sets","id":"/Basic-Types/Maps-and-Sets/#HashSet"},"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--ST--Backed-State-Monads":{"contents":"Creates a MonadStateOf instance from a reference cell.This allows programs written against the state monad API to\nbe executed using a mutable reference cell to track the state.\n\n","context":"Lean Reference\u0009IO\u0009Mutable References\u0009State Transformers","header":"15.4.1.3. ST -Backed State Monads","id":"/IO/Mutable-References/#The-Lean-Language-Reference--IO--Mutable-References--State-Transformers--ST--Backed-State-Monads"}});