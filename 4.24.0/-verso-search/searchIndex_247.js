window.docContents[247].resolve({"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent":{"contents":"Computes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntan.\n\nComputes the tangent of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanf.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanh.\n\nComputes the hyperbolic tangent of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\ntanhf.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan.\n\nComputes the arc tangent (inverse tangent) of a floating-point number in radians.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanf.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanh.\n\nComputes the hyperbolic arc tangent (inverse tangent) of a floating-point number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natanhf.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2.\n\nComputes the arc tangent (inverse tangent) of y / x in radians, in the range -π–π. The signs\nof the arguments determine the quadrant of the result.This function does not reduce in the kernel. It is implemented in compiled code by the C function\natan2f.\n\n","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference\u0009Trigonometry","header":"19.6.2.9.3. Tangent","id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Trigonometry--Tangent"},"/Basic-Types/Linked-Lists/#list-syntax":{"contents":"List literals are written in square brackets, with the elements of the list separated by commas.\nThe constructor List.cons that adds an element to the front of a list is represented by the infix operator ::.\nThe syntax for lists can be used both in ordinary terms and in patterns.\n\nList LiteralsThe syntax [a, b, c] is shorthand for a :: b :: c :: [], or\nList.cons a (List.cons b (List.cons c List.nil)). It allows conveniently constructing\nlist literals.For lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\nlet left := [d, e, f]; a :: b :: c :: left to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like dbg_trace.Conventions for notations in identifiers:* The recommended spelling of [] in identifiers is nil.* The recommended spelling of [a] in identifiers is singleton.\n\nList ConstructionThe list whose first element is head, where tail is the rest of the list.\nUsually written head :: tail.Conventions for notations in identifiers:* The recommended spelling of :: in identifiers is cons.\n\nConstructing ListsAll of these examples are equivalent:example : List Nat := [1, 2, 3]\nexample : List Nat := 1 :: [2, 3]\nexample : List Nat := 1 :: 2 :: [3]\nexample : List Nat := 1 :: 2 :: 3 :: []\nexample : List Nat := 1 :: 2 :: 3 :: .nil\nexample : List Nat := 1 :: 2 :: .cons 3 .nil\nexample : List Nat := .cons 1 (.cons 2 (.cons 3 .nil))\n\n\nPattern Matching and ListsAll of these functions are equivalent:def split : List α → List α × List α\n  | [] => ([], [])\n  | [x] => ([x], [])\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | x :: [] => (.singleton x, .nil)\n  | x :: x' :: xs =>\n    let (ys, zs) := split xs\n    (x :: ys, x' :: zs)\ndef split'' : List α → List α × List α\n  | .nil => (.nil, .nil)\n  | .cons x .nil=> (.singleton x, .nil)\n  | .cons x (.cons x' xs) =>\n    let (ys, zs) := split xs\n    (.cons x ys, .cons x' zs)\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Linked Lists","header":"19.15.1. Syntax","id":"/Basic-Types/Linked-Lists/#list-syntax"},"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch":{"contents":"\n\nThis error occurs when a parameter of an inductive type is not uniform in an inductive\ndeclaration. The parameters of an inductive type (i.e., those that appear before the colon following\nthe inductive keyword) must be identical in all occurrences of the type being defined in its\nconstructors' types. If a parameter of an inductive type must vary between constructors, make the\nparameter an index by moving it to the right of the colon. See the manual section on\nInductive Types for additional details.\n\nNote that auto-implicit inlay hints always appear left of the colon in an inductive declaration\n(i.e., as parameters), even when they are actually indices. This means that double-clicking on an\ninlay hint to insert such parameters may result in this error. If it does, change the inserted\nparameters to indices.\n\n\n\n","context":"Lean Reference\u0009Error Explanations","header":"lean.inductiveParamMismatch","id":"/Error-Explanations/lean___inductiveParamMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___inductiveParamMismatch"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators":{"contents":"Infix operators are primarily useful in smaller expressions, or when there is no Monad instance.\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax","header":"14.3.1. Infix Operators","id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators"}});