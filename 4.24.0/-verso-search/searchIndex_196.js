window.docContents[196].resolve({"/Basic-Propositions/Propositional-Equality/#HEq":{"contents":"Heterogeneous equality is a version of propositional equality that does not require that the two equated terms have the same type.\nHowever, proving that the terms are equal using its version of rfl requires that both the types and the terms are definitionally equal.\nIn other words, it allows more statements to be formulated.\n\nHeterogeneous equality is typically less convenient in practice than ordinary propositional equality.\nThe greater flexibility afforded by not requiring both sides of the equality to have the same type means that it has fewer useful properties.\nIt is often encountered as a result of dependent pattern matching: the split tactic and functional induction add heterogeneous equality assumptions to the context when the ordinary equality assumptions that are needed to accurate reflect the corresponding control flow would not be type correct.\nIn these cases, the built-in automation has no choice but to use heterogeneous equality.\n\nHeterogeneous equality. a ≍ b asserts that a and b have the same\ntype, and casting a across the equality yields b, and vice versa.You should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as Eq, because the assumption that the types of\na and b are equal is often too weak to prove theorems of interest. One\npublic important non-theorem is the analogue of congr: If f ≍ g and x ≍ y\nand f x and g y are well typed it does not follow that f x ≍ g y.\n(This does follow if you have f = g instead.) However if a and b have\nthe same type then a = b and a ≍ b are equivalent.Reflexivity of heterogeneous equality.\n\nHeterogeneous EqualityHeterogeneous equality HEq x y can be written x ≍ y.\n\nA version of HEq.refl with an implicit argument.\n\nHeterogeneous EqualityThe type Vector α n is a wrapper around an Array α that includes a proof that the array has size n.\nAppending Vectors is associative, but this fact cannot be straightforwardly stated using ordinary propositional equality:variable\n  {xs : Vector α l₁} {ys : Vector α l₂} {zs : Vector α l₃}\nset_option linter.unusedVariables false\ntheorem Vector.append_associative :\n    xs ++ (ys ++ zs) = (xs ++ ys) ++ zs := by sorry\nThe problem is that the associativity of addition of natural numbers holds propositionally, but not definitionally:Type mismatch\n  xs ++ ys ++ zs\nhas type\n  Vector α (l₁ + l₂ + l₃)\nbut is expected to have type\n  Vector α (l₁ + (l₂ + l₃))\nOne solution to this problem is to use the associativity of natural number addition in the statement:theorem Vector.append_associative' :\n    xs ++ (ys ++ zs) =\n    Nat.add_assoc _ _ _ ▸ ((xs ++ ys) ++ zs) := by\n  sorry\nHowever, such proof statements can be difficult to work with in certain circumstances.Another is to use heterogeneous equality:theorem Vector.append_associative :\n    HEq (xs ++ (ys ++ zs)) ((xs ++ ys) ++ zs) := by sorry\nIn this case, the simplifier can rewrite both sides of the equation without having to preserve their types.\nHowever, proving the theorem does require eventually proving that the lengths nonetheless match.theorem Vector.append_associative :\n    HEq (xs ++ (ys ++ zs)) ((xs ++ ys) ++ zs) := by\n  cases xs; cases ys; cases zs\n  simp\n  congr 1\n  . omega\n  . apply heq_of_eqRec_eq\n    . rfl\n    . apply propext\n      constructor <;> intro h <;> simp_all +arith\n\n\nHEq.ndrec variant\n\nNon-dependent recursor for HEq\n\nHEq.ndrec variant\n\nSubstitution with heterogeneous equality.\n\nIf two heterogeneously equal terms have the same type, then they are propositionally equal.\n\nPropositionally equal terms are also heterogeneously equal.\n\nIf casting a term with Eq.rec to another type makes it equal to some other term, then the two\nterms are heterogeneously equal.\n\nRewriting inside φ using Eq.recOn yields a term that's heterogeneously equal to the original\nterm.\n\nThe result of casting a term with cast is heterogeneously equal to the original term.\n\nHeterogeneous equality precomposes with propositional equality.\n\nIf two terms are heterogeneously equal then their types are propositionally equal.\n\n","context":"Lean Reference\u0009Basic Propositions\u0009Propositional Equality","header":"18.4.2. Heterogeneous Equality","id":"/Basic-Propositions/Propositional-Equality/#HEq"},"/Basic-Types/Fixed-Precision-Integers/#fixed-int-runtime":{"contents":"In compiled code in contexts that require boxed representations, fixed-width integer types that fit in one less bit than the platform's pointer size are always represented without additional allocations or indirections.\nThis always includes Int8, UInt8, Int16, and UInt16.\nOn 64-bit architectures, Int32 and UInt32 are also represented without pointers.\nOn 32-bit architectures, Int32 and UInt32 require a pointer to an object on the heap.\nISize, USize, Int64 and UInt64 may require pointers on all architectures.\n\nEven though some fixed-with integer types require boxing in general, the compiler is able to represent them without boxing or pointer indirections in code paths that use only a specific fixed-width type rather than being polymorphic, potentially after a specialization pass.\nThis applies in most practical situations where these types are used: their values are represented using the corresponding unsigned fixed-width C type when a constructor parameter, function parameter, function return value, or intermediate result is known to be a fixed-width integer type.\nThe Lean run-time system includes primitives for storing fixed-width integers in constructors of inductive types, and the primitive operations are defined on the corresponding C types, so boxing tends to happen at the “edges” of integer calculations rather than for each intermediate result.\nIn contexts where other types might occur, such as the contents of polymorphic containers like Array, these types are boxed, even if an array is statically known to contain only a single fixed-width integer type.The monomorphic array type ByteArray avoids boxing for arrays of UInt8.\nLean does not specialize the representation of inductive types or arrays.\nInspecting a function's type in Lean is not sufficient to determine how fixed-width integer values will be represented, because boxed values are not eagerly unboxed—a function that projects an Int64 from an array returns a boxed integer value.\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.2. Run-Time Representation","id":"/Basic-Types/Fixed-Precision-Integers/#fixed-int-runtime"},"/Basic-Types/Tuples/#sigma-types":{"contents":"Dependent pairs, also known as dependent sums or Σ-types, are pairs in which the second term's type may depend on the value of the first term.\nThey are closely related to the existential quantifier and Subtype.\nUnlike existentially quantified statements, dependent pairs are in the Type universe and are computationally relevant data.\nUnlike subtypes, the second term is also computationally relevant data.\nLike ordinary pairs, dependent pairs may be nested; this nesting is right-associative.\n\nDependent Pair TypesDependent pair types bind one or more variables, which are then in scope in the final term.\nIf there is one variable, then its type is a that of the first element in the pair and the final term is the type of the second element in the pair.\nIf there is more than one variable, the types are nested right-associatively.\nThe identifiers may also be _.\nWith parentheses, multiple bound variables may have different types, while the unparenthesized variant requires that all have the same type.\n\nNested Dependent Pair TypesThe typeΣ n k : Nat, Fin (n * k)\nis equivalent toΣ n : Nat, Σ k : Nat, Fin (n * k)\nand(n : Nat) × (k : Nat) × Fin (n * k)\nThe typeΣ (n k : Nat) (i : Fin (n * k)) , Fin i.val\nis equivalent toΣ (n : Nat), Σ (k : Nat), Σ (i : Fin (n * k)) , Fin i.val\nand(n : Nat) × (k : Nat) × (i : Fin (n * k)) × Fin i.val\nThe two styles of annotation cannot be mixed in a single Σ-type:Σ n k (i : Fin (n * k)) , Fin i.val\n<example>:1:5-1:7: unexpected token '('; expected ','\n\n\n\n\nDependent pairs are typically used in one of two ways:1. They can be used to “package” a concrete type index together with a value of the indexed family, used when the index value is not known ahead of time.\n    The type Σ n, Fin n is a pair of a natural number and some other number that's strictly smaller.\n    This is the most common way to use dependent pairs.2. The first element can be thought of as a “tag” that's used to select from among different types for the second term.\n    This is similar to the way that selecting a constructor of a sum type determines the types of the constructor's arguments.\n    For example, the typeΣ (b : Bool), if b then Unit else α\nis equivalent to Option α, where none is ⟨true, ()⟩ and some x is ⟨false, x⟩.\n    Using dependent pairs this way is uncommon, because it's typically much easier to define a special-purpose inductive type directly.\n\n\n\nDependent pairs, in which the second element's type depends on the value of the first element. The\ntype Sigma β is typically written Σ a : α, β a or (a : α) × β a.Although its values are pairs, Sigma is sometimes known as the dependent sum type, since it is\nthe type level version of an indexed summation.Constructs a dependent pair.Using this constructor in a context in which the type is not known usually requires a type\nascription to determine β. This is because the desired relationship between the two values can't\ngenerally be determined automatically.The first component of a dependent pair.The second component of a dependent pair. Its type depends on the first component.\n\nDependent Pairs with DataThe type Vector, which associates a known length with an array, can be placed in a dependent pair with the length itself.\nWhile this is logically equivalent to just using Array, this construction is sometimes necessary to bridge gaps in an API.def getNLinesRev : (n : Nat) → IO (Vector String n)\n  | 0 => pure #v[]\n  | n + 1 => do\n    let xs ← getNLinesRev n\n    return xs.push (← (← IO.getStdin).getLine)\n\ndef getNLines (n : Nat) : IO (Vector String n) := do\n  return (← getNLinesRev n).reverse\n\npartial def getValues : IO (Σ n, Vector String n) := do\n  let stdin ← IO.getStdin\n\n  IO.println \"How many lines to read?\"\n  let howMany ← stdin.getLine\n\n  if let some howMany := howMany.trim.toNat? then\n    return ⟨howMany, (← getNLines howMany)⟩\n  else\n    IO.eprintln \"Please enter a number.\"\n    getValues\n\ndef main : IO Unit := do\n  let values ← getValues\n  IO.println s!\"Got {values.fst} values. They are:\"\n  for x in values.snd do\n    IO.println x.trim\nWhen calling the program with this standard input:4\nApples\nQuince\nPlums\nRaspberries\nthe output is:How many lines to read?\nGot 4 values. They are:\nRaspberries\nPlums\nQuince\nApples\n\n\nDependent Pairs as SumsSigma can be used to implement sum types.\nThe Bool in the first projection of Sum' indicates which type the second projection is drawn from.def Sum' (α : Type) (β : Type) : Type :=\n  Σ (b : Bool),\n    match b with\n    | true => α\n    | false => β\nThe injections pair a tag (a Bool) with a value of the indicated type.\nAnnotating them with match_pattern allows them to be used in patterns as well as in ordinary terms.variable {α β : Type}\n\n@[match_pattern]\ndef Sum'.inl (x : α) : Sum' α β := ⟨true, x⟩\n\n@[match_pattern]\ndef Sum'.inr (x : β) : Sum' α β := ⟨false, x⟩\n\ndef Sum'.swap : Sum' α β → Sum' β α\n  | .inl x => .inr x\n  | .inr y => .inl y\n\n\nJust as Prod has a variant PProd that accepts propositions as well as types, PSigma allows its projections to be propositions.\nThis has the same drawbacks as PProd: it is much more likely to lead to failures of universe level unification.\nHowever, PSigma can be necessary when implementing custom proof automation or in some rare, advanced use cases.\n\nFully-Polymorphic Dependent Pair TypesThe rules for nesting Σ', as well as those that govern its binding structure, are the same as those for Σ.\n\nFully universe-polymorphic dependent pairs, in which the second element's type depends on the value\nof the first element and both types are allowed to be propositions. The type PSigma β is typically\nwritten Σ' a : α, β a or (a : α) ×' β a.In practice, this generality leads to universe level constraints that are difficult to solve, so\nPSigma is rarely used in manually-written code. It is usually only used in automation that\nconstructs pairs of arbitrary types.To pair a value with a proof that a predicate holds for it, use Subtype. To demonstrate that a\nvalue exists that satisfies a predicate, use Exists. A dependent pair with a proposition as its\nfirst component is not typically useful due to proof irrelevance: there's no point in depending on a\nspecific proof because all proofs are equal anyway.Constructs a fully universe-polymorphic dependent pair.The first component of a dependent pair.The second component of a dependent pair. Its type depends on the first component.\n\n","context":"Lean Reference\u0009Basic Types\u0009Tuples","header":"19.13.2. Dependent Pairs","id":"/Basic-Types/Tuples/#sigma-types"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Executable-Targets":{"contents":"A Lean executable's declarative configuration.The executable's name.The subdirectory of the package's source directory containing the executable's\nLean source file. Defaults simply to said srcDir.(This will be passed to lean as the -R option.)The root module of the binary executable.\nShould include a main definition that will serve\nas the entry point of the program.The root is built by recursively building its\nlocal imports (i.e., fellow modules of the workspace).Defaults to the name of the target.The name of the binary executable.\nDefaults to the target name with any . replaced with a -.An Array of targets to build before the executable's modules.Deprecated. Use needs instead.\nAn Array of target names to build before the executable's modules.Enables the executable to interpret Lean files (e.g., via\nLean.Elab.runFrontend) by exposing symbols within the  executable\nto the Lean interpreter.Implementation-wise, on Windows, the Lean shared libraries are linked\nto the executable and, on other systems, the executable is linked with\n-rdynamic. This increases the size of the binary on Linux and, on Windows,\nrequires libInit_shared.dll and libleanshared.dll to  be co-located\nwith the executable or part of PATH (e.g., via lake exe). Thus, this\nfeature should only be enabled when necessary.Defaults to false.The mode in which the modules should be built (e.g., debug, release).\nDefaults to release.An Array of additional options to pass to both the Lean language server\n(i.e., lean --server) launched by lake serve and to lean when compiling\na module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Additional arguments to pass to lean\nwhen compiling a module's Lean source files.Unlike moreLeanArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeanArgs.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Lake already passes some flags based on the buildType,\nbut you can change this by, for example, adding -O0 and -UNDEBUG.Additional options to pass to the Lean language server\n(i.e., lean --server) launched by lake serve.Additional arguments to pass to leanc\nwhen compiling a module's C source files generated by lean.Unlike moreLeancArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLeancArgs.Additional target objects to use when linking (both static and shared).\nThese will come after the paths of native facets.Additional target libraries to pass to leanc when linking\n(e.g., for shared libraries or binary executables).\nThese will come after the paths of other link objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Additional arguments to pass to leanc when linking (e.g., for shared\nlibraries or binary executables). These will come after the paths of\nthe linked objects.Unlike moreLinkArgs, these arguments do not affect the trace\nof the build result, so they can be changed without triggering a rebuild.\nThey come before moreLinkArgs.Asserts whether Lake should assume Lean modules are platform-independent.* If false, Lake will add System.Platform.target to the module traces\nwithin the code unit (e.g., package or library). This will force Lean code\nto be re-elaborated on different platforms.* If true, Lake will exclude platform-dependent elements\n(e.g., precompiled modules, external libraries) from a module's trace,\npreventing re-elaboration on different platforms. Note that this will not\neffect  modules outside the code unit in question. For example, a\nplatform-independent package which depends on a platform-dependent library\nwill still be platform-dependent.* If none, Lake will construct traces as natural. That is, it will include\nplatform-dependent artifacts in the trace if they module depends on them,\nbut otherwise not force modules to be platform-dependent.There is no check  for correctness here, so a configuration can lie\nand Lake will not catch it. Defaults to none.\n\nMinimal Executable TargetThis executable declaration supplies only a name:[[lean_exe]]\nname = \"trustworthytool\"\nThe executable's main function is expected in a module named trustworthytool.lean in the package's default source file path.\nThe resulting executable is named trustworthytool.\n\nConfigured Executable TargetThe name trustworthy-tool is not a valid Lean name due to the dash (-).\nTo use this name for an executable target, an explicit module root must be supplied.\nEven though trustworthy-tool is a perfectly acceptable name for an executable, the target also specifies that the result of compilation and linking should be named tt.[[lean_exe]]\nname = \"trustworthy-tool\"\nroot = \"TrustworthyTool\"\nexeName = \"tt\"\nThe executable's main function is expected in a module named TrustworthyTool.lean in the package's default source file path.\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Declarative TOML Format","header":"22.1.3.1.4. Executable Targets","id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Declarative-TOML-Format--Executable-Targets"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-other":{"contents":"rfl closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting).\n\nnorm_cast tactic in conv mode.\n\n","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","header":"13.6.7. Other","id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-other"},"/releases/v4.4.0/#release-v4___4___0":{"contents":"* Lake and the language server now support per-package server options using the moreServerOptions config field, as well as options that apply to both the language server and lean using the leanOptions config field. Setting either of these fields instead of moreServerArgs ensures that viewing files from a dependency uses the options for that dependency. Additionally, moreServerArgs is being deprecated in favor of the moreGlobalServerArgs field. See PR #2858.A Lakefile with the following deprecated package declaration:def moreServerArgs := #[\n  \"-Dpp.unicode.fun=true\"\n]\ndef moreLeanArgs := moreServerArgs\n\npackage SomePackage where\n  moreServerArgs := moreServerArgs\n  moreLeanArgs := moreLeanArgs\n... can be updated to the following package declaration to use per-package options:package SomePackage where\n  leanOptions := #[⟨`pp.unicode.fun, true⟩]\n* Rename request handler.* Import auto-completion.* `pp.beta`` to apply beta reduction when pretty printing.* Embed and check githash in .olean.* Guess lexicographic order for well-founded recursion.* Allow trailing comma in tuples, lists, and tactics.Bug fixes for #2628, #2883,\n#2810, #2925, and #2914.Lake:* lake init . and a bare lake init and will now use the current directory as the package name. #2890* lake new and lake init will now produce errors on invalid package names such as .., foo/bar, Init, Lean, Lake, and Main. See issue #2637 and PR #2890.* lean_lib no longer converts its name to upper camel case (e.g., lean_lib bar will include modules named bar.* rather than Bar.*). See issue #2567 and PR #2889.* Lean and Lake now properly support non-identifier library names (e.g., lake new 123-hello and import «123Hello» now work correctly). See issue #2865 and PR #2889.* Lake now filters the environment extensions loaded from a compiled configuration (lakefile.olean) to include only those relevant to Lake's workspace loading process. This resolves segmentation faults caused by environment extension type mismatches (e.g., when defining custom elaborators via elab in configurations). See issue #2632 and PR #2896.* Cloud releases will now properly be re-unpacked if the build directory is removed. See PR #2928.* Lake's math template has been simplified. See PR #2930.* lake exe <target> now parses target like a build target (as the help text states it should) rather than as a basic name. For example, lake exe @mathlib/runLinter should now work. See PR #2932.* lake new foo.bar [std] now generates executables named foo-bar and lake new foo.bar exe properly creates foo/bar.lean. See PR #2932.* Later packages and libraries in the dependency tree are now preferred over earlier ones. That is, the later ones \"shadow\" the earlier ones. Such an ordering is more consistent with how declarations generally work in programming languages. This will break any package that relied on the previous ordering. See issue #2548 and PR #2937.* Executable roots are no longer mistakenly treated as importable. They will no longer be picked up by findModule?. See PR #2937.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.4.0 (2023-12-31)","id":"/releases/v4.4.0/#release-v4___4___0"}});