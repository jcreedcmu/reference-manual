window.docContents[59].resolve({"/Basic-Types/Strings/#string-api-pos":{"contents":"A byte position in a String, according to its UTF-8 encoding.Character positions (counting the Unicode code points rather than bytes) are represented by plain\nNats. Indexing a String by a String.Pos takes constant time, while character positions need to\nbe translated internally to byte positions, which takes linear time.A byte position p is valid for a string s if 0 ≤ p ≤ s.endPos and p lies on a UTF-8\ncharacter boundary.Get the underlying byte index of a String.Pos\n\nReturns true if p is a valid UTF-8 position in the string s.This means that p ≤ s.endPos and p lies on a UTF-8 character boundary. At runtime, this\noperation takes constant time.Examples:* String.Pos.isValid \"abc\" ⟨0⟩ = true* String.Pos.isValid \"abc\" ⟨1⟩ = true* String.Pos.isValid \"abc\" ⟨3⟩ = true* String.Pos.isValid \"abc\" ⟨4⟩ = false* String.Pos.isValid \"𝒫(A)\" ⟨0⟩ = true* String.Pos.isValid \"𝒫(A)\" ⟨1⟩ = false* String.Pos.isValid \"𝒫(A)\" ⟨2⟩ = false* String.Pos.isValid \"𝒫(A)\" ⟨3⟩ = false* String.Pos.isValid \"𝒫(A)\" ⟨4⟩ = true\n\nReturns true if a specified byte position is greater than or equal to the position which points to\nthe end of a string. Otherwise, returns false.Examples:* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = false* (0 |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".next |> \"abc\".atEnd) = true* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = false* (0 |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".next |> \"L∃∀N\".atEnd) = true* \"abc\".atEnd ⟨4⟩ = true* \"L∃∀N\".atEnd ⟨7⟩ = false* \"L∃∀N\".atEnd ⟨8⟩ = true\n\nA UTF-8 byte position that points at the end of a string, just after the last character.* \"abc\".endPos = ⟨3⟩* \"L∃∀N\".endPos = ⟨8⟩\n\nReturns the next position in a string after position p. If p is not a valid position or\np = s.endPos, returns the position one byte after p.A run-time bounds check is performed to determine whether p is at the end of the string. If a\nbounds check has already been performed, use String.next' to avoid a repeated check.Some examples of edge cases:* \"abc\".next ⟨3⟩ = ⟨4⟩, since 3 = \"abc\".endPos* \"L∃∀N\".next ⟨2⟩ = ⟨3⟩, since 2 points into the middle of a multi-byte UTF-8 characterExamples:* \"abc\".get (\"abc\".next 0) = 'b'* \"L∃∀N\".get (0 |> \"L∃∀N\".next |> \"L∃∀N\".next) = '∀'\n\nReturns the next position in a string after position p. The result is unspecified if p is not a\nvalid position.Requires evidence, h, that p is within bounds. No run-time bounds check is performed, as in\nString.next.A typical pattern combines String.next' with a dependent if-expression to avoid the overhead of\nan additional bounds check. For example:def next? (s : String) (p : String.Pos) : Option Char :=\n  if h : s.atEnd p then none else s.get (s.next' p h)\nExample:* let abc := \"abc\"; abc.get (abc.next' 0 (by decide)) = 'b'\n\nRepeatedly increments a position in a string, as if by String.next, while the predicate p\nreturns true for the character at the position. Stops incrementing at the end of the string or\nwhen p returns false for the current character.Examples:* let s := \"   a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'* let s := \"a  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'a'* let s := \"ba  \"; s.get (s.nextWhile Char.isWhitespace 0) = 'b'\n\nRepeatedly increments a position in a string, as if by String.next, while the predicate p\nreturns false for the character at the position. Stops incrementing at the end of the string or\nwhen p returns true for the current character.Examples:* let s := \"   a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '* let s := \"   a  \"; s.get (s.nextUntil Char.isLetter 0) = 'a'* let s := \"a  \"; s.get (s.nextUntil Char.isWhitespace 0) = ' '\n\nReturns the position in a string before a specified position, p. If p = ⟨0⟩, returns 0. If p\nis greater than endPos, returns the position one byte before p. Otherwise, if p occurs in the\nmiddle of a multi-byte character, returns the beginning position of that character.For example, \"L∃∀N\".prev ⟨3⟩ is ⟨1⟩, since byte 3 occurs in the middle of the multi-byte\ncharacter '∃' that starts at byte 1.Examples:* \"abc\".get (\"abc\".endPos |> \"abc\".prev) = 'c'* \"L∃∀N\".get (\"L∃∀N\".endPos |> \"L∃∀N\".prev |> \"L∃∀N\".prev |> \"L∃∀N\".prev) = '∃'\n\nReturns either p₁ or p₂, whichever has the least byte index.\n\n","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","header":"19.8.4.4. Positions","id":"/Basic-Types/Strings/#string-api-pos"}});