window.docContents[36].resolve({"/releases/v4.22.0/#release-v4___22___0":{"id":"/releases/v4.22.0/#release-v4___22___0","header":"Lean 4.22.0 (2025-08-14)","context":"Lean Reference\u0009Release Notes","contents":"For this release, 468 changes landed. In addition to the 185 feature additions and 85 fixes listed below there were 15 refactoring changes, 5 documentation improvements, 4 performance improvements, 0 improvements to the test suite and 174 other changes.HighlightsGrind is released!Lean now includes a new SMT-style tactic grind, along with annotations for the Lean standard library.\ngrind ships theory-specific solvers, including cutsat (superseding omega, with model construction)\nand a new Gröbner basis solver.Also see the chapter on grind in the reference manual.New compilerThe old compiler has been replaced by the new compiler (#8577)!\nThis closes many long-standing issues, and lays the foundation for many\nfuture features and performance improvements.New math project template#8866 upgrades the math template for lake init and\nlake new to meet rigorous Mathlib maintenance standards.\nIn comparison with the previous version (now available as lake new ... math-lax), the new template automatically provides:* Strict linting options matching Mathlib.* GitHub workflow for automatic upgrades to newer Lean and Mathlib releases.* Automatic release tagging for toolchain upgrades.* API documentation generated by doc-gen4 and hosted on github.io.* README with some GitHub-specific instructions.Signature help#8511 implements signature help support in the editors.\nSee the demo in the PR description.Displaying import hierarchy#8654 (together with #620 for vscode-lean4) adds\na new module hierarchy component in\nVS Code that can be used to navigate both the import tree of a module\nand the imported-by tree of a module.Refactor of have/let semanticsTL;DR: nondependent let bindings are now transformed to have bindings for better performance.\nSyntax of have and let is unified, and new options are added.* #8373 enables transforming nondependent lets into haves\nso simp works better without zeta reduction. Disable with set_option cleanup.letToHave false.* #8804 implements first-class support for nondependent let expressions\nin the elaborator. This has been given full support throughout the metaprogramming interface and the\nelaborator.* #8914 modifies let and have term syntaxes to be consistent with\neach other. Adds configuration options; for example, have is\nequivalent to let +nondep, for nondependent lets. Other options\ninclude +usedOnly (for let_tmp), +zeta (for letI/haveI), and\n+postponeValue (for let_delayed). There is also let (eq := h) x := v; b\nfor introducing h : x = v when elaborating b. The eq option\nworks for pattern matching as well, for example let (eq := h) (x, y) := p; b.* #8935 adds the +generalize option to the let and have syntaxes.\nFor example, have +generalize n := a + b; body replaces all instances\nof a + b in the expected type with n when elaborating body. This\ncan be likened to a term version of the generalize tactic. One can\ncombine this with eq in have +generalize (eq := h) n := a + b; body\nas an analogue of generalize h : n = a + b.* #8954 adds a procedure that efficiently transforms let expressions\ninto have expressions (Meta.letToHave). This is exposed as the\nlet_to_have tactic.* #9086 deprecates let_fun syntax in favor of have and removes\nletFun support from WHNF and simp.Simp* Flagging unused simp arguments#8901 adds a linter (linter.unusedSimpArgs) that complains when a\nsimp argument (simp [foo]) is unused, with a clickable suggestion to remove it.\nHandles repeated simp calls correctly (e.g., inside all_goals), but skips macros.* Detection of possibly looping lemmas#8865 allows simp to recognize and warn about simp lemmas that are\nlikely looping in the current simp set. It does so automatically\nwhenever simplification fails with the dreaded “max recursion depth”\nerror, but it can be made to do it always with set_option linter.loopingSimpArgs true. This check is not on by default because it\nis somewhat costly, and can warn about simp calls that still happen to\nwork.* Faster simp via cache reuse#8880 makes simp consult\nits own cache more often, to avoid replicating work.* Explicit defeq attribute for dsimp#8419 introduces an explicit defeq attribute to mark theorems that\ncan be used by dsimp. The benefit of an explicit attribute over the\nprior logic of looking at the proof body is that we can reliably omit\ntheorem bodies across module boundaries. It also helps with intra-file\nparallelism.Named errors with explanationsLean now supports named error messages with associated explanations.#8649 and #8730 add\nmacro syntax for registering\nand throwing named errors, mechanisms for displaying error names in the Infoview and at the command line,\nand the ability to link to error explanations in the reference manual.This infrastructure lays the foundation for a searchable error index and improved diagnostics.finally section#8723 implements a finally section following a (potentially empty)\nwhere block. where ... finally opens a tactic sequence block in\nwhich the goals are the unassigned metavariables from the definition\nbody and its auxiliary definitions that arise from use of let rec and\nwhere.\nThis can be useful for discharging multiple proof obligations in the definition body\nby a single invocation of a tactic such as all_goals:example (i j : Nat) (xs : Array Nat) (hi : i < xs.size) (hj: j < xs.size) :=\n  match i with\n  | 0 => x\n  | _ => xs[i]'?_ + xs[j]'?_\nwhere x := 13\nfinally all_goals assumption\nPolymorphic ranges and slices#8784 introduces new syntax for ranges:\n1...*, 1...=3, 1...<3, 1<...=2, *...=3..#8947 extends this syntax to slices, allowing expressions like xs[*...end].Library highlightsNotable additions to the standard library are:* Iterators (#8420, #8545, #8615, #8629, #8768),* monadic interface for Async operations (#8003),* DNS functions (#8072),* system information functions (#8109).Experimental: monadic verification framework#8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:* mspec for applying Hoare triple specifications,* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditions.Experimental: module systemThe new module system (enabled by the module keyword before import statements) is available\nfor experimentation.Experimental: sharing oleans between different checkouts of the same repository#8922 introduces a local artifact cache for Lake. When enabled, Lake\nwill share build artifacts (built files) across different instances of\nthe same package using an input- and content-addressed cache. Requires export LAKE_ARTIFACT_CACHE=true for now.Warnings about sorrys#8662 adds a warn.sorry option (default true) that logs the\n\"declaration uses 'sorry'\" warning when declarations contain sorryAx.\nWhen false, the warning is not logged.Breaking changes* #8751 adds the nondep field of Expr.letE to the C++ data model.Breaking change: Expr.updateLet! is renamed to Expr.updateLetE!.* #8105 adds support for server-sided RpcRef reuse and fixes a bug\nwhere trace nodes in the InfoView would close while the file was still being processed.Breaking change: Since WithRpcRef is now capable of tracking its identity\nto decide which WithRpcRef usage constitutes a reuse, the constructor of\nWithRpcRef has been made private to discourage downstream users from\ncreating WithRpcRef instances with manually-set ids. Instead, WithRpcRef.mk\n(which lives in BaseIO) is now the preferred way to create WithRpcRef instances.* #8654 adds server-side support for a new module hierarchy component in\nVS Code.Breaking change: This PR augments the .ilean format with the direct imports of a file\nin order to implement the $/lean/moduleHierarchy/importedBy request and bumps the .ilean format version.* #8804 implements first-class support for nondependent let expressions\nin the elaborator.Breaking change: Uses of letLambdaTelescope/mkLetFVars need to use generalizeNondepLet := false;\nsee the PR description for more info.Language* #6672 filters out all declarations from Lean.*, *.Tactic.*, and\n*.Linter.* from the results of exact? and rw?.* #7395 changes the show t tactic to match its documentation.\nPreviously it was a synonym for change t, but now it finds the first\ngoal that unifies with the term t and moves it to the front of the\ngoal list.* #7639 changes the generated below and brecOn implementations for\nreflexive inductive types to support motives in Sort u rather than\nType u.* #8337 adjusts the experimental module system to not export any private\ndeclarations from modules.* #8373 enables transforming nondependent lets into haves in a\nnumber of contexts: the bodies of nonrecursive definitions, equation\nlemmas, smart unfolding definitions, and types of theorems. A motivation\nfor this change is that when zeta reduction is disabled, simp can only\neffectively rewrite have expressions (e.g. split uses simp with\nzeta reduction disabled), and so we cache the nondependence calculations\nby transforming lets to haves. The transformation can be disabled\nusing set_option cleanup.letToHave false.* #8387 improves the error messages produced by end and prevents\ninvalid end commands from closing scopes on failure.* #8419 introduces an explicit defeq attribute to mark theorems that\ncan be used by dsimp. The benefit of an explicit attribute over the\nprior logic of looking at the proof body is that we can reliably omit\ntheorem bodies across module boundaries. It also helps with intra-file\nparallelism.* #8519 makes the equational theorems of non-exposed defs private. If\nthe author of a module chose not to expose the body of their function,\nthen they likely don't want that implementation to leak through\nequational theorems. Helps with #8419.* #8543 adds typeclasses for grind to embed types into Int, for\ncutsat. This allows, for example, treating Fin n, or Mathlib's ℕ+ in\na uniform and extensible way.* #8568 modifies the structure elaborator to add local terminfo for\nstructure fields and explicit parent projections, enabling \"go to\ndefinition\" when there are dependent fields.* #8574 adds an additional diff mode to the error-message hint\nsuggestion widget that displays diffs per word rather than per\ncharacter.* #8596 makes guard_msgs.diff=true the default. The main usage of\n#guard_msgs is for writing tests, and this makes staring at altered\ntest outputs considerably less tiring.* #8609 uses grind to shorten some proofs in the LRAT checker. The\nintention is not particularly to improve the quality or maintainability\nof these proofs (although hopefully this is a side effect), but just to\ngive grind a work out.* #8619 fixes an internalization (aka preprocessing) issue in grind\nwhen applying injectivity theorems.* #8621 fixes a bug in the equality-resolution procedure used by\ngrind.\nThe procedure now performs a topological sort so that every simplified\ntheorem declaration is emitted before any place where it is\nreferenced.\nPreviously, applying equality resolution toh : ∀ x, p x a → ∀ y, p y b → x ≠ y\nin the exampleexample\n  (p : Nat → Nat → Prop)\n  (a b c : Nat)\n  (h  : ∀ x, p x a → ∀ y, p y b → x ≠ y)\n  (h₁ : p c a)\n  (h₂ : p c b) :\n  False := by\n  grind\ncaused grind to produce the incorrect termp ?y a → ∀ y, p y b → False\nThe patch eliminates this error, and the following correct simplified\ntheorem is generated∀ y, p y a → p y b → False\n* #8622 adds a test case / use case example for grind, setting up the\nvery basics of IndexMap, modelled on Rust's\nindexmap. It is not\nintended as a complete implementation: just enough to exercise grind.* #8625 improves the diagnostic information produced by grind when it\nsucceeds. We now include the list of case-splits performed, and the\nnumber of application per function symbol.* #8633 implements case-split tracking in grind. The information is\ndisplayed when grind fails or diagnostic information is requested.\nExamples:* Failure* #8637 adds background theorems for normalizing IntModule expressions\nusing reflection.* #8638 improves the diagnostic information produced by grind. It now\nsorts the equivalence classes by generation and then Expr. lt.* #8639 completes the ToInt family of typeclasses which grind will\nuse to embed types into the integers for cutsat. It contains instances\nfor the usual concrete data types (Fin, UIntX, IntX, BitVec),\nand is extensible (e.g. for Mathlib's PNat).* #8641 adds the #print sig $ident variant of the #print command,\nwhich omits the body. This is useful for testing meta-code, in the#guard_msgs (drop trace, all) in #print sig foo\nidiom. The benefit over #check is that it shows the declaration kind,\nreducibility attributes (and in the future more built-in attributes,\nlike @[defeq] in #8419). (One downside is that #check shows unused\nfunction parameter names, e.g. in induction principles; this could\nprobably be refined.)* #8645 adds many helper theorems for the future IntModule linear\narithmetic procedure in grind.\nIt also adds helper theorems for normalizing input atoms and support for\ndisequality in the new linear arithmetic procedure in grind.* #8650 adds helper theorems for coefficient normalization and equality\ndetection. This theorems are for the linear arithmetic procedure in\ngrind.* #8662 adds a warn.sorry option (default true) that logs the\n\"declaration uses 'sorry'\" warning when declarations contain sorryAx.\nWhen false, the warning is not logged.* #8670 adds helper theorems that will be used to interface the\nCommRing module with the linarith procedure in grind.* #8671 allow structures to have non-bracketed binders, making it\nconsistent with inductive.* #8677 adds the basic infrastructure for the linarith module in\ngrind.* #8680 adds the reify? and denoteExpr for the new linarith module\nin grind.* #8682 uses the CommRing module to normalize linarith inequalities.* #8687 implements the infrastructure for constructing proof terms in\nthe linarith procedure in grind. It also adds the ToExpr instances\nfor the reified objects.* #8689 implements proof term generation for the CommRing and\nlinarith interface. It also fixes the CommRing helper theorems.* #8690 implements the main framework of the model search procedure for\nthe linarith component in grind. It currently handles only inequalities.\nIt can already solve simple goals such asexample [IntModule α] [Preorder α] [IntModule.IsOrdered α] (a b c : α)\n    : a < b → b < c → c < a → False := by\n  grind\n\n* #8693 fixes the denotation functions used to interface the ring and\nlinarith modules in grind.* #8694 implements special support for One.one in linarith when the\nstructure is a ordered ring. It also fixes bugs during initialization.* #8697 implements support for inequalities in the grind linear\narithmetic procedure and simplifies its design. Some examples that can\nalready be solved:open Lean.Grind\nexample [IntModule α] [Preorder α] [IntModule.IsOrdered α] (a b c d : α)\n    : a + d < c → b = a + (2:Int)*d → b - d > c → False := by\n  grind\n\n* #8708 fixes an internalization bug in the interface between linarith\nand ring modules in grind. The CommRing module may create new terms\nduring normalization.* #8713 fixes a bug in the commutative ring module used in grind. It\nwas missing simplification opportunities.* #8715 implements the basic infrastructure for processing disequalities\nin the grind linarith module. We still have to implement backtracking.* #8723 implements a finally section following a (potentially empty)\nwhere block. where ... finally opens a tactic sequence block in\nwhich the goals are the unassigned metavariables from the definition\nbody and its auxiliary definitions that arise from use of let rec and\nwhere.* #8730 adds support for throwing named errors with associated error\nexplanations. In particular, it adds elaborators for the syntax defined\nin #8649, which use the error-explanation infrastructure added in #8651.\nThis includes completions, hovers, and jump-to-definition for error\nnames.* #8733 implements disequality splitting and non-chronological\nbacktracking for the grind linarith procedure.example [IntModule α] [LinearOrder α] [IntModule.IsOrdered α] (a b c d : α)\n    : a ≤ b → a - c ≥ 0 + d → d ≤ 0 → d ≥ 0 → b = c → a ≠ b → False := by\n  grind\n* #8751 adds the nondep field of Expr.letE to the C++ data model.\nPreviously this field has been unused, and in followup PRs the\nelaborator will use it to encode have expressions (non-dependent\nlets). The kernel does not verify that nondep is correctly applied\nduring typechecking. The letE delaborator now prints haves when\nnondep is true, though have still elaborates as letFun for now.\nBreaking change: Expr.updateLet! is renamed to Expr.updateLetE!.* #8753 fixes a bug in simp where it was not resetting the set of\nzeta-delta reduced let definitions between simp calls. It also fixes a\nbug where simp would report zeta-delta reduced let definitions that\nweren't given as simp arguments (these extraneous let definitions appear\ndue to certain processes temporarily setting zetaDelta := true). This\nPR also modifies the metaprogramming interface for the zeta-delta\ntracking functions to be re-entrant and to prevent this kind of no-reset\nbug from occurring again. Closes #6655.* #8756 implements counterexamples for grind linarith. Example:example [CommRing α] [LinearOrder α] [Ring.IsOrdered α] (a b c d : α)\n    : b ≥ 0 → c > b → d > b → a ≠ b + c → a > b + c → a < b + d →  False := by\n  grind\nproduces the counterexamplea := 7/2\nb := 1\nc := 2\nd := 3\n* #8759 implements model-based theory combination for grind linarith.\nExample:example [CommRing α] [LinearOrder α] [Ring.IsOrdered α] (f : α → α → α) (x y z : α)\n    : z ≤ x → x ≤ 1 → z = 1 → f x y = 2 → f 1 y = 2 := by\n  grind\n* #8763 corrects the handling of explicit monotonicity proofs for\nmutual partial_fixpoint definitions.* #8773 implements support for the heterogeneous (k : Nat) * (a : R)\nin ordered modules. Example:variable (R : Type u) [IntModule R] [LinearOrder R] [IntModule.IsOrdered R]\n\n* #8774 adds an option for disabling the cutsat procedure in grind.\nThe linarith module takes over linear integer/nat constraints. Example:set_option trace.grind.cutsat.assert true in -- cutsat should **not** process the following constraints\nexample (x y z : Int) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) : ¬ 12*y - 4* z < 0 := by\n  grind -cutsat -- `linarith` module solves it\n* #8775 adds a grind normalization theorem for Int.negSucc. Example:example (p : Int) (n : Nat) (hmp : Int.negSucc (n + 1) + 1 = p)\n    (hnm : Int.negSucc (n + 1 + 1) + 1 = Int.negSucc (n + 1)) : p = Int.negSucc n := by\n  grind\n* #8776 ensures that user provided natCast application are properly\ninternalized in the grind cutsat module.* #8777 implements basic Field support in the commutative ring module\nin grind. It is just division by numerals for now. Examples:open Lean Grind\n\n* #8780 makes Lean code generation respect the module name provided\nthrough lean --setup.* #8786 improves the support for fields in grind. New supported\nexamples:example [Field α] [IsCharP α 0] (x : α) : x ≠ 0 → (4 / x)⁻¹ * ((3 * x^3) / x)^2 * ((1 / (2 * x))⁻¹)^3 = 18 * x^8 := by grind\nexample [Field α] (a : α) : 2 * a ≠ 0 → 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] [IsCharP α 0] (a : α) : 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] [IsCharP α 0] (a b : α) : 2*b - a = a + b → 1 / a + 1 / (2 * a) = 3 / b := by grind\nexample [Field α] [NoNatZeroDivisors α] (a : α) : 1 / a + 1 / (2 * a) = 3 / (2 * a) := by grind\nexample [Field α] {x y z w : α} : x / y = z / w → y ≠ 0 → w ≠ 0 → x * w = z * y := by grind\nexample [Field α] (a : α) : a = 0 → a ≠ 1 := by grind\nexample [Field α] (a : α) : a = 0 → a ≠ 1 - a := by grind\n* #8789 implements the Rabinowitsch transformation for Field\ndisequalities in grind. For example, this transformation is necessary\nfor solving:example [Field α] (a : α) : a^2 = 0 → a = 0 := by\n  grind\n* #8791 ensures the grind linarith module is activated for any type\nthat implements only IntModule. That is, the type does not need to be\na preorder anymore.* #8792 makes the clear_value tactic preserve the order of variables\nin the local context. This is done by adding\nLean.MVarId.withRevertedFrom, which reverts all local variables\nstarting from a given variable, rather than only the ones that depend on\nit.* #8794 adds a module Lean.Util.CollectLooseBVars with a function\nExpr.collectLooseBVars that collects the set of loose bound variables\nin an expression. That is, it computes the set of all i such that\ne.hasLooseBVar i is true.* #8795 ensures that auxliary terms are not internalized by the ring and\nlinarith modules.* #8796 fixes grind linarith term internalization and support for\nHSMul.* #8798 adds the following instanceinstance [Field α] [LinearOrder α] [Ring.IsOrdered α] : IsCharP α 0\nThe goal is to ensure we do not perform unnecessary case-splits in our\ntest suite.* #8804 implements first-class support for nondependent let expressions\nin the elaborator; recall that a let expression let x : t := v; b is\ncalled nondependent if fun x : t => b typechecks, and the notation\nfor a nondependent let expression is have x := v; b. Previously we\nencoded have using the letFun function, but now we make use of the\nnondep flag in the Expr.letE constructor for the encoding. This has\nbeen given full support throughout the metaprogramming interface and the\nelaborator. Key changes to the metaprogramming interface:* Local context ldecls with nondep := true are generally treated as\ncdecls. This is because in the body of a have expression the\nvariable is opaque. Functions like LocalDecl.isLet by default return\nfalse for nondependent ldecls. In the rare case where it is needed,\nthey take an additional optional allowNondep : Bool flag (defaults to\nfalse) if the variable is being processed in a context where the value\nis relevant.* Functions such as mkLetFVars by default generalize nondependent let\nvariables and create lambda expressions for them. The\ngeneralizeNondepLet flag (default true) can be set to false if have\nexpressions should be produced instead. Breaking change: Uses of\nletLambdaTelescope/mkLetFVars need to use generalizeNondepLet := false. See the next item.* There are now some mapping functions to make telescoping operations\nmore convenient. See mapLetTelescope and mapLambdaLetTelescope.\nThere is also mapLetDecl as a counterpart to withLetDecl for\ncreating let/have expressions.* Important note about the generalizeNondepLet flag: it should only be\nused for variables in a local context that the metaprogram \"owns\". Since\nnondependent let variables are treated as constants in most cases, the\nvalue field might refer to variables that do not exist, if for example\nthose variables were cleared or reverted. Using mapLetDecl is always\nfine.* The simplifier will cache its let dependence calculations in the\nnondep field of let expressions.* The intro tactic still produces dependent local variables. Given\nthat the simplifier will transform lets into haves, it would be\nsurprising if that would prevent intro from creating a local variable\nwhose value cannot be used.* #8809 introduces the basic theory of ordered modules over Nat (i.e.\nwithout subtraction), for grind. We'll solve problems here by\nembedding them in the IntModule envelope.* #8810 implements equality elimination in grind linarith. The current\nimplementation supports only IntModule and IntModule +\nNoNatZeroDivisors* #8813 adds some basic lemmas about grind internal notions of\nmodules.* #8815 refactors the way simp arguments are elaborated: Instead of\nchanging the SimpTheorems structure as we go, this elaborates each\nargument to a more declarative description of what it does, and then\napply those. This enables more interesting checks of simp arguments that\nneed to happen in the context of the eventually constructed simp context\n(the checks in #8688), or after simp has run (unused argument linter\n#8901).* #8828 extends the experimental module system to support resolving\nprivate names imported (transitively) through import all.* #8835 defines the embedding of a CommSemiring into its CommRing\nenvelope, injective when the CommSemiring is cancellative. This will\nbe used by grind to prove results in Nat.* #8836 generalizes #8835 to the noncommutative case, allowing us to\nembed a Lean.Grind.Semiring into a Lean.Grind.Ring.* #8845 implements the proof-by-reflection infrastructure for embedding\nsemiring terms as ring ones.* #8847 relaxes the assumptions for Lean.Grind.IsCharP from Ring to\nSemiring, and provides an alternative constructor for rings.* #8848 generalizes the internal grind instanceinstance [Field α] [LinearOrder α] [Ring.IsOrdered α] : IsCharP α 0\ntoinstance [Ring α] [Preorder α] [Ring.IsOrdered α] : IsCharP α 0\n* #8855 refactors Lean.Grind.NatModule/IntModule/Ring.IsOrdered.* #8859 shows the equivalence between Lean.Grind.NatModule.IsOrdered\nand Lean.Grind.IntModule.IsOrdered over an IntModule.* #8865 allows simp to recognize and warn about simp lemmas that are\nlikely looping in the current simp set. It does so automatically\nwhenever simplification fails with the dreaded “max recursion depth”\nerror fails, but it can be made to do it always with set_option linter.loopingSimpArgs true. This check is not on by default because it\nis somewhat costly, and can warn about simp calls that still happen to\nwork.* #8874 skips attempting to compute a module name from the file name and\nroot directory (i.e., lean -R) if a name is already provided via lean --setup.* #8880 makes simp consult its own cache more often, to avoid\nreplicating work.* #8882 adds @[expose] annotations to terms that appear in grind\nproof certificates, so grind can be used in the module system. It's\npossible/likely that I haven't identified all of them yet.* #8890 adds doc-strings to the Lean.Grind algebra typeclasses, as\nthese will appear in the reference manual explaining how to extend\ngrind algebra solvers to new types. Also removes some redundant\nfields.* #8892 corrects the pretty printing of grind modifiers. Previously\n@[grind →] was being pretty printed as @[grind→ ] (Space on the\nright of the symbol, rather than left.) This fixes the pretty printing\nof attributes, and preserves the presence of spaces after the symbol in\nthe output of grind?.* #8893 fixes a bug in the dvd propagation function in cutsat.* #8901 adds a linter (linter.unusedSimpArgs) that complains when a\nsimp argument (simp [foo]) is unused. It should do the right thing if\nthe simp invocation is run multiple times, e.g. inside all_goals. It\ndoes not trigger when the simp call is inside a macro. The linter\nmessage contains a clickable hint to remove the simp argument.* #8903 make sure that the local instance cache calculation applies more\nreductions. In #2199 there was an issue where metavariables could\nprevent local variables from being considered as local instances. We use\na slightly different approach that ensures that, for example, lets at\nthe ends of telescopes do not cause similar problems. These reductions\nwere already being calculated, so this does not require any additional\nwork to be done.* #8909 refactors the NoNatZeroDivisors to make sure it will work with\nthe new Semiring support.* #8910 adds the NoNatZeroDivisors instance for OfSemiring.Q α* #8913 cleans up grind's internal order typeclasses, removing\nunnecessary duplication.* #8914 modifies let and have term syntaxes to be consistent with\neach other. Adds configuration options; for example, have is\nequivalent to let +nondep, for nondependent lets. Other options\ninclude +usedOnly (for let_tmp), +zeta (for letI/haveI), and\n+postponeValue (for let_delayed). There is also let (eq := h) x := v; b for introducing h : x = v when elaborating b. The eq option\nworks for pattern matching as well, for example let (eq := h) (x, y) := p; b.* #8918 fixes the guard_msgs.diff default behavior so that the default\nspecified in the option definition is actually used everywhere.* #8921 implements support for (commutative) semirings in grind. It\nuses the Grothendieck completion to construct a (commutative) ring\nLean.Grind.Ring.OfSemiring.Q α from a (commutative) semiring α. This\nconstruction is mostly useful for semirings that implement\nAddRightCancel α. Otherwise, the function toQ is not injective.\nExamples:example (x y : Nat) : x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind\n\n* #8935 adds the +generalize option to the let and have syntaxes.\nFor example, have +generalize n := a + b; body replaces all instances\nof a + b in the expected type with n when elaborating body. This\ncan be likened to a term version of the generalize tactic. One can\ncombine this with eq in have +generalize (eq := h) n := a + b; body\nas an analogue of generalize h : n = a + b.* #8937 changes the output universe of the generated below\nimplementation for non-reflexive inductive types to match the\nimplementation for reflexive inductive types in #7639.* #8940 introduces antitonicity lemmas that support the elaboration of\nmixed inductive-coinductive predicates defined using the\nleast_fixpoint / greatest_fixpoint constructs.* #8943 adds helper theorems for normalizing semirings that do not\nimplement AddRightCancel.* #8953 implements support for normalization for commutative semirings\nthat do not implement AddRightCancel. Examples:variable (R : Type u) [CommSemiring R]\n\n* #8954 adds a procedure that efficiently transforms let expressions\ninto have expressions (Meta.letToHave). This is exposed as the\nlet_to_have tactic.* #8955 fixes Lean.MVarId.deltaLocalDecl, which previously replaced\nthe local definition with the target.* #8957 adds configuration options to the let/have tactic syntaxes.\nFor example, let (eq := h) x := v adds h : x = v to the local\ncontext. The configuration options are the same as those for the\nlet/have term syntaxes.* #8958 improves the case splitting strategy used in grind, and\nensures grind also considers simple match-conditions for\ncase-splitting. Example:example (x y : Nat)\n    : 0 < match x, y with\n          | 0, 0   => 1\n          | _, _ => x + y := by -- x or y must be greater than 0\n  grind\n* #8959 add instances showing that the Grothendieck (i.e. additive)\nenvelope of a semiring is an ordered ring if the original semiring is\nordered (and satisfies ExistsAddOfLE), and in this case the embedding is\nmonotone.* #8963 embeds a NatModule into its IntModule completion, which is\ninjective when we have AddLeftCancel, and monotone when the modules are\nordered. Also adds some (failing) grind test cases that can be verified\nonce grind uses this embedding.* #8964 adds @[expose] attributes to proof terms constructed by\ngrind that need to be evaluated in the kernel.* #8965 revises @[grind] annotations on Nat bitwise operations.* #8968 adds the following features to simp:* A routine for simplifying have telescopes in a way that avoids\nquadratic complexity arising from locally nameless expression\nrepresentations, like what #6220 did for letFun telescopes.\nFurthermore, simp converts letFuns into haves (nondependent lets),\nand we remove the #6220 routine since we are moving away from letFun\nencodings of nondependent lets.* A +letToHave configuration option (enabled by default) that converts\nlets into haves when possible, when -zeta is set. Previously Lean\nwould need to do a full typecheck of the bodies of lets, but the\nletToHave procedure can skip checking some subexpressions, and it\nmodifies the lets in an entire expression at once rather than one at a\ntime.* A +zetaHave configuration option, to turn off zeta reduction of\nhaves specifically. The motivation is that dependent lets can only\nbe dsimped by let, so zeta reducing just the dependent lets is a\nreasonable way to make progress. The +zetaHave option is also added to\nthe meta configuration.* When simp is zeta reducing, it now uses an algorithm that avoids\ncomplexity quadratic in the depth of the let telescope.* Additionally, the zeta reduction routines in simp, whnf, and\nisDefEq now all are consistent with how they apply the zeta,\nzetaHave, and zetaUnused configurations.* #8971 fixes linter.simpUnusedSimpArgs to check the syntax kind, to\nnot fire on simp calls behind macros. Fixes #8969* #8973 refactors the juggling of universes in the linear\nnoConfusionType construction: Instead of using PUnit.{…} →  in the\nto get the branches of withCtorType to the same universe level, we use\nPULift.* #8978 updates the solveMonoStep function used in the monotonicity\ntactic to check for definitional equality between the current goal and\nthe monotonicity proof obtained from a recursive call. This ensures\nsoundness by preventing incorrect applications when\nLean.Order.PartialOrder instances differ—an issue that can arise with\nmutual blocks defined using the partial_fixpoint keyword, where\ndifferent Lean.Order.CCPO structures may be involved.* #8980 improves the consistency of error message formatting by\nrendering addenda of several existing error messages as labeled notes\nand hints.* #8983 fixes a bug in congruence proof generation in grind for\nover-applied functions.* #8986 improves the error messages produced by invalid projections and\nfield notation. It also adds a hint to the \"function expected\" error\nmessage noting the argument to which the term is being applied, which\ncan be helpful for debugging spurious \"function expected\" messages\nactually caused by syntax errors.* #8991 adds some missing ToInt.X typeclass instances for grind.* #8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:* mspec for applying Hoare triple specifications* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditoins (i.e., without any traces of Hoare triples\nor weakest preconditions reminiscent of prog). The resulting\nverification conditions in the stateful logic of Std.Do.SPred can be\ndischarged manually with the tactics coming with its custom proof mode\nor with automation such as simp and grind.* #8996 provides the remaining instances for the Lean.Grind.ToInt\ntypeclasses.* #9004 ensures that type-class synthesis failure errors in interpolated\nstrings are displayed at the interpolant at which they occurred.* #9005 changes the definition of Lean.Grind.ToInt.OfNat, introducing\na wrap on the right-hand-side.* #9008 implements the basic infrastructure for the generic ToInt\nsupport in cutsat.* #9022 completes the generic toInt infrastructure for embedding terms\nimplementing the ToInt type classes into Int.* #9026 implements support for (non strict) ToInt inequalities in\ngrind cutsat. grind cutsat can solve simple problems such as:example (a b c : Fin 11) : a ≤ b → b ≤ c → a ≤ c := by\n  grind\n\n* #9030 fixes a couple of bootstrapping-related hiccups in the newly\nadded Std.Do module. More precisely,* #9035 extends the list of acceptable characters to all the french ones\nas well as some others,\nby adding characters from the Latin-1-Supplement add Latin-Extended-A\nunicode block.* #9038 adds test cases for the VC generator and implements a few small\nand tedious fixes to ensure they pass.* #9041 makes mspec detect more viable assignments by rfl instead of\ngenerating a VC.* #9044 adjusts the experimental module system to make private the\ndefault visibility modifier in modules, introducing public as a new\nmodifier instead. public section can be used to revert the default for\nan entire section, though this is more intended to ease gradual adoption\nof the new semantics such as in Init (and soon Std) where they\nshould be replaced by a future decl-by-decl re-review of visibilities.* #9045 fixes a type error in mvcgen and makes it turn fewer natural\ngoals into synthetic opaque ones, so that tactics such as trivial may\ninstantiate them more easily.* #9048 implements support for strict inequalities in the ToInt\nadapter used in grind cutsat. Example:example (a b c : Fin 11) : c ≤ 9 → a ≤ b → b < c → a < c + 1 := by\n  grind\n* #9050 ensures the ToInt bounds are asserted for every toInt a\napplication internalized in grind cutsat.* #9051 implements support for equalities and disequalities in grind cutsat. We still have to improve the encoding. Examples:example (a b c : Fin 11) : a ≤ 2 → b ≤ 3 → c = a + b → c ≤ 5 := by\n  grind\n\n* #9057 introduces a simple variable-reordering heuristic for cutsat.\nIt is needed by the ToInt adapter to support finite types such as\nUInt64. The current encoding into Int produces large coefficients,\nwhich can enlarge the search space when an unfavorable variable order is\nused. Example:example (a b c : UInt64) : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n* #9059 adds helper theorems for normalizing coefficients in rings of\nunknown characteristic.* #9062 implements support for equations <num> = 0 in rings and fields\nof unknown characteristic. Examples:example [Field α] (a : α) : (2 * a)⁻¹ = a⁻¹ / 2 := by grind\n\n* #9065 improves the counterexamples produced by the cutsat procedure\nin grind when using the ToInt gadget.* #9067 adds a docstring for the grind tactic.* #9069 implements support for the type class LawfulEqCmp. Examples:example (a b c : Vector (List Nat) n)\n    : b = c → a.compareLex (List.compareLex compare) b = o → o = .eq → a = c := by\n  grind\n\n* #9073 copies #9069 to handle ReflCmp the same way; we need to call\nthis in propagateUp rather than propagateDown.* #9074 uses the commutative ring module to normalize nonlinear\npolynomials in grind cutsat. Examples:example (a b : Nat) (h₁ : a + 1 ≠ a * b * a) (h₂ : a * a * b ≤ a + 1) : b * a^2 < a + 1 := by\n  grind\n\n* #9076 adds an unexpander for OfSemiring.toQ. This an auxiliary\nfunction used by the ring module in grind, but we want to reduce the\nclutter in the diagnostic information produced by grind. Example:example [CommSemiring α] [AddRightCancel α] [IsCharP α 0] (x y : α)\n    : x^2*y = 1 → x*y^2 = y → x + y = 2 → False := by\n  grind\nproduces  [ring] Ring `Ring.OfSemiring.Q α` ▼\n    [basis] Basis ▼\n      [_] ↑x + ↑y + -2 = 0\n      [_] ↑y + -1 = 0\n* #9086 deprecates let_fun syntax in favor of have and removes\nletFun support from WHNF and simp.* #9087 removes the irreducible attribute from letFun, which is one\nstep toward removing special letFun support; part of #9086.\n\nLibrary* #8003 adds a new monadic interface for Async operations.* #8072 adds DNS functions to the standard library* #8109 adds system information functions to the standard library* #8178 provides a compact formula for the MSB of the sdiv. Most of the\nwork in the PR involves handling the corner cases of division\noverflowing (e.g. intMin / -1 = intMin)* #8203 adds trichotomy lemmas for unsigned and signed comparisons,\nstating that only one of three cases may happen: either x < y, x = y, or x > y (for both signed and unsigned comparsions). We use\nexplicit arguments so that users can write rcases slt_trichotomy x y with hlt | heq | hgt.* #8205 adds a simp lemma that simplifies T-division where the numerator\nis a Nat into an E-division:@[simp] theorem ofNat_tdiv_eq_ediv {a : Nat} {b : Int} : (a : Int).tdiv b = a / b :=\n   tdiv_eq_ediv_of_nonneg (by simp)\n* #8210 adds an equivalence relation to tree maps akin to the existing\none for hash maps. In order to get many congruence lemmas to eventually\nuse for defining functions on extensional tree maps, almost all of the\nremaining tree map functions have also been given lemmas to relate them\nto list functions, although these aren't currently used to prove lemmas\nother than congruence lemmas.* #8253 adds toInt_smod and auxilliary lemmas necessary for its proof\n(msb_intMin_umod_neg_of_msb_true,\nmsb_neg_umod_neg_of_msb_true_of_msb_true, toInt_dvd_toInt_iff,\ntoInt_dvd_toInt_iff_of_msb_true_msb_false,\ntoInt_dvd_toInt_iff_of_msb_false_msb_true,\nneg_toInt_neg_umod_eq_of_msb_true_msb_true, toNat_pos_of_ne_zero,\ntoInt_umod_neg_add, toInt_sub_neg_umod and\nBitVec.[lt_of_msb_false_of_msb_true, msb_umod_of_msb_false_of_ne_zero,\nneg_toInt_neg])* #8420 provides the iterator combinator drop that transforms any\niterator into one that drops the first n elements.* #8534 fixes IO.FS.realPath on windows to take symbolic links into\naccount.* #8545 provides the means to reason about \"equivalent\" iterators.\nSimply speaking, two iterators are equivalent if they behave the same as\nlong as consumers do not introspect their states.* #8546 adds a new BitVec.clz operation and a corresponding clz\ncircuit to bv_decide, allowing to bitblast the count leading zeroes\noperation. The AIG circuit is linear in the number of bits of the\noriginal expression, making the bitblasting convenient wrt. rewriting.\nclz is common in numerous compiler intrinsics (see\nhere)\nand architectures (see\nhere).* #8573 avoids the likely unexpected behavior of removeDirAll to\ndelete through symlinks and adds the new function\nIO.FS.symlinkMetadata.* #8585 makes the lemma BitVec.extractLsb'_append_eq_ite more usable\nby using the \"simple case\" more often, and uses this simplification to\nmake BitVec.extractLsb'_append_eq_of_add_lt stronger, renaming it to\nBitVec.extractLsb'_append_eq_of_add_le.* #8587 adjusts the grind annotation on\nStd.HashMap.map_fst_toList_eq_keys and variants, so grind can reason\nbidirectionally between m.keys and m.toList.* #8590 adds @[grind] to getElem?_pos and variants.* #8615 provides a special empty iterator type. Although its behavior\ncan be emulated with a list iterator (for example), having a special\ntype has the advantage of being easier to optimize for the compiler.* #8620 removes the NatCast (Fin n) global instance (both the direct\ninstance, and the indirect one via Lean.Grind.Semiring), as that\ninstance causes causes x < n (for x : Fin k, n : Nat) to be\nelaborated as x < ↑n rather than ↑x < n, which is undesirable. Note\nhowever that in Mathlib this happens anyway!* #8629 replaces special, more optimized IteratorLoop instances, for\nwhich no lawfulness proof has been made, with the verified default\nimplementation. The specialization of the loop/collect implementations\nis low priority, but having lawfulness instances for all iterators is\nimportant for verification.* #8631 generalizes Std.Sat.AIG. relabel(Nat)_unsat_iff to allow the\nAIG type to be empty. We generalize the proof, by showing that in the\ncase when α is empty, the environment doesn't matter, since all\nenvironments α → Bool are isomorphic.* #8640 adds BitVec.setWidth'_eq to bv_normalize such that\nbv_decide can reduce it and solve lemmas involving setWidth'_eq* #8669 makes unsafeBaseIO noinline. The new compiler is better at\noptimizing Result-like types, which can cause the final operation in\nan unsafeBaseIO block to be dropped, since unsafeBaseIO is\ndiscarding the state.* #8678 makes the LHS of isSome_finIdxOf? and isNone_finIdxOf? more\ngeneral.* #8703 corrects the IteratorLoop instance in DropWhile, which\npreviously triggered for arbitrary iterator types.* #8719 adds grind annotations for\nList/Array/Vector.eraseP/erase/eraseIdx. It also adds some missing\nlemmas.* #8721 adds the types Std.ExtDTreeMap, Std.ExtTreeMap and\nStd.ExtTreeSet of extensional tree maps and sets. These are very\nsimilar in construction to the existing extensional hash maps with one\nexception: extensional tree maps and sets provide all functions from\nregular tree maps and sets. This is possible because in contrast to hash\nmaps, tree maps are always ordered.* #8734 adds the missing instanceinstance decidableExistsFin (P : Fin n → Prop) [DecidablePred P] : Decidable (∃ i, P i)\n* #8740 introduces associativity rules and preservation of (umul, smul, uadd, sadd)Overflowflags.* #8741 adds annotations for\nList/Array/Vector.find?/findSome?/idxOf?/findIdx?.* #8742 fixes a bug where the single-quote character Char.ofNat 39\nwould delaborate as ''', which causes a parse error if pasted back in\nto the source code.* #8745 adds a logic of stateful predicates SPred to Std.Do in order\nto support reasoning about monadic programs. It comes with a dedicated\nproof mode the tactics of which are accessible by importing\nStd.Tactic.Do.* #8747 adds grind annotations for `List/Array/Vector.finRange`\ntheorems.* #8748 adds grind annotations for Array/Vector.mapIdx and mapFinIdx\ntheorems.* #8749 adds grind annotations for List/Array/Vector.ofFn theorems and\nadditional List.Impl find operations.* #8750 adds grind annotations for the\nList/Array/Vector.zipWith/zipWithAll/unzip functions.* #8765 adds grind annotations for List.Perm; involves a revision of\ngrind annotations for List.countP/count as well.* #8768 introduces a ForIn' instance and a size function for\niterators in a minimal fashion. The ForIn' instance is not marked as\nan instance because it is unclear which Membership relation is\nsufficiently useful. The ForIn' instance existing as a def and\ninducing the ForIn instance, it becomes possible to provide more\nspecialized ForIn' instances, with nice Membership relations, for\nvarious types of iterators. The size function has no lemmas yet.* #8784 introduces ranges that are polymorphic, in contrast to the\nexisting Std.Range which only supports natural numbers.* #8805 continues adding grind annotations for List/Array/Vector\nlemmas.* #8808 adds the missing le_of_add_left_le {n m k : Nat} (h : k + n ≤ m) : n ≤ m and le_add_left_of_le {n m k : Nat} (h : n ≤ m) : n ≤ k + m.* #8811 adds theorems BitVec.(toNat, toInt, toFin)_shiftLeftZeroExtend, completing the API for\nBitVec.shiftLeftZeroExtend.* #8826 corrects the definition of Lean.Grind.NatModule, which wasn't\npreviously useful.* #8827 renames BitVec.getLsb' to BitVec.getLsb, now that older\ndeprecated definition occupying that name has been removed. (Similarly\nfor BitVec.getMsb'.)* #8829 avoids importing all of BitVec.Lemmas and BitVec.BitBlast\ninto UInt.Lemmas. (They are still imported into SInt.Lemmas; this\nseems much harder to avoid.)* #8830 rearranges files under Init.Grind, moving out instances for\nconcrete algebraic types in Init.GrindInstances.* #8849 adds grind annotations for Sum.* #8850 adds grind annotations for Prod.* #8851 adds grind annotations for Function.curry/uncurry.* #8852 adds grind annotations for Nat.testBit and bitwise operations\non Nat.* #8853 adds grind annotations relating Nat.fold/foldRev/any/all and\nFin.foldl/foldr/foldlM/foldrM to the corresponding operations on\nList.finRange.* #8877 adds grind annotations for\nList/Array/Vector.attach/attachWith/pmap.* #8878 adds grind annotations for List/Array/Vector monadic functions.* #8886 adds IO.FS.Stream.readToEnd which parallels\nIO.FS.Handle.readToEnd along with its upstream definitions (i.e.,\nreadBinToEndInto and readBinToEnd). It also removes an unnecessary\npartial from IO.FS.Handle.readBinToEnd.* #8887 generalizes IO.FS.lines with IO.FS.Handle.lines and adds the\nparallel IO.FS.Stream.lines for streams.* #8897 simplifies some simp calls.* #8905 uses the linter from\nhttps://github.com/leanprover/lean4/pull/8901 to clean up simp\narguments.* #8920 uses the linter from #8901 to clean up more simp arguments,\ncompleting #8905.* #8928 adds a logic of stateful predicates SPred to Std.Do in order to\nsupport reasoning about monadic programs. It comes with a dedicated\nproof mode the tactics of which are accessible by importing\nStd.Tactic.Do.* #8941 adds BitVec.(getElem, getLsbD, getMsbD)_(smod, sdiv, srem)\ntheorems to complete the API for sdiv, srem, smod. Even though the\nrhs is not particularly succint (it's hard to find a meaning for what it\nmeans to have \"the n-th bit of the result of a signed division/modulo\noperation\"), these lemmas prevent the need to unfold of operations.* #8947 introduces polymorphic slices in their most basic form. They\ncome with a notation similar to the new range notation. Subarray is\nnow also a slice and can produce an iterator now. It is intended to\nmigrate more operations of Subarray to the Slice wrapper type to\nmake them available for slices of other types, too.* #8950 adds BitVec.toFin_(sdiv, smod, srem) and BitVec.toNat_srem.\nThe strategy for the rhs of the toFin_* lemmas is to consider what\nthe corresponding toNat_* theorems do and push the toFin closerto\nthe operands. For the rhs of BitVec.toNat_srem I used the same\nstrategy as BitVec.toNat_smod.* #8967 both adds initial @[grind] annotations for BitVec, and uses\ngrind to remove many proofs from BitVec/Lemmas.* #8974 adds BitVec.msb_(smod, srem).* #8977 adds a generic MonadLiftT Id m instance. We do not implement a\nMonadLift Id m instance because it would slow down instance resolution\nand because it would create more non-canonical instances. This change\nmakes it possible to iterate over a pure iterator, such as [1, 2, 3].iter, in arbitrary monads.* #8992 adds PULift, a more general form of ULift and PLift that\nsubsumes both.* #8995 introduces a Hoare logic for monadic programs in\nStd.Do.Triple, and assorted tactics:* mspec for applying Hoare triple specifications* mvcgen to turn a Hoare triple proof obligation ⦃P⦄ prog ⦃Q⦄ into\npure verification conditoins (i.e., without any traces of Hoare triples\nor weakest preconditions reminiscent of prog). The resulting\nverification conditions in the stateful logic of Std.Do.SPred can be\ndischarged manually with the tactics coming with its custom proof mode\nor with automation such as simp and grind.* #9027 provides an iterator combinator that lifts the emitted values\ninto a higher universe level via ULift. This combinator is then used\nto make the subarray iterators universe-polymorphic. Previously, they\nwere only available for Subarray α if α : Type.* #9030 fixes a couple of bootstrapping-related hiccups in the newly\nadded Std.Do module. More precisely,* #9038 adds test cases for the VC generator and implements a few small\nand tedious fixes to ensure they pass.* #9049 proves that the default toList, toListRev and toArray\nfunctions on slices can be described in terms of the slice iterator.\nRelying on new lemmas for the uLift and attachWith iterator\ncombinators, a more concrete description of said functions is given for\nSubarray.* #9054 corrects some inconsistencies in TreeMap/HashMap grind\nannotations, for isSome_get?_eq_contains and empty_eq_emptyc.* #9055 renames Array/Vector.extract_push to extract_push_of_le, and\nreplaces the lemma with one without a side condition.* #9058 provides a ToStream instance for slices so that they can be\nused in for i in xs, j in ys do notation.* #9075 adds BEq instances for ByteArray and FloatArray (also a\nDecidableEq instance for ByteArray).Compiler* #8594 removes incorrect optimizations for strictOr/strictAnd from the\nold compiler, along with deleting an incorrect test. In order to do\nthese optimizations correctly, nontermination analysis is required.\nArguably, the correct way to express these optimizations is by exposing\nthe implementation of strictOr/strictAnd to a nontermination-aware phase\nof the compiler, and then having them follow from more general\ntransformations.* #8595 wraps the invocation of the new compiler in withoutExporting.\nThis is not necessary for the old compiler because it uses more direct\naccess to the kernel environment.* #8602 adds support to the new compiler for Eq.recOn (which is\nsupported by the old compiler but missing a test).* #8604 adds support for the compiler.extract_closed option to the new\ncompiler, since this is used by the definition of unsafeBaseIO. We'll\nrevisit this once we switch to the new compiler and rethink its\nrelationship with IO.* #8614 implements constant folding for toNat in the new compiler,\nwhich improves parity with the old compiler.* #8616 adds constant folding for Nat.pow to the new compiler,\nfollowing the same limits as the old compiler.* #8618 implements LCNF constant folding for Nat.nextPowerOfTwo.* #8634 makes hasTrivialStructure? return false for types whose\nconstructors have types that are erased, e.g. if they construct a\nProp.* #8636 adds a function called lean_setup_libuv that initializes\nrequired LIBUV components. It needs to be outside of\nlean_initialize_runtime_module because it requires argv and argc\nto work correctly.* #8647 improves the precision of the new compiler's noncomputable\ncheck for projections. There is no test included because while this was\nreduced from Mathlib, the old compiler does not correctly handle the\nreduced test case. It's not entirely clear to me if the check is passing\nwith the old compiler for correct reasons. A test will be added to the\nnew compiler's branch.* #8675 increases the precision of the new compiler's non computable\ncheck, particularly around irrelevant uses of noncomputable defs in\napplications.* #8681 adds an optimization to the LCNF simp pass where the\ndiscriminant of a cases construct will only be mark used if it has a\nnon-default alternative.* #8683 adds an optimization to the LCNF simp pass where the\ndiscriminant of a single-alt cases is only marked as used if any param\nis used.* #8709 handles constants with erased types in toMonoType. It is much\nharder to write a test case for this than you would think, because most\nreferences to such types get replaced with lcErased earlier.* #8712 optimizes let decls of an erased type to an erased value.\nSpecialization can create local functions that produce a Prop, and\nthere's no point in keeping them around.* #8716 makes any type application of an erased term to be erased. This\ncomes up a bit more than one would expect in the implementation of Lean\nitself.* #8717 uses the fvar substitution mechanism to replace erased code.\nThis isn't entirely satisfactory, since LCNF's .return doesn't support\na general Arg (which has a .erased constructor), it only supports an\nFVarId. This is in contrast to the IR .ret, which does support a\ngeneral Arg.* #8729 changes LCNF's FVarSubst to use Arg rather than Expr. This\nenforces the requirements on substitutions, which match the requirements\non Arg.* #8752 fixes an issue where the extendJoinPointContext pass can lift\njoin points containing projections to the top level, as siblings of\ncases constructs matching on other projections of the same base value.\nThis prevents the structProjCases pass from projecting both at once,\nextending the lifetime of the parent value and breaking linearity at\nruntime.* #8754 changes the implementation of computed fields in the new\ncompiler, which should enable more optimizations (and remove a\nquestionable hack in toLCNF that was only suitable for bringup). We\nconvert casesOn to cases like we do for other inductive types, all\nconstructors get replaced by their real implementations late in the base\nphase, and then the cases expression is rewritten to use the real\nconstructors in toMono.* #8758 adds caching for the hasTrivialStructure? function for LCNF\ntypes. This is one of the hottest small functions in the new compiler,\nso adding a cache makes a lot of sense.* #8764 changes the LCNF pass pipeline so checks are no longer run by\ndefault after every pass, only after init, saveBase, toMono and\nsaveMono. This is a compile time improvement, and the utility of these\nchecks is decreased a bit after the decision to no longer attempt to\npreserve types throughout compilation. They have not been a significant\nway to discover issues during development of the new compiler.* #8802 fixes a bug in floatLetIn where if one decl (e.g. a join\npoint) is floated into a case arm and it uses another decl (e.g. another\njoin point) that does not have any other existing uses in that arm, then\nthe second decl does not get floated in despite this being perfectly\nlegal. This was causing artificial array linearity issues in\nLean.Elab.Tactic.BVDecide.LRAT.trim.useAnalysis.* #8816 adds constant folding for Char.ofNat in LCNF simp. This\nimplicitly relies on the representation of Char as UInt32 rather\nthan making a separate .char literal type, which seems reasonable as\nChar is erased by the trivial structure optimization in toMono.* #8822 adds a cache for constructor info in toIR. This is called for\nall constructors, projections, and cases alternatives, so it makes sense\nto cache.* #8825 improves IR generation for constructors of inductive types that\nare represented by scalars. Surprisingly, this isn't required for\ncorrectness, because the boxing pass will fix it up. The extra unbox\noperation it inserts shouldn't matter when compiling to native code,\nbecause it's trivial for a C compiler to optimize, but it does matter\nfor the interpreter.* #8831 caches the result of lowerEnumToScalarType, which is used\nheavily in LCNF to IR conversion.* #8885 removes an old workaround around non-implemented C++11 features\nin the thread finalization.* #8923 implements casesOn for Thunk and Task. Since these are\nbuiltin types, this needs to be special-cased in toMono.* #8952 fixes the handling of the never_extract attribute in the\ncompiler's CSE pass. There is an interesting debate to be had about\nexactly how hard the compiler should try to avoid duplicating anything\nthat transitively uses never_extract, but this is the simplest form\nand roughly matches the check in the old compiler (although due to\ndifferent handling of local function decls in the two compilers, the\nconsequences might be slightly different).* #8956 changes toLCNF to stop caching translations of expressions\nupon seeing an expression marked never_extract. This is more\ncoarse-grained than it needs to be, but it is difficult to do any\nbetter, as the new compiler's Expr cache is based on structural\nidentity (rather than the pointer identity of the old compiler).* #9003 implements the validity check for the type of main in the new\ncompiler. There were no tests for this, so it slipped under the radar.Pretty Printing* #7954 improves pp.oneline, where it now preserves tags when\ntruncating formatted syntax to a single line. Note that the [...]\ncontinuation does not yet have any functionality to enable seeing the\nuntruncated syntax. Closes #3681.* #8617 fixes (1) an issue where private names are not unresolved when\nthey are pretty printed, (2) an issue where in pp.universes mode names\nwere allowed to shadow local names, (3) an issue where in match\npatterns constants shadowing locals wouldn't use _root_, and (4) an\nissue where tactics might have an incorrect \"try this\" when\npp.fullNames is set. Adds more delaboration tests for name\nunresolution.* #8626 closes #3791, making sure that the Syntax formatter inserts\nwhitespace before and after comments in the leading and trailing text of\nSyntax to avoid having comments comment out any following syntax, and to\navoid comments' lexical syntax from being interpreted as being part of\nanother syntax. If the text contains newlines before or after any\ncomments, they are formatted as hard newlines rather than soft newlines.\nFor example, -- comments will have a hard newline after them. Note:\nmetaprograms generating Syntax with comments should be sure to include\nnewlines at the ends of -- comments.Documentation* #8934 adds explanations for a few errors concerning noncomputability,\nredundant match alternatives, and invalid inductive declarations.* #8990 adds missing doc-strings for grind's internal algebra\ntypeclasses, for inclusion in the reference manual.* #8998 makes the docstrings related to Format and Repr have\nconsistent formatting and style, and adds missing docstrings.Server* #8105 adds support for server-sided RpcRef reuse and fixes a bug\nwhere trace nodes in the InfoView would close while the file was still\nbeing processed.* #8511 implements signature help support. When typing a function\napplication, editors with support for signature help will now display a\npopup that designates the current (remaining) function type. This\nremoves the need to remember the function signature while typing the\nfunction application, or having to constantly cycle between hovering\nover the function identifier and typing the application. In VS Code, the\nsignature help can be triggered manually using Ctrl+Shift+Space.* #8654 adds server-side support for a new module hierarchy component in\nVS Code that can be used to navigate both the import tree of a module\nand the imported-by tree of a module. Specifically, it implements new\nrequests $/lean/prepareModuleHierarchy,\n$/lean/moduleHierarchy/imports and\n$/lean/moduleHierarchy/importedBy. These requests are not supported by\nstandard LSP. Companion PR at\nleanprover/vscode-lean4#620.* #8699 adds support to the server for the new module setup process by\nchanging how lake setup-file is used.* #8868 ensures that code actions do not have to wait for the full file\nto elaborate. This regression was accidentally introduced in #7665.* #9019 fixes a bug where semantic highlighting would only highlight\nkeywords that started with an alphanumeric character. Now, it uses\nLean.isIdFirst.Lake* #7738 makes memoization of built-in facets toggleable through a\nmemoize option on the facet configuration. Built-in facets which are\nessentially aliases (e.g., default, o) have had memoization\ndisabled.* #8447 makes use of lean --setup in Lake builds of Lean modules and\nadds Lake support for the new .olean artifacts produced by the module\nsystem.* #8613 changes the Lake version syntax (to 5.0.0-src+<commit>) to\nensure it is a well-formed SemVer,* #8656 enables auto-implicits in the Lake math template. This resolves\nan issue where new users sometimes set up a new project for math\nformalization and then quickly realize that none of the code samples in\nour official books and docs that use auto-implicits work in their\nprojects. With the introduction of inlay hints for\nauto-implicits, we\nconsider the auto-implicit UX to be sufficiently usable that they can be\nenabled by default in the math template.\nNotably, this change does not affect Mathlib itself, which will proceed\nto disable auto-implicits.* #8701 exports LeanOption in the Lean namespace from the Lake\nnamespace. LeanOption was moved from Lean to Lake in #8447, which\ncan cause unnecessary breakage without this.* #8736 partially reverts #8024 which introduced a significant Lake\nperformance regression during builds. Once the cause is discovered and\nfixed, a similar PR will be made to revert this.* #8846 reintroduces the basics of lean --setup integration into Lake\nwithout the module computation which is still undergoing performance\ndebugging in #8787.* #8866 upgrades the math template for lake init and lake new to\nconfigures the new project to meet rigorous Mathlib maintenance\nstandards. In comparison with the previous version (now available as\nlake new ... math-lax), this automatically provides:* Strict linting options matching Mathlib.* GitHub workflow for automatic upgrades to newer Lean and Mathlib\nreleases.* Automatic release tagging for toolchain upgrades.* API documentation generated by\ndoc-gen4 and hosted on\ngithub.io.* README with some GitHub-specific instructions.* #8922 introduces a local artifact cache for Lake. When enabled, Lake\nwill shared build artifacts (built files) across different instances of\nthe same package using an input- and content-addressed cache.* #8981 removes Lake's usage of lean -R and moduleNameOfFileName to\npass module names to Lean. For workspace names, it now relies on\ndirectly passing the module name through lean --setup. For\nnon-workspace modules passed to lake lean or lake setup-file, it\nuses a fixed module name of _unknown.* #9068 fixes some bugs with the local Lake artifact cache and cleans up\nthe surrounding API. It also adds the ability to opt-in to the cache on\npackages without enableArtifactCache set using the\nLAKE_ARTIFACT_CACHE environment variable.* #9081 fixes a bug with Lake where the job monitor would sit on a\ntop-level build (e.g., mathlib/Mathlib:default) instead of reporting\nmodule build progress.* #9101 fixes a bug introduce by #9081 where the source file was dropped\nfrom the module input trace and some entries were dropped from the\nmodule job log.Other* #8702 enhances the PR release workflow to create both short format and\nSHA-suffixed release tags. Creates both pr-release-{PR_NUMBER} and\npr-release-{PR_NUMBER}-{SHORT_SHA} tags, generates separate releases for\nboth formats, adds separate GitHub status checks, and updates\nBatteries/Mathlib testing branches to use SHA-suffixed tags for exact\ncommit traceability.* #8710 pins the precise hash of softprops/action-gh-release to* #9033 adds a Mathlib-like testing and feedback system for the\nreference manual. Lean PRs will receive comments that reflect the status\nof the language reference with respect to the PR.* #9092 further updates release automation. The per-repository update\nscripts script/release_steps.py now actually performs the tests,\nrather than outputting a script for the release manager to run line by\nline. It's been tested on v4.21.0 (i.e. the easy case of a stable\nrelease), and we'll debug its behaviour on v4.22.0-rc1 tonight.\n\n"},"/releases/v4.13.0/#release-v4___13___0":{"id":"/releases/v4.13.0/#release-v4___13___0","header":"Lean 4.13.0 (2024-11-01)","context":"Lean Reference\u0009Release Notes","contents":"Full Changelog: https://github.com/leanprover/lean4/compare/v4.12.0...v4.13.0Language features, tactics, and metaprograms* structure command* #5511 allows structure parents to be type synonyms.* #5531 allows default values for structure fields to be noncomputable.* rfl and apply_rfl tactics* #3714, #3718 improve the rfl tactic and give better error messages.* #3772 makes rfl no longer use kernel defeq for ground terms.* #5329 tags Iff.refl with @[refl] (@Parcly-Taxel)* #5359 ensures that the rfl tactic tries Iff.rfl (@Parcly-Taxel)* unfold tactic* #4834 let unfold do zeta-delta reduction of local definitions, incorporating functionality of the Mathlib unfold_let tactic.* omega tactic* #5382 fixes spurious error in #5315* #5523 supports Int.toNat* simp tactic* #5479 lets simp apply rules with higher-order patterns.* induction tactic* #5494 fixes induction’s \"pre-tactic\" block to always be indented, avoiding unintended uses of it.* ac_nf tactic* #5524 adds ac_nf, a counterpart to ac_rfl, for normalizing expressions with respect to associativity and commutativity. Tests it with BitVec expressions.* bv_decide* #5211 makes extractLsb' the primitive bv_decide understands, rather than extractLsb (@alexkeizer)* #5365 adds bv_decide diagnoses.* #5375 adds bv_decide normalization rules for ofBool (a.getLsbD i) and ofBool a[i] (@alexkeizer)* #5423 enhances the rewriting rules of bv_decide* #5433 presents the bv_decide counterexample at the API* #5484 handles BitVec.ofNat with Nat fvars in bv_decide* #5506, #5507 add bv_normalize rules.* #5568 generalize the bv_normalize pipeline to support more general preprocessing passes* #5573 gets bv_normalize up-to-date with the current BitVec rewrites* Cleanups: #5408, #5493, #5578* Elaboration improvements* #5266 preserve order of overapplied arguments in elab_as_elim procedure.* #5510 generalizes elab_as_elim to allow arbitrary motive applications.* #5283, #5512 refine how named arguments suppress explicit arguments. Breaking change: some previously omitted explicit arguments may need explicit _ arguments now.* #5376 modifies projection instance binder info for instances, making parameters that are instance implicit in the type be implicit.* #5402 localizes universe metavariable errors to let bindings and fun binders if possible. Makes \"cannot synthesize metavariable\" errors take precedence over unsolved universe level errors.* #5419 must not reduce ite in the discriminant of match-expression when reducibility setting is .reducible* #5474 have autoparams report parameter/field on failure* #5530 makes automatic instance names about types with hygienic names be hygienic.* Deriving handlers* #5432 makes Repr deriving instance handle explicit type parameters* Functional induction* #5364 adds more equalities in context, more careful cleanup.* Linters* #5335 fixes the unused variables linter complaining about match/tactic combinations* #5337 fixes the unused variables linter complaining about some wildcard patterns* Other fixes* #4768 fixes a parse error when .. appears with a . on the next line* Metaprogramming* #3090 handles level parameters in Meta.evalExpr (@eric-wieser)* #5401 instance for Inhabited (TacticM α) (@alexkeizer)* #5412 expose Kernel.check for debugging purposes* #5556 improves the \"invalid projection\" type inference error in inferType.* #5587 allows MVarId.assertHypotheses to set BinderInfo and LocalDeclKind.* #5588 adds MVarId.tryClearMany', a variant of MVarId.tryClearMany.Language server, widgets, and IDE extensions* #5205 decreases the latency of auto-completion in tactic blocks.* #5237 fixes symbol occurrence highlighting in VS Code not highlighting occurrences when moving the text cursor into the identifier from the right.* #5257 fixes several instances of incorrect auto-completions being reported.* #5299 allows auto-completion to report completions for global identifiers when the elaborator fails to provide context-specific auto-completions.* #5312 fixes the server breaking when changing whitespace after the module header.* #5322 fixes several instances of auto-completion reporting non-existent namespaces.* #5428 makes sure to always report some recent file range as progress when waiting for elaboration.Pretty printing* #4979 make pretty printer escape identifiers that are tokens.* #5389 makes formatter use the current token table.* #5513 use breakable instead of unbreakable whitespace when formatting tokens.Library* #5222 reduces allocations in Json.compress.* #5231 upstreams Zero and NeZero* #5292 refactors Lean.Elab.Deriving.FromToJson (@arthur-adjedj)* #5415 implements Repr Empty (@TomasPuverle)* #5421 implements To/FromJSON Empty (@TomasPuverle)* Logic* #5263 allows simplifying dite_not/decide_not with only Decidable (¬p).* #5268 fixes binders on ite_eq_left_iff* #5284 turns off Inhabited (Sum α β) instances* #5355 adds simp lemmas for LawfulBEq* #5374 add Nonempty instances for products, allowing more partial functions to elaborate successfully* #5447 updates Pi instance names* #5454 makes some instance arguments implicit* #5456 adds heq_comm* #5529 moves @[simp] from exists_prop' to exists_prop* Bool* #5228 fills gaps in Bool lemmas* #5332 adds notation ^^ for Bool.xor* #5351 removes _root_.and (and or/not/xor) and instead exports/uses Bool.and (etc.).* BitVec* #5240 removes BitVec simps with complicated RHS* #5247 BitVec.getElem_zeroExtend* #5248 simp lemmas for BitVec, improving confluence* #5249 removes @[simp] from some BitVec lemmas* #5252 changes BitVec.intMin/Max from abbrev to def* #5278 adds BitVec.getElem_truncate (@tobiasgrosser)* #5281 adds udiv/umod bitblasting for bv_decide (@bollu)* #5297 BitVec unsigned order theoretic results* #5313 adds more basic BitVec ordering theory for UInt* #5314 adds toNat_sub_of_le (@bollu)* #5357 adds BitVec.truncate lemmas* #5358 introduces BitVec.setWidth to unify zeroExtend and truncate (@tobiasgrosser)* #5361 some BitVec GetElem lemmas* #5385 adds BitVec.ofBool_[and|or|xor]_ofBool theorems (@tobiasgrosser)* #5404 more of BitVec.getElem_* (@tobiasgrosser)* #5410 BitVec analogues of Nat.{mul_two, two_mul, mul_succ, succ_mul} (@bollu)* #5411 BitVec.toNat_{add,sub,mul_of_lt} for BitVector non-overflow reasoning (@bollu)* #5413 adds _self, _zero, and _allOnes for BitVec.[and|or|xor] (@tobiasgrosser)* #5416 adds LawCommIdentity + IdempotentOp for BitVec.[and|or|xor] (@tobiasgrosser)* #5418 decidable quantifers for BitVec* #5450 adds BitVec.toInt_[intMin|neg|neg_of_ne_intMin] (@tobiasgrosser)* #5459 missing BitVec lemmas* #5469 adds BitVec.[not_not, allOnes_shiftLeft_or_shiftLeft, allOnes_shiftLeft_and_shiftLeft] (@luisacicolini)* #5478 adds BitVec.(shiftLeft_add_distrib, shiftLeft_ushiftRight) (@luisacicolini)* #5487 adds sdiv_eq, smod_eq to allow sdiv/smod bitblasting (@bollu)* #5491 adds BitVec.toNat_[abs|sdiv|smod] (@tobiasgrosser)* #5492 BitVec.(not_sshiftRight, not_sshiftRight_not, getMsb_not, msb_not) (@luisacicolini)* #5499 BitVec.Lemmas - drop non-terminal simps (@tobiasgrosser)* #5505 unsimps BitVec.divRec_succ'* #5508 adds BitVec.getElem_[add|add_add_bool|mul|rotateLeft|rotateRight… (@tobiasgrosser)* #5554 adds Bitvec.[add, sub, mul]_eq_xor and width_one_cases (@luisacicolini)* List* #5242 improve naming for List.mergeSort lemmas* #5302 provide mergeSort comparator autoParam* #5373 fix name of List.length_mergeSort* #5377 upstream map_mergeSort* #5378 modify signature of lemmas about mergeSort* #5245 avoid importing List.Basic without List.Impl* #5260 review of List API* #5264 review of List API* #5269 remove HashMap's duplicated Pairwise and Sublist* #5271 remove @[simp] from List.head_mem and similar* #5273 lemmas about List.attach* #5275 reverse direction of List.tail_map* #5277 more List.attach lemmas* #5285 List.count lemmas* #5287 use boolean predicates in List.filter* #5289 List.mem_ite_nil_left and analogues* #5293 cleanup of List.findIdx / List.take lemmas* #5294 switch primes on List.getElem_take* #5300 more List.findIdx theorems* #5310 fix List.all/any lemmas* #5311 fix List.countP lemmas* #5316 List.tail lemma* #5331 fix implicitness of List.getElem_mem* #5350 List.replicate lemmas* #5352 List.attachWith lemmas* #5353 List.head_mem_head?* #5360 lemmas about List.tail* #5391 review of List.erase / List.find lemmas* #5392 List.fold / attach lemmas* #5393 List.fold relators* #5394 lemmas about List.maximum?* #5403 theorems about List.toArray* #5405 reverse direction of List.set_map* #5448 add lemmas about List.IsPrefix (@Command-Master)* #5460 missing List.set_replicate_self* #5518 rename List.maximum? to max?* #5519 upstream List.fold lemmas* #5520 restore @[simp] on List.getElem_mem etc.* #5521 List simp fixes* #5550 List.unattach and simp lemmas* #5594 induction-friendly List.min?_cons* Array* #5246 cleanup imports of Array.Lemmas* #5255 split Init.Data.Array.Lemmas for better bootstrapping* #5288 rename Array.data to Array.toList* #5303 cleanup of List.getElem_append variants* #5304 Array.not_mem_empty* #5400 reorganization in Array/Basic* #5420 make Array functions either semireducible or use structural recursion* #5422 refactor DecidableEq (Array α)* #5452 refactor of Array* #5458 cleanup of Array docstrings after refactor* #5461 restore @[simp] on Array.swapAt!_def* #5465 improve Array GetElem lemmas* #5466 Array.foldX lemmas* #5472 @[simp] lemmas about List.toArray* #5485 reverse simp direction for toArray_concat* #5514 Array.eraseReps* #5515 upstream Array.qsortOrd* #5516 upstream Subarray.empty* #5526 fix name of Array.length_toList* #5527 reduce use of deprecated lemmas in Array* #5534 cleanup of Array GetElem lemmas* #5536 fix Array.modify lemmas* #5551 upstream Array.flatten lemmas* #5552 switch obvious cases of array \"bang\"[]! indexing to rely on hypothesis (@TomasPuverle)* #5577 add missing simp to Array.size_feraseIdx* #5586 Array/Option.unattach* Option* #5272 remove @[simp] from Option.pmap/pbind and add simp lemmas* #5307 restoring Option simp confluence* #5354 remove @[simp] from Option.bind_map* #5532 Option.attach* #5539 fix explicitness of Option.mem_toList* Nat* #5241 add @[simp] to Nat.add_eq_zero_iff* #5261 Nat bitwise lemmas* #5262 Nat.testBit_add_one should not be a global simp lemma* #5267 protect some Nat bitwise theorems* #5305 rename Nat bitwise lemmas* #5306 add Nat.self_sub_mod lemma* #5503 restore @[simp] to upstreamed Nat.lt_off_iff* Int* #5301 rename Int.div/mod to Int.tdiv/tmod* #5320 add ediv_nonneg_of_nonpos_of_nonpos to DivModLemmas (@sakehl)* Fin* #5250 missing lemma about Fin.ofNat'* #5356 Fin.ofNat' uses NeZero* #5379 remove some @[simp]s from Fin lemmas* #5380 missing Fin @[simp] lemmas* HashMap* #5244 (DHashMap|HashMap|HashSet).(getKey?|getKey|getKey!|getKeyD)* #5362 remove the last use of Lean.(HashSet|HashMap)* #5369 HashSet.ofArray* #5370 HashSet.partition* #5581 Singleton/Insert/Union instances for HashMap/Set* #5582 HashSet.all/any* #5590 adding Insert/Singleton/Union instances for HashMap/Set.Raw* #5591 HashSet.Raw.all/any* Monads* #5463 upstream some monad lemmas* #5464 adjust simp attributes on monad lemmas* #5522 more monadic simp lemmas* Simp lemma cleanup* #5251 remove redundant simp annotations* #5253 remove Int simp lemmas that can't fire* #5254 variables appearing on both sides of an iff should be implicit* #5381 cleaning up redundant simp lemmasCompiler, runtime, and FFI* #4685 fixes a typo in the C run_new_frontend signature* #4729 has IR checker suggest using noncomputable* #5143 adds a shared library for Lake* #5437 removes (syntactically) duplicate imports (@euprunin)* #5462 updates src/lake/lakefile.toml to the adjusted Lake build process* #5541 removes new shared libs before build to better support Windows* #5558 make lean.h compile with MSVC (@kant2002)* #5564 removes non-conforming size-0 arrays (@eric-wieser)Lake* Reservoir build cache. Lake will now attempt to fetch a pre-built copy of the package from Reservoir before building it. This is only enabled for packages in the leanprover or leanprover-community organizations on versions indexed by Reservoir. Users can force Lake to build packages from the source by passing --no-cache on the CLI or by setting the  LAKE_NO_CACHE environment variable to true. #5486, #5572, #5583, #5600, #5641, #5642.* #5504 lake new and lake init now produce TOML configurations by default.* #5878 fixes a serious issue where Lake would delete path dependencies when attempting to cleanup a dependency required with an incorrect name.* Breaking changes* #5641 A Lake build of target within a package will no longer build a package's dependencies package-level extra target dependencies. At the technical level, a package's extraDep facet no longer transitively builds its dependencies’ extraDep facets (which include their extraDepTargets).Documentation fixes* #3918 @[builtin_doc] attribute (@digama0)* #4305 explains the borrow syntax (@eric-wieser)* #5349 adds documentation for groupBy.loop (@vihdzp)* #5473 fixes typo in BitVec.mul docstring (@llllvvuu)* #5476 fixes typos in Lean.MetavarContext* #5481 removes mention of Lean.withSeconds (@alexkeizer)* #5497 updates documentation and tests for toUIntX functions (@TomasPuverle)* #5087 mentions that inferType does not ensure type correctness* Many fixes to spelling across the doc-strings, (@euprunin): #5425 #5426 #5427 #5430  #5431 #5434 #5435 #5436 #5438 #5439 #5440 #5599Changes to CI* #5343 allows addition of release-ci label via comment (@thorimur)* #5344 sets check level correctly during workflow (@thorimur)* #5444 Mathlib's lean-pr-testing-NNNN branches should use Batteries' lean-pr-testing-NNNN branches* #5489 commit lake-manifest.json when updating lean-pr-testing branches* #5490 use separate secrets for commenting and branching in pr-release.yml\n\n"},"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal":{"id":"/Tactic-Proofs/Tactic-Reference/#The-Lean-Language-Reference--Tactic-Proofs--Tactic-Reference--Verification-Condition-Generation--Tactics-for-Stateful-Goals-in--Std___Do___SPred--Proving-a-Stateful-Goal","header":"13.5.23.1.2. Proving a Stateful Goal","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Verification Condition Generation\u0009Tactics for Stateful Goals in  Std.Do.SPred","contents":"mspec is an apply-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.Given a stateful goal H ⊢ₛ wp⟦prog⟧ Q', mspec foo_spec will instantiate\nfoo_spec : ... → ⦃P⦄ foo ⦃Q⦄, match foo against prog and produce subgoals for\nthe verification conditions ?pre : H ⊢ₛ P and ?post : Q ⊢ₚ Q'.* If prog = x >>= f, then mspec Specs.bind is tried first so that foo is matched against x\ninstead. Tactic mspec_no_bind does not attempt to do this decomposition.* If ?pre or ?post follow by .rfl, then they are discharged automatically.* ?post is automatically simplified into constituent ⊢ₛ entailments on\nsuccess and failure continuations.* ?pre and ?post.* goals introduce their stateful hypothesis under an inaccessible name.\nYou can give it a name with the mrename_i tactic.* Any uninstantiated MVar arising from instantiation of foo_spec becomes a new subgoal.* If the target of the stateful goal looks like fun s => _ then mspec will first mintro ∀s.* If P has schematic variables that can be instantiated by doing mintro ∀s, for example\nfoo_spec : ∀(n:Nat), ⦃fun s => ⌜n = s⌝⦄ foo ⦃Q⦄, then mspec will do mintro ∀s first to\ninstantiate n = s.* Right before applying the spec, the mframe tactic is used, which has the following effect:\nAny hypothesis Hᵢ in the goal h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T that is\npure (i.e., equivalent to some ⌜φᵢ⌝) will be moved into the pure context as hᵢ:φᵢ.Additionally, mspec can be used without arguments or with a term argument:* mspec without argument will try and look up a spec for x registered with @[spec].* mspec (foo_spec blah ?bleh) will elaborate its argument as a term with expected type\n⦃?P⦄ x ⦃?Q⦄ and introduce ?bleh as a subgoal.\nThis is useful to pass an invariant to e.g., Specs.forIn_list and leave the inductive step\nas a hole.\n\nLike intro, but introducing stateful hypotheses into the stateful context of the Std.Do.SPred\nproof mode.\nThat is, given a stateful goal (hᵢ : Hᵢ)* ⊢ₛ P → T, mintro h transforms\ninto (hᵢ : Hᵢ)*, (h : P) ⊢ₛ T.Furthermore, mintro ∀s is like intro s, but preserves the stateful goal.\nThat is, mintro ∀s brings the topmost state variable s:σ in scope and transforms\n(hᵢ : Hᵢ)* ⊢ₛ T (where the entailment is in Std.Do.SPred (σ::σs)) into\n(hᵢ : Hᵢ s)* ⊢ₛ T s (where the entailment is in Std.Do.SPred σs).Beyond that, mintro supports the full syntax of mcases patterns\n(mintro pat = (mintro h; mcases h with pat), and can perform multiple\nintroductions in sequence.\n\nmexact is like exact, but operating on a stateful Std.Do.SPred goal.example (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n\n\nmassumption is like assumption, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n\n\nLike refine, but operating on stateful Std.Do.SPred goals.example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n\n\nmconstructor is like constructor, but operating on a stateful Std.Do.SPred goal.example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor <;> mexact HQ\n\n\nmleft is like left, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n\n\nmright is like right, but operating on a stateful Std.Do.SPred goal.example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n\n\nmexists is like exists, but operating on a stateful Std.Do.SPred goal.example (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n\n\nmpure_intro operates on a stateful Std.Do.SPred goal of the form P ⊢ₛ ⌜φ⌝.\nIt leaves the stateful proof mode (thereby discarding P), leaving the regular goal φ.theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n\n\nmexfalso is like exfalso, but operating on a stateful Std.Do.SPred goal.example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n\n\n"},"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp--Examples":{"id":"/Error-Explanations/lean___projNonPropFromProp/#The-Lean-Language-Reference--Error-Explanations--lean___projNonPropFromProp--Examples","header":"Examples","context":"Lean Reference\u0009Error Explanations\u0009lean.projNonPropFromProp","contents":"Attempting to use index projection on existential proofexample (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > 0 :=\n  ⟨h.1, Nat.lt_of_succ_lt h.2⟩\nInvalid projection: Cannot project a value of non-propositional type\n  Nat\nfrom the expression\n  h\nwhich has propositional type\n  ∃ x, x > a + 1\nexample (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > a :=\n  let ⟨w, hw⟩ := h\n  ⟨w, Nat.lt_of_succ_lt hw⟩\nexample (a : Nat) (h : ∃ x : Nat, x > a + 1) : ∃ x : Nat, x > a := by\n  cases h with\n  | intro w hw =>\n    exists w\n    omega\nThe witness associated with a proof of an existential proposition cannot be extracted using an\nindex projection. Instead, it is necessary to use a pattern match: either a term like a let\nbinding or a tactic like cases.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Targets":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Targets","header":"22.1.3.2.4.4. Custom Targets","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Configuration File Format\u0009Lean Format\u0009Targets","contents":"Custom targets may be used to define any incrementally-built artifact whatsoever, using the Lake API.\n\nCustom TargetsDefine a new external library target for the package. Has one form:extern_lib «target-name» (pkg : NPackage _package.name) :=\n  /- build term of type `FetchM (Job FilePath)` -/\nThe pkg parameter (and its type specifier) is optional.\nIt is of type NPackage _package.name to provably demonstrate the package\nprovided is the package in which the target is defined.The term should build the external library's static library.\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Properties","header":"19.17.2.2. Properties","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","contents":"The number of mappings present in the hash map\n\nReturns true if the hash map contains no mappings.Note that if your BEq instance is not reflexive or your Hashable instance is not\nlawful, then it is possible that this function returns false even though is not possible\nto get anything out of the hash map.\n\nTwo hash maps are equivalent in the sense of Equiv iff\nall the keys and values are equal.Internal implementation detail of the hash map\n\nEquivalenceThe relation HashMap.Equiv can also be written with an infix operator, which is scoped to its namespace:\n\n"},"/Basic-Types/Arrays/#array-performance":{"id":"/Basic-Types/Arrays/#array-performance","header":"19.16.2.1. Performance Notes","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Run-Time Representation","contents":"Despite the fact that they appear to be an ordinary constructor and projection, Array.mk and Array.toList take time linear in the size of the array in compiled code.\nThis is because converting between linked lists and packed arrays must necessarily visit each element.\n\nMutable arrays can be used to write very efficient code.\nHowever, they are a poor persistent data structure.\nUpdating a shared array rules out mutation, and requires time linear in the size of the array.\nWhen using arrays in performance-critical code, it's important to ensure that they are used linearly.\n\n"}});