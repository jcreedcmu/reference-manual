window.docContents[243].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-other":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-other","header":"13.5.22. Other","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"trivial tries different simple tactics (e.g., rfl, contradiction, ...)\nto close the current goal.\nYou can use the command macro_rules to extend the set of tactics used. Example:macro_rules | `(tactic| trivial) => `(tactic| simp)\n\n\nSimilar to first, but succeeds only if one the given tactics solves the current goal.\n\nand_intros applies And.intro until it does not make progress.\n\ninfer_instance is an abbreviation for exact inferInstance.\nIt synthesizes a value of any target type by typeclass inference.\n\nexpose_names renames all inaccessible variables with accessible names, making them available\nfor reference in generated tactics. However, this renaming introduces machine-generated names\nthat are not fully under user control. expose_names is primarily intended as a preamble for\nauto-generated end-game tactic scripts. It is also useful as an alternative to\nset_option tactic.hygienic false. If explicit control over renaming is needed in the\nmiddle of a tactic script, consider using structured tactic scripts with\nmatch .. with, induction .. with, or intro with explicit user-defined names,\nas well as tactics such as next, case, and rename_i.\n\nunhygienic tacs runs tacs with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. Warning: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use unhygienic if possible.example : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n\n\nThe run_tac doSeq tactic executes code in TacticM Unit.\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Modification","header":"19.17.10.4. Modification","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","contents":"Inserts the given element into the set. If the tree set already contains an element that is\nequal (with regard to cmp) to the given element, then the tree set is returned unchanged.Note: this non-replacement behavior is true for TreeSet and TreeSet.Raw.\nThe insert function on TreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw behaves\ndifferently: it will overwrite an existing mapping.\n\nInserts multiple elements into the tree set by iterating over the given collection and calling\ninsert. If the same element (with respect to cmp) appears multiple times, the first occurrence\ntakes precedence.Note: this precedence behavior is true for TreeSet and TreeSet.Raw. The insertMany function on\nTreeMap, DTreeMap, TreeMap.Raw and DTreeMap.Raw behaves differently: it will prefer the last\nappearance.\n\nChecks whether an element is present in a set and inserts the element if it was not found.\nIf the tree set already contains an element that is equal (with regard to cmp to the given\nelement, then the tree set is returned unchanged.Equivalent to (but potentially faster than) calling contains followed by insert.\n\nRemoves the given key if it exists.\n\nErases multiple items from the tree set by iterating over the given collection and calling erase.\n\nRemoves all elements from the tree set for which the given function returns false.\n\nReturns a set that contains all mappings of t₁ and `t₂.This function ensures that t₁ is used linearly.\nHence, as long as t₁ is unshared, the performance characteristics follow the following imperative\ndescription: Iterate over all mappings in t₂, inserting them into t₁.Hence, the runtime of this method scales logarithmically in the size of t₁ and linearly in the\nsize of t₂ as long as t₁ is unshared.\n\nPartitions a tree set into two tree sets based on a predicate.\n\n"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--Run-Time-Characteristics":{"id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--Run-Time-Characteristics","header":"19.3.1. Run-Time Characteristics","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers","contents":"Because Fin n is a structure in which only a single field is not a proof, it is a trivial wrapper.\nThis means that it is represented identically to the underlying natural number in compiled code.\n\n"}});