window.docContents[81].resolve({"/Tactic-Proofs/The-Tactic-Language/#tactic-language-goal-selection":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-goal-selection","header":"13.3.1.3. Goal Selection","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures","contents":"Most tactics affect the main goal.\nGoal selection tactics provide a way to treat a different goal as the main one, rearranging the sequence of goals in the proof state.\n\n* case tag => tac focuses on the goal with case name tag and solves it using tac,\nor else fails.* case tag x₁ ... xₙ => tac additionally renames the n most recent hypotheses\nwith inaccessible names to the given names.* case tag₁ | tag₂ => tac is equivalent to (case tag₁ => tac); (case tag₂ => tac).\n\ncase' is similar to the case tag => tac tactic, but does not ensure the goal\nhas been solved after applying tac, nor admits the goal if tac failed.\nRecall that case closes the goal using sorry when tac fails, and\nthe tactic execution is not interrupted.\n\nrotate_left n rotates goals to the left by n. That is, rotate_left 1\ntakes the main goal and puts it to the back of the subgoal list.\nIf n is omitted, it defaults to 1.\n\nRotate the goals to the right by n. That is, take the goal at the back\nand push it to the front n times. If n is omitted, it defaults to 1.\n\n\n\n\n\n"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref-mvcgen":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-mvcgen","header":"13.5.23. Verification Condition Generation","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"mvcgen will break down a Hoare triple proof goal like ⦃P⦄ prog ⦃Q⦄ into verification conditions,\nprovided that all functions used in prog have specifications registered with @[spec].A verification condition is an entailment in the stateful logic of Std.Do.SPred\nin which the original program prog no longer occurs.\nVerification conditions are introduced by the mspec tactic; see the mspec tactic for what they\nlook like.\nWhen there's no applicable mspec spec, mvcgen will try and rewrite an application\nprog = f a b c with the simp set registered via @[spec].When used like mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat], mvcgen will additionally* add a Hoare triple specification foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄ to spec set for a\nfunction foo occurring in prog,* unfold a definition def bar_def ... := ... in prog,* unfold any method of the instBEqFloat : BEq Float instance in prog.* it will no longer substitute away let-expressions that occur at most once in P, Q or prog.Furthermore, mvcgen tries to close trivial verification conditions by SPred.entails.rfl or\nthe tactic sequence try (mpure_intro; trivial). The variant mvcgen_no_trivial does not do this.For debugging purposes there is also mvcgen_step 42 which will do at most 42 VC generation\nsteps. This is useful for bisecting issues with the generated VCs.\n\n\n\n"},"/IO/Tasks-and-Threads/#concurrency":{"id":"/IO/Tasks-and-Threads/#concurrency","header":"15.11. Tasks and Threads","context":"Lean Reference\u0009IO","contents":"Tasks are the fundamental primitive for writing multi-threaded code.\nA Task α represents a computation that, at some point, will resolve to a value of type α; it may be computed on a separate thread.\nWhen a task has resolved, its value can be read; attempting to get the value of a task before it resolves causes the current thread to block until the task has resolved.\nTasks are similar to promises in JavaScript, JoinHandle in Rust, and Future in Scala.Tasks may either carry out pure computations or IO actions.\nThe API of pure tasks resembles that of thunks: Task.spawn creates a Task α from a function in Unit → α, and Task.get waits until the function's value has been computed and then returns it.\nThe value is cached, so subsequent requests do not need to recompute it.\nThe key difference lies in when the computation occurs: while the values of thunks are not computed until they are forced, tasks execute opportunistically in a separate thread.Tasks in IO are created using IO.asTask.\nSimilarly, BaseIO.asTask and EIO.asTask create tasks in other IO monads.\nThese tasks may have side effects, and can communicate with other tasks.\n\nWhen the last reference to a task is dropped it is cancelled.\nPure tasks created with Task.spawn are terminated upon cancellation.\nTasks spawned with IO.asTask, EIO.asTask, or BaseIO.asTask continue executing and must explicitly check for cancellation using IO.checkCanceled.\nTasks may be explicitly cancelled using IO.cancel.\n\nThe Lean runtime maintains a thread pool for running tasks.\nThe size of the thread pool is determined by the environment variable LEAN_NUM_THREADS if it is set, or by the number of logical processors on the current machine otherwise.\nThe size of the thread pool is not a hard limit; in certain situations it may be exceeded to avoid deadlocks.\nBy default, these threads are used to run tasks; each task has a priority (Task.Priority), and higher-priority tasks take precedence over lower-priority tasks.\nTasks may also be assigned to dedicated threads by spawning them with a sufficiently high priority.\n\nTask α is a primitive for asynchronous computation.\nIt represents a computation that will resolve to a value of type α,\npossibly being computed on another thread. This is similar to Future in Scala,\nPromise in Javascript, and JoinHandle in Rust.The tasks have an overridden representation in the runtime.\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Recursion-Helpers":{"id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Recursion-Helpers","header":"19.12.2.6. Recursion Helpers","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","contents":"“Attaches” a proof that an optional value, if present, is indeed this value, returning a subtype\nthat expresses this fact.This function is primarily used to allow definitions by well-founded recursion that use iteration\noperators (such as Option.map) to prove that an optional value drawn from a parameter is smaller\nthan the parameter. This allows the well-founded recursion mechanism to prove that the function\nterminates.\n\n“Attaches” a proof that some predicate holds for an optional value, if present, returning a subtype\nthat expresses this fact.This function is primarily used to implement Option.attach, which allows definitions by\nwell-founded recursion that use iteration operators (such as Option.map) to prove that an optional\nvalue drawn from a parameter is smaller than the parameter. This allows the well-founded recursion\nmechanism to prove that the function terminates.\n\nRemove an attached proof that the value in an Option is indeed that value.This function is usually inserted automatically by Lean, rather than explicitly in code. It is\nintroduced as an intermediate step during the elaboration of definitions by well-founded recursion.If this function is encountered in a proof state, the right approach is usually the tactic\nsimp [Option.unattach, -Option.map_subtype].It is a synonym for Option.map Subtype.val.\n\n"}});