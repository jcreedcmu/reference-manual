window.docContents[182].resolve({"/The--grind--tactic/Constraint-Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint-Propagation--Propagation___Only-Examples":{"id":"/The--grind--tactic/Constraint-Propagation/#The-Lean-Language-Reference--The--grind--tactic--Constraint-Propagation--Propagation___Only-Examples","header":"17.4.1. Propagation‑Only Examples","context":"Lean Reference\u0009The  grind  tactic\u0009Constraint Propagation","contents":"These goals are closed purely by constraint propagation—no case splits, no theory solvers:\n\n-- Boolean connective: a && !a is always false.\nexample (a : Bool) : (a && !a) = false := by\n  grind\n\n-- Conditional (ite):\n-- once the condition is true, ite picks the 'then' branch.\nexample (c : Bool) (t e : Nat) (h : c = true) :\n    (if c then t else e) = t := by\n  grind\n\n-- Negation propagates truth downwards.\nexample (a : Bool) (h : (!a) = true) : a = false := by\n  grind\n\n\nThese snippets run instantly because the relevant propagators (propagateBoolAndUp, propagateIte, propagateBoolNotDown) fire as soon as the hypotheses are internalized.\nSetting the option trace.grind.eqc to true causes grind to print a line every time two equivalence classes merge, which is handy for seeing propagation in action.\n\n\n\nThe set of propagation rules is expanded and refined over time, so the InfoView will show increasingly rich True and False buckets.\nThe full equivalence classes are displayed automatically only when grind fails, and only for the first subgoal that it could not close—use this output to inspect missing facts and understand why the subgoal remains open.\n\nIdentifying Missing FactsIn this example, grind fails:example :\n    x = y ∧ y = z →\n    w = x ∨ w = v →\n    w = z := by\n  grind\nThe resulting error message includes the identified equivalence classes along with the true and false propositions:`grind` failed\ncase grind\nα : Sort u_1\nx y z w v : α\nleft : x = y\nright : y = z\nh_1 : w = x ∨ w = v\nh_2 : ¬w = z\n⊢ False\n[grind] Goal diagnostics\n  [facts] Asserted facts\n  [eqc] True propositions\n    [prop] w = x ∨ w = v\n    [prop] w = v\n  [eqc] False propositions\n    [prop] w = x\n    [prop] w = z\n  [eqc] Equivalence classes\n    [eqc] {x, y, z}\n    [eqc] {w, v}\nBoth x = y and y = z were discovered by constraint propagation from the x = y ∧ y = z premise.\nIn this proof, grind performed a case split on w = x ∨ w = v.\nIn the second branch, it could not place w and z in the same equivalence class.\n\n"},"/Basic-Types/Natural-Numbers/#nat-performance":{"id":"/Basic-Types/Natural-Numbers/#nat-performance","header":"19.1.2.1. Performance Notes","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers\u0009Run-Time Representation","contents":"Using Lean's built-in arithmetic operators, rather than redefining them, is essential.\nThe logical model of Nat is essentially a linked list, so addition would take time linear in the size of one argument.\nStill worse, multiplication takes quadratic time in this model.\nWhile defining arithmetic from scratch can be a useful learning exercise, these redefined operations will not be nearly as fast.\n\n"}});