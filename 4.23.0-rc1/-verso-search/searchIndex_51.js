window.docContents[51].resolve({"/Basic-Types/Maps-and-Sets/#HashMap":{"id":"/Basic-Types/Maps-and-Sets/#HashMap","header":"19.17.2. Hash Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.HashMap.\n\nHash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pairs. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.Data.HashMap.Raw and\nStd.Data.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nHashMap over HashMap.Raw.Dependent hash maps, in which keys may occur in their values' types, are available as\nStd.Data.DHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing":{"id":"/Basic-Types/Arrays/#The-Lean-Language-Reference--Basic-Types--Arrays--Sub-Arrays--Resizing","header":"19.16.5.2. Resizing","context":"Lean Reference\u0009Basic Types\u0009Arrays\u0009Sub-Arrays","contents":"Removes the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nKeeps only the first i elements of the subarray. If there are i or fewer elements, the resulting\nsubarray is empty.\n\nShrinks the subarray by incrementing its starting index if possible, returning it unchanged if not.Examples:* #[1,2,3].toSubarray.popFront.toArray = #[2, 3]* #[1,2,3].toSubarray.popFront.popFront.toArray = #[3]* #[1,2,3].toSubarray.popFront.popFront.popFront.toArray = #[]* #[1,2,3].toSubarray.popFront.popFront.popFront.popFront.toArray = #[]\n\nSplits a subarray into two parts, the first of which contains the first i elements and the second\nof which contains the remainder.\n\n"}});