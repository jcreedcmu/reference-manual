window.docContents[165].resolve({"/Source-Files-and-Modules/#whitespace":{"id":"/Source-Files-and-Modules/#whitespace","header":"5.2.1. Whitespace","context":"Lean Reference\u0009Source Files and Modules\u0009Concrete Syntax","contents":"Tokens in Lean may be separated by any number of whitespace character sequences.\nWhitespace may be a space (\" \", Unicode 'SPACE (SP)' (U+0020)), a valid newline sequence, or a comment. \nNeither tab characters nor carriage returns not followed by newlines are valid whitespace sequences.\n\n"},"/Introduction/#introduction":{"id":"/Introduction/#introduction","header":"1. Introduction","context":"Lean Reference","contents":"The Lean Language Reference is intended as a comprehensive, precise description of Lean.\nIt is a reference work in which Lean users can look up detailed information, rather than a tutorial for new users.\nAt the moment, this reference manual is a public preview.\nFor tutorials and learning materials, please visit the Lean documentation page.\n\nThis document describes version 4.23.0-rc1 of Lean.\n\n\n\n\n\n\n\n\n\n"},"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors":{"id":"/Functors___-Monads-and--do--Notation/Syntax/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Syntax--Infix-Operators--Functors","header":"14.3.1.1. Functors","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Syntax\u0009Infix Operators","contents":"\n\nThere are two infix operators for Functor.map.\n\nFunctor Operatorsg <$> x is short for Functor.map g x.x <&> g is short for Functor.map g x.\n\n\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion--Unbundled-Variants":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Maps--Conversion--Unbundled-Variants","header":"19.17.8.6.1. Unbundled Variants","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Maps\u0009Conversion","contents":"Unbundled maps separate well-formedness proofs from data.\nThis is primarily useful when defining nested inductive types.\nTo use these variants, import the module Std.TreeMap.Raw.\n\nTree maps without a bundled well-formedness invariant, suitable for use in nested\ninductive types. The well-formedness invariant is called Raw.WF. When in doubt, prefer TreeMap\nover TreeMap.Raw. Lemmas about the operations on Std.TreeMap.Raw are available in the\nmodule Std.Data.TreeMap.Raw.Lemmas.A tree map stores an assignment of keys to values. It depends on a comparator function that\ndefines an ordering on the keys and provides efficient order-dependent queries, such as retrieval\nof the minimum or maximum.To ensure that the operations behave as expected, the comparator function cmp should satisfy\ncertain laws that ensure a consistent ordering:* If a is less than (or equal) to b, then b is greater than (or equal) to a\nand vice versa (see the OrientedCmp typeclass).* If a is less than or equal to b and b is, in turn, less than or equal to c, then a\nis less than or equal to c (see the TransCmp typeclass).Keys for which cmp a b = Ordering.eq are considered the same, i.e., there can be only one entry\nwith key either a or b in a tree map. Looking up either a or b always yields the same entry,\nif any is present.To avoid expensive copies, users should make sure that the tree map is used linearly.Internally, the tree maps are represented as size-bounded trees, a type of self-balancing binary\nsearch tree with efficient order statistic lookups.Internal implementation detail of the tree map.\n\nWell-formedness predicate for tree maps. Users of TreeMap will not need to interact with\nthis. Users of TreeMap.Raw will need to provide proofs of WF to lemmas and should use lemmas\nlike WF.empty and WF.insert (which are always named exactly like the operations they are about)\nto show that map operations preserve well-formedness. The constructors of this type are internal\nimplementation details and should not be accessed by users.Internal implementation detail of the tree map.\n\n"},"/Basic-Types/Floating-Point-Numbers/#Float-api":{"id":"/Basic-Types/Floating-Point-Numbers/#Float-api","header":"19.6.2. API Reference","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers","contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations":{"id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Sequence-Operations","header":"19.5.5.6. Sequence Operations","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","contents":"These operations treat bitvectors as sequences of bits, rather than as encodings of numbers.\n\nThe empty bitvector.\n\nPrepends a single bit to the front of a bitvector, using big-endian order (see append).The new bit is the most significant bit.\n\nAppend a single bit to the end of a bitvector, using big endian order (see append).\nThat is, the new bit is the least significant bit.\n\nShifts all bits of x to the left by 1 and sets the least significant bit to b.This is a non-dependent version of BitVec.concat that does not change the total bitwidth.\n\nTransforms a bitvector of length w into a bitvector of length v, padding with 0 as needed.The specific behavior depends on the relationship between the starting width w and the final width\nv:* If v > w, it is zero-extended; the high bits are padded with zeroes until the bitvector has v\nbits.* If v = w, the bitvector is returned unchanged.* If v < w, the high bits are truncated.BitVec.setWidth, BitVec.zeroExtend, and BitVec.truncate are aliases for this operation.SMT-LIB name: zero_extend.\n\nTransforms a bitvector of length w into a bitvector of length v, padding with 0 as needed.The specific behavior depends on the relationship between the starting width w and the final width\nv:* If v > w, it is zero-extended; the high bits are padded with zeroes until the bitvector has v\nbits.* If v = w, the bitvector is returned unchanged.* If v < w, the high bits are truncated.BitVec.setWidth, BitVec.zeroExtend, and BitVec.truncate are aliases for this operation.SMT-LIB name: zero_extend.\n\nIncreases the width of a bitvector to one that is at least as large by zero-extending it.This is a constant-time operation because the underlying Nat is unmodified; because the new width\nis at least as large as the old one, no overflow is possible.\n\nConcatenates two bitvectors using the “big-endian” convention that the more significant\ninput is on the left. Usually accessed via the ++ operator.SMT-LIB name: concat.Example:* 0xAB#8 ++ 0xCD#8 = 0xABCD#16.\n\nConcatenates i copies of x into a new vector of length w * i.\n\nReverses the bits in a bitvector.\n\nRotates the bits in a bitvector to the left.All the bits of x are shifted to higher positions, with the top n bits wrapping around to fill\nthe vacated low bits.SMT-LIB name: rotate_left, except this operator uses a Nat shift amount.Example:* (0b0011#4).rotateLeft 3 = 0b1001\n\nRotates the bits in a bitvector to the right.All the bits of x are shifted to lower positions, with the bottom n bits wrapping around to fill\nthe vacated high bits.SMT-LIB name: rotate_right, except this operator uses a Nat shift amount.Example:* rotateRight 0b01001#5 1 = 0b10100\n\n\n\n"},"/Basic-Propositions/Quantifiers/#The-Lean-Language-Reference--Basic-Propositions--Quantifiers":{"id":"/Basic-Propositions/Quantifiers/#The-Lean-Language-Reference--Basic-Propositions--Quantifiers","header":"18.3. Quantifiers","context":"Lean Reference\u0009Basic Propositions","contents":"Just as implication is implemented as ordinary function types in Prop, universal quantification is implemented as dependent function types in Prop.\nBecause Prop is impredicative, any function type in which the codomain is a Prop is itself a Prop, even if the domain is a Type.\nThe typing rules for dependent functions precisely match the introduction and elimination rules for universal quantification: if a predicate holds for any arbitrarily chosen element of a type, then it holds universally.\nIf a predicate holds universally, then it can be instantiated to a proof for any individual.\n\nUniversal QuantificationUniversal quantifiers bind one or more variables, which are then in scope in the final term.\nThe identifiers may also be _.\nWith parenthesized type annotations, multiple bound variables may have different types, while the unparenthesized variant requires that all have the same type.\n\nEven though universal quantifiers are represented by functions, their proofs should not be thought of as computations.\nBecause of proof irrelevance and the elimination restriction for propositions, there's no way to actually compute data using these proofs.\nAs a result, they are free to use reasoning principles that are not readily computed, such as the classical Axiom of Choice.\n\nExistential quantification is implemented as a structure that is similar to Subtype and Sigma: it contains a witness, which is a value that satisfies the predicate, along with a proof that the witness does in fact satisfy the predicate.\nIn other words, it is a form of dependent pair type.\nUnlike both Subtype and Sigma, it is a proposition; this means that programs cannot in general use a proof of an existential statement to obtain a value that satisfies the predicate.\n\nWhen writing a proof, the exists tactic allows one (or more) witness(es) to be specified for a (potentially nested) existential statement.\nThe constructor tactic, on the other hand, creates a metavariable for the witness; providing a proof of the predicate may solve the metavariable as well.\nThe components of an existential assumption can be made available individually by pattern matching with let or Lean.Parser.Tactic.match, as well as by using cases or rcases.\n\nProving Existential StatementsWhen proving that there exists some natural number that is the sum of four and five, the exists tactic expects the sum to be provided, constructing the equality proof using trivial:theorem ex_four_plus_five : ∃ n, 4 + 5 = n := by\n  exists 9\nThe constructor tactic, on the other hand, expects a proof.\nThe rfl tactic causes the sum to be determined as a side effect of checking definitional equality.theorem ex_four_plus_five' : ∃ n, 4 + 5 = n := by\n  constructor\n  rfl\n\n\nExistential quantification. If p : α → Prop is a predicate, then ∃ x : α, p x\nasserts that there is some x of type α such that p x holds.\nTo create an existential proof, use the exists tactic,\nor the anonymous constructor notation ⟨x, h⟩.\nTo unpack an existential, use cases h where h is a proof of ∃ x : α, p x,\nor let ⟨x, hx⟩ := h where `.Because Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:example (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\nThe error message recursor 'Exists.casesOn' can only eliminate into Prop means\nthat this only works when the current goal is another proposition:example (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\nExistential introduction. If a : α and h : p a,\nthen ⟨a, h⟩ is a proof that ∃ x : α, p x.\n\nExistential QuantificationExistential quantifiers bind one or more variables, which are then in scope in the final term.\nThe identifiers may also be _.\nWith parenthesized type annotations, multiple bound variables may have different types, while the unparenthesized variant requires that all have the same type.\nIf more than one variable is bound, then the result is multiple instances of Exists, nested to the right.\n\nExtract an element from an existential statement, using Classical.choose.\n\n"}});