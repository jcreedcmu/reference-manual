window.docContents[192].resolve({"/releases/v4.2.0/#release-v4___2___0":{"id":"/releases/v4.2.0/#release-v4___2___0","header":"Lean 4.2.0 (2023-10-31)","context":"Lean Reference\u0009Release Notes","contents":"* isDefEq cache for terms not containing metavariables..* Make Environment.mk and Environment.add private, and add replay as a safer alternative.* IO.Process.output no longer inherits the standard input of the caller.* Do not inhibit caching of default-level match reduction.* List the valid case tags when the user writes an invalid one.* The derive handler for DecidableEq now handles mutual inductive types.* Show path of failed import in Lake.* Fix linker warnings on macOS.* Lake: Add postUpdate? package configuration option. Used by a package to specify some code which should be run after a successful lake update of the package or one of its downstream dependencies. (lake#185)* Improvements to Lake startup time (#2572, #2573)* refine e now replaces the main goal with metavariables which were created during elaboration of e and no longer captures pre-existing metavariables that occur in e (#2502).* This is accomplished via changes to withCollectingNewGoalsFrom, which also affects elabTermWithHoles, refine', calc (tactic), and specialize. Likewise, all of these now only include newly-created metavariables in their output.* Previously, both newly-created and pre-existing metavariables occurring in e were returned inconsistently in different edge cases, causing duplicated goals in the infoview (issue #2495), erroneously closed goals (issue #2434), and unintuitive behavior due to refine e capturing previously-created goals appearing unexpectedly in e (no issue; see PR).\n\n"},"/Tactic-Proofs/The-Tactic-Language/#tactic-config":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-config","header":"13.3.5. Configuration","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","contents":"Many tactics are configurable.\nBy convention, tactics share a configuration syntax, described using optConfig.\nThe specific options available to each tactic are described in the tactic's documentation.\n\nTactic ConfigurationA tactic configuration consists of zero or more configuration items:\n\nTactic Configuration ItemsEach configuration item has a name that corresponds to an underlying tactic option.\nBoolean options may be enabled or disabled using prefix + and -:Options may be assigned specific values using a syntax similar to that for named function arguments:Finally, the name config is reserved; it is used to pass an entire set of options as a data structure.\nThe specific type expected depends on the tactic.\n\n"},"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed--Examples":{"id":"/Error-Explanations/lean___inferDefTypeFailed/#The-Lean-Language-Reference--Error-Explanations--lean___inferDefTypeFailed--Examples","header":"Examples","context":"Lean Reference\u0009Error Explanations\u0009lean.inferDefTypeFailed","contents":"Implicit argument cannot be inferreddef emptyNats :=\n  []\nFailed to infer type of definition `emptyNats`\ndef emptyNats : List Nat :=\n  []\ndef emptyNats :=\n  List.nil (α := Nat)\nHere, Lean is unable to infer the value of the parameter α of the List type constructor, which\nin turn prevents it from inferring the type of the definition. Two fixes are possible: specifying\nthe expected type of the definition allows Lean to infer the appropriate implicit argument to the\nList.nil constructor; alternatively, making this implicit argument explicit in the function body\nprovides sufficient information for Lean to infer the definition's type.\n\nDefinition type uninferrable due to unknown parameter typedef identity x :=\n  x\nFailed to infer type of definition `identity`\ndef identity (x : α) :=\n  x\nIn this example, the type of identity is determined by the type of x, which cannot be inferred.\nBoth the indicated error and\nlean.inferBinderTypeFailed therefore\nappear (see that explanation for additional discussion of this example). Resolving the latter—by\nexplicitly specifying the type of x—provides Lean with sufficient information to infer the\ndefinition type.\n\n"},"/Build-Tools-and-Distribution/Lake/#automatic-toolchain-updates":{"id":"/Build-Tools-and-Distribution/Lake/#automatic-toolchain-updates","header":"22.1.2.4. Automatic Toolchain Updates","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Command-Line Interface","contents":"The update command checks for changes to dependencies, fetching their sources and updating the manifest accordingly.\nBy default, update also attempts to update the root package's toolchain file when a new version of a dependency specifies an updated toolchain.\nThis behavior can be disabled with the --keep-toolchain flag.\n\nIf multiple dependencies specify newer toolchains, Lake selects the newest compatible toolchain, if it exists.\nTo determine the newest compatible toolchain, Lake parses the toolchain listed in the packages' lean-toolchain files into four categories:* Releases, which are compared by version number (e.g., v4.4.0 < v4.8.0 and v4.6.0-rc1 < v4.6.0)* Nightly builds, which are compared by date (e.g., nightly-2024-01-10 < nightly-2024-10-01)* Builds from pull requests to the Lean compiler, which are incomparable* Other versions, which are also incomparableToolchain versions from multiple categories are incomparable.\nIf there is not a single newest toolchain, Lake will print a warning and continue updating without changing the toolchain.\n\nIf Lake does find a new toolchain, then it updates the workspace's lean-toolchain file accordingly and restarts the update using the new toolchain's Lake.\nIf Elan is detected, it will spawn the new Lake process via elan run with the same arguments Lake was initially run with.\nIf Elan is missing, it will prompt the user to restart Lake manually and exit with a special error code (namely, 4).\nThe Elan executable used by Lake can be configured using the ELAN environment variable.\n\n"}});