window.docContents[40].resolve({"/releases/v4.15.0/#release-v4___15___0":{"id":"/releases/v4.15.0/#release-v4___15___0","header":"Lean 4.15.0 (2025-01-04)","context":"Lean Reference\u0009Release Notes","contents":"Language* #4595 implements Simp.Config.implicitDefEqsProofs. When true\n(default: true), simp will not create a proof term for a\nrewriting rule associated with an rfl-theorem. Rewriting rules are\nprovided by users by annotating theorems with the attribute @[simp].\nIf the proof of the theorem is just rfl (reflexivity), and\nimplicitDefEqProofs := true, simp will not create a proof term\nwhich is an application of the annotated theorem.* #5429 avoid negative environment lookup* #5501 ensure instantiateMVarsProfiling adds a trace node* #5856 adds a feature to the the mutual def elaborator where the\ninstance command yields theorems instead of definitions when the class\nis a Prop.* #5907 unset trailing for simpa? \"try this\" suggestion* #5920 changes the rule for which projections become instances. Before,\nall parents along with all indirect ancestors that were represented as\nsubobject fields would have their projections become instances. Now only\nprojections for direct parents become instances.* #5934 make all_goals admit goals on failure* #5942 introduce synthetic atoms in bv_decide* #5945 adds a new definition Message.kind which returns the top-level\ntag of a message. This is serialized as the new field kind in\nSerialMessaege so that i can be used by external consumers (e.g.,\nLake) to identify messages via lean --json.* #5968 arg conv tactic misreported number of arguments on error* #5979 BitVec.twoPow in bv_decide* #5991 simplifies the implementation of omega.* #5992 fix style in bv_decide normalizer* #5999 adds configuration options for\ndecide/decide!/native_decide and refactors the tactics to be\nfrontends to the same backend. Adds a +revert option that cleans up\nthe local context and reverts all local variables the goal depends on,\nalong with indirect propositional hypotheses. Makes native_decide fail\nat elaboration time on failure without sacrificing performance (the\ndecision procedure is still evaluated just once). Now native_decide\nsupports universe polymorphism.* #6010 changes bv_decide's configuration from lots of set_option to\nan elaborated config like simp or omega. The notable exception is\nsat.solver which is still a set_option such that users can configure\na custom SAT solver globally for an entire project or file. Additionally\nit introduces the ability to set maxSteps for the simp preprocessing\nrun through the new config.* #6012 improves the validation of new syntactic tokens. Previously, the\nvalidation code had inconsistencies: some atoms would be accepted only\nif they had a leading space as a pretty printer hint. Additionally,\natoms with internal whitespace are no longer allowed.* #6016 removes the decide! tactic in favor of decide +kernel\n(breaking change).* #6019 removes @[specilize] from MkBinding.mkBinding, which is a\nfunction that cannot be specialized (as none of its arguments are\nfunctions). As a result, the specializable function Nat.foldRevM.loop\ndoesn't get specialized, which leads to worse performing code.* #6022 makes the change tactic and conv tactic use the same\nelaboration strategy. It works uniformly for both the target and local\nhypotheses. Now change can assign metavariables, for example:example (x y z : Nat) : x + y = z := by\n  change ?a = _\n  let w := ?a\n  -- now `w : Nat := x + y`\n* #6024 fixes a bug where the monad lift coercion elaborator would\npartially unify expressions even if they were not monads. This could be\ntaken advantage of to propagate information that could help elaboration\nmake progress, for example the first change worked because the monad\nlift coercion elaborator was unifying @Eq _ _ with @Eq (Nat × Nat) p:example (p : Nat × Nat) : p = p := by\n  change _ = ⟨_, _⟩ -- used to work (yielding `p = (p.fst, p.snd)`), now it doesn't\n  change ⟨_, _⟩ = _ -- never worked\nAs such, this is a breaking change; you may need to adjust expressions\nto include additional implicit arguments.* #6029 adds a normalization rule to bv_normalize (which is used by\nbv_decide) that converts x / 2^k into x >>> k under suitable\nconditions. This allows us to simplify the expensive division circuits\nthat are used for bitblasting into much cheaper shifting circuits.\nConcretely, it allows for the following canonicalization:* #6030 fixes simp only [· ∈ ·] after #5020.* #6035 introduces the and flattening pre processing pass from Bitwuzla\nto bv_decide. It splits hypotheses of the form (a && b) = true into\na = true and b = true which has synergy potential with the already\nexisting embedded constraint substitution pass.* #6037 fixes bv_decide's embedded constraint substitution to generate\ncorrect counter examples in the corner case where duplicate theorems are\nin the local context.* #6045 add LEAN_ALWAYS_INLINE to some functions* #6048 fixes simp? suggesting output with invalid indentation* #6051 mark Meta.Context.config as private* #6053 fixes the caching infrastructure for whnf and isDefEq,\nensuring the cache accounts for all relevant configuration flags. It\nalso cleans up the WHNF.lean module and improves the configuration of\nwhnf.* #6061 adds a simp_arith benchmark.* #6062 optimize Nat.Linear.Expr.toPoly* #6064 optimize Nat.Linear.Poly.norm* #6068 improves the asymptotic performance of simp_arith when there are many variables to consider.* #6077 adds options to bv_decide's configuration structure such that\nall non mandatory preprocessing passes can be disabled.* #6082 changes how the canonicalizer handles forall and lambda,\nreplacing bvars with temporary fvars. Fixes a bug reported by @hrmacbeth\non\nzulip.* #6093 use mkFreshUserName in ArgsPacker* #6096 improves the #print command for structures to show all fields\nand which parents the fields were inherited from, hiding internal\ndetails such as which parents are represented as subobjects. This\ninformation is still present in the constructor if needed. The pretty\nprinter for private constants is also improved, and it now handles\nprivate names from the current module like any other name; private names\nfrom other modules are made hygienic.* #6098 modifies Lean.MVarId.replaceTargetDefEq and\nLean.MVarId.replaceLocalDeclDefEq to use Expr.equal instead of\nExpr.eqv when determining whether the expression has changed. This is\njustified on the grounds that binder names and binder infos are\nuser-visible and affect elaboration.* #6105 fixes a stack overflow caused by a cyclic assignment in the\nmetavariable context. The cycle is unintentionally introduced by the\nstructure instance elaborator.* #6108 turn off pp.mvars in apply? results* #6109 fixes an issue in the injection tactic. This tactic may\nexecute multiple sub-tactics. If any of them fail, we must backtrack the\npartial assignment. This issue was causing the error: \"mvarId is\nalready assigned\" in issue #6066. The issue is not yet resolved, as the\nequation generator for the match expressions is failing in the example\nprovided in this issue.* #6112 makes stricter requirements for the @[deprecated] attribute,\nrequiring either a replacement identifier as @[deprecated bar] or\nsuggestion text @[deprecated \"Past its use by date\"], and also\nrequires a since := \"...\" field.* #6114 liberalizes atom rules by allowing '' to be a prefix of an\natom, after #6012 only added an exception for '' alone, and also adds\nsome unit tests for atom validation.* #6116 fixes a bug where structural recursion did not work when indices\nof the recursive argument appeared as function parameters in a different\norder than in the argument's type's definition.* #6125 adds support for structure in mutual blocks, allowing\ninductive types defined by inductive and structure to be mutually\nrecursive. The limitations are (1) that the parents in the extends\nclause must be defined before the mutual block and (2) mutually\nrecursive classes are not allowed (a limitation shared by class inductive). There are also improvements to universe level inference for\ninductive types and structures. Breaking change: structure parents now\nelaborate with the structure in scope (fix: use qualified names or\nrename the structure to avoid shadowing), and structure parents no\nlonger elaborate with autoimplicits enabled.* #6128 does the same fix as #6104, but such that it doesn't break the\ntest/the file in Plausible. This is done by not creating unused let\nbinders in metavariable types that are made by elimMVar. (This is also\na positive thing for users looking at metavariable types, for example in\nerror messages)* #6129 fixes a bug at isDefEq when zetaDelta := false. See new test\nfor a small example that exposes the issue.* #6131 fixes a bug at the definitional equality test (isDefEq). At\nunification constraints of the form c.{u} =?= c.{v}, it was not trying\nto unfold c. This bug did not affect the kernel.* #6141 make use of recursive structures in snapshot types* #6145 fixes the revert tactic so that it creates a syntheticOpaque\nmetavariable as the new goal, instead of a natural metavariable* #6146 fixes a non-termination bug that occurred when generating the\nmatch-expression splitter theorem. The bug was triggered when the proof\nautomation for the splitter theorem repeatedly applied injection to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6065 for an example that reproduces this issue.* #6165 modifies structure instance notation and where notation to use\nthe same notation for fields. Structure instance notation now admits\nbinders, type ascriptions, and equations, and where notation admits\nfull structure lvals. Examples of these for structure instance notation:structure PosFun where\n  f : Nat → Nat\n  pos : ∀ n, 0 < f n\n* #6168 extends the \"motive is not type correct\" error message for the\nrewrite tactic to explain what it means. It also pretty prints the\ntype-incorrect motive and reports the type error.* #6170 adds core metaprogramming functions for forking off background\ntasks from elaboration such that their results are visible to reporting\nand the language server* #6175 fixes a bug with the structure/class command where if there\nare parents that are not represented as subobjects but which used other\nparents as instances, then there would be a kernel error. Closes #2611.* #6180 fixes a non-termination bug that occurred when generating the\nmatch-expression equation theorems. The bug was triggered when the proof\nautomation for the equation theorem repeatedly applied injection( to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6067 for an example that reproduces this issue.* #6189 changes how generalized field notation (\"dot notation\") resolves\nthe function. The new resolution rule is that if x : S, then x.f\nresolves the name S.f relative to the root namespace (hence it now\naffected by export and open). Breaking change: aliases now resolve\ndifferently. Before, if x : S, and if S.f is an alias for S'.f,\nthen x.f would use S'.f and look for an argument of type S'. Now,\nit looks for an argument of type S, which is more generally useful\nbehavior. Code making use of the old behavior should consider defining\nS or S' in terms of the other, since dot notation can unfold\ndefinitions during resolution.* #6206 makes it possible to write rw (occs := [1,2]) ... instead of\nrw (occs := .pos [1,2]) ... by adding a coercion from List.Nat to\nLean.Meta.Occurrences.* #6220 adds proper support for let_fun in simp.* #6236 fixes an issue where edits to a command containing a nested\ndocstring fail to reparse the entire command.Library* #4904 introduces date and time functionality to the Lean 4 Std.* #5616 is a follow-up to https://github.com/leanprover/lean4/pull/5609,\nwhere we add lemmas characterizing smtUDiv and smtSDiv's behavior\nwhen the denominator is zero.* #5866 verifies the keys function on Std.HashMap.* #5885 add Int16/Int32/Int64* #5926 add Option.or_some'* #5927 List.pmap_eq_self* #5937 upstream lemmas about Fin.foldX* #5938 upstream List.ofFn and relate to Array.ofFn* #5941 List.mapFinIdx, lemmas, relate to Array version* #5949 consolidate decide_True and decide_true_eq_true* #5950 relate Array.takeWhile with List.takeWhile* #5951 remove @[simp] from BitVec.ofFin_sub and sub_ofFin* #5952 relate Array.eraseIdx with List.eraseIdx* #5961 define ISize and basic operations on it* #5969 upstream List.insertIdx from Batteries, lemmas from Mathlib, and revise lemmas* #5970 deprecate Array.split in favour of identical Array.partition* #5971 relate Array.isPrefixOf with List.isPrefixOf* #5972 relate Array.zipWith/zip/unzip with List versions* #5974 add another List.find?_eq_some lemma* #5981 names the default SizeOf instance instSizeOfDefault* #5982 minor lemmas about List.ofFn* #5984 adds lemmas for List for the interactions between {foldl,\nfoldr, foldlM, foldlrM} and {filter, filterMap}.* #5985 relates the operations findSomeM?, findM?, findSome?, and\nfind? on Array with the corresponding operations on List, and also\nprovides simp lemmas for the Array operations findSomeRevM?,\nfindRevM?, findSomeRev?, findRev? (in terms of reverse and the\nusual forward find operations).* #5987 BitVec.getMsbD in bv_decide* #5988 changes the signature of Array.set to take a Nat, and a\ntactic-provided bound, rather than a Fin.* #5995 BitVec.sshiftRight' in bv_decide* #6007 List.modifyTailIdx naming fix* #6008 missing @[ext] attribute on monad transformer ext lemmas* #6023 variants of List.forIn_eq_foldlM* #6025 deprecate duplicated Fin.size_pos* #6032 changes the signature of Array.get to take a Nat and a proof,\nrather than a Fin, for consistency with the rest of the (planned)\nArray API. Note that because of bootstrapping issues we can't provide\nget_elem_tactic as an autoparameter for the proof. As users will\nmostly use the xs[i] notation provided by GetElem, this hopefully\nisn't a problem.* #6041 modifies the order of arguments for higher-order Array\nfunctions, preferring to put the Array last (besides positional\narguments with defaults). This is more consistent with the List API,\nand is more flexible, as dot notation allows two different partially\napplied versions.* #6049 adds a primitive for accessing the current thread ID* #6052 adds Array.pmap, as well as a @[csimp] lemma in terms of the\nno-copy Array.attachWith.* #6055 adds lemmas about for loops over Array, following the existing\nlemmas for List.* #6056 upstream some NameMap functions* #6060 implements conversion functions from Bool to all UIntX and\nIntX types.* #6070 adds the Lean.RArray data structure.* #6074 allow Sort u in Squash* #6094 adds raw transmutation of floating-point numbers to and from\nUInt64. Floats and UInts share the same endianness across all\nsupported platforms. The IEEE 754 standard precisely specifies the bit\nlayout of floats. Note that Float.toBits is distinct from\nFloat.toUInt64, which attempts to preserve the numeric value rather\nthan the bitwise value.* #6095 generalize List.get_mem* #6097 naming convention and NaN normalization* #6102 moves IO.rand and IO.setRandSeed to be in the BaseIO\nmonad.* #6106 fix naming of left/right injectivity lemmas* #6111 fills in the API for Array.findSome? and Array.find?,\ntransferring proofs from the corresponding List statements.* #6120 adds theorems BitVec.(getMsbD, msb)_(rotateLeft, rotateRight).* #6126 adds lemmas for extracting a given bit of a BitVec obtained\nvia sub/neg/sshiftRight'/abs.* #6130 adds Lean.loadPlugin which exposes functionality similar to\nthe lean executable's --plugin option to Lean code.* #6132 duplicates the verification API for\nList.attach/attachWith/pmap over to Array.* #6133 replaces Array.feraseIdx and Array.insertAt with\nArray.eraseIdx and Array.insertIdx, both of which take a Nat\nargument and a tactic-provided proof that it is in bounds. We also have\neraseIdxIfInBounds and insertIdxIfInBounds which are noops if the\nindex is out of bounds. We also provide a Fin valued version of\nArray.findIdx?. Together, these quite ergonomically improve the array\nindexing safety at a number of places in the compiler/elaborator.* #6136 fixes the run-time evaluation of (default : Float).* #6139 modifies the signature of the functions Nat.fold,\nNat.foldRev, Nat.any, Nat.all, so that the function is passed the\nupper bound. This allows us to change runtime array bounds checks to\ncompile time checks in many places.* #6148 adds a primitive for creating temporary directories, akin to the\nexisting functionality for creating temporary files.* #6149 completes the elementwise accessors for ofNatLt, allOnes,\nand not by adding their implementations of getMsbD.* #6151 completes the toInt interface for BitVec bitwise operations.* #6154 implements BitVec.toInt_abs.* #6155 adds toNat theorems for BitVec.signExtend.* #6157 adds toInt theorems for BitVec.signExtend.* #6160 adds theorem mod_eq_sub, makes theorem\nsub_mul_eq_mod_of_lt_of_le not private anymore and moves its location\nwithin the rotate* section to use it in other proofs.* #6184 uses Array.findFinIdx? in preference to Array.findIdx? where\nit allows converting a runtime bounds check to a compile time bounds\ncheck.* #6188 completes the toNat theorems for the bitwise operations\n(and, or, xor, shiftLeft, shiftRight) of the UInt types and\nadds toBitVec theorems as well. It also renames and_toNat to\ntoNat_and to fit with the current naming convention.* #6190 adds the builtin simproc USize.reduceToNat which reduces the\nUSize.toNat operation on literals less than UInt32.size (i.e.,\n4294967296).* #6191 adds Array.zipWithAll, and the basic lemmas relating it to\nList.zipWithAll.* #6192 adds deprecations for Lean.HashMap functions which did not\nreceive deprecation attributes initially.* #6193 completes the TODO in Init.Data.Array.BinSearch, removing the\npartial keyword and converting runtime bounds checks to compile time\nbounds checks.* #6194 changes the signature of Array.swap, so it takes Nat\narguments with tactic provided bounds checking. It also renames\nArray.swap! to Array.swapIfInBounds.* #6195 renames Array.setD to Array.setIfInBounds.* #6197 upstreams the definition of Vector from Batteries, along with\nthe basic functions.* #6200 upstreams Nat.lt_pow_self and Nat.lt_two_pow from Mathlib\nand uses them to prove the simp theorem Nat.mod_two_pow.* #6202 makes USize.toUInt64 a regular non-opaque definition.* #6203 adds the theorems le_usize_size and usize_size_le, which\nmake proving inequalities about USize.size easier.* #6205 upstreams some UInt theorems from Batteries and adds more\ntoNat-related theorems. It also adds the missing UInt8 and UInt16\nto/from USize conversions so that the the interface is uniform across\nthe UInt types.* #6207 ensures the Fin.foldl and Fin.foldr are semireducible.\nWithout this the defeq example (f : Fin 3 → ℕ) : List.ofFn f = [f 0, f 1, f 2] := rfl was failing.* #6208 fix Vector.indexOf?* #6217 adds simp lemmas about List's == operation.* #6221 fixes:* Problems in other linux distributions that the default tzdata\ndirectory is not the same as previously defined by ensuring it with a\nfallback behavior when directory is missing.* Trim unnecessary characters from local time identifier.* #6222 changes the definition of HashSet.insertMany and\nHashSet.Raw.insertMany so that it is equivalent to repeatedly calling\nHashSet.insert/HashSet.Raw.insert. It also clarifies the docstrings\nof all the insert and insertMany functions.* #6230 copies some lemmas about List.foldX to Array.* #6233 upstreams lemmas about Vector from Batteries.* #6234 upstreams the definition and basic lemmas about List.finRange\nfrom Batteries.* #6235 relates that operations Nat.fold/foldRev/any/all to the\ncorresponding List operations over List.finRange.* #6241 refactors Array.qsort to remove runtime array bounds checks,\nand avoids the use of partial. We use the Vector API, along with\nauto_params, to avoid having to write any proofs. The new code\nbenchmarks indistinguishably from the old.* #6242 deprecates Fin.ofNat in favour of Fin.ofNat' (which takes an\n[NeZero] instance, rather than returning an element of Fin (n+1)).* #6247 adds the theorems numBits_pos, le_numBits, numBits_le ,\nwhich make proving inequalities about System.Platform.numBits easier.Compiler* #5840 changes lean_sharecommon_{eq,hash} to only consider the\nsalient bytes of an object, and not any bytes of any\nunspecified/uninitialized unused capacity.* #6087 fixes a bug in the constant folding for the Nat.ble and\nNat.blt function in the old code generator, leading to a\nmiscompilation.* #6143 should make lean better-behaved around sanitizers, per\nhttps://github.com/google/sanitizers/issues/1688.\nAs far as I can tell,\nhttps://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn#algorithm\nreplaces local variables with heap allocations, and so taking the\naddress of a local is not effective at producing a monotonic measure of\nstack usage.* #6209 documents under which conditions Runtime.markPersistent is\nunsafe and adjusts the elaborator accordingly* #6257 harden markPersistent usesPretty Printing* #2934 adds the option pp.parens (default: false) that causes the\npretty printer to eagerly insert parentheses, which can be useful for\nteaching and for understanding the structure of expressions. For\nexample, it causes p → q → r to pretty print as p → (q → r).* #6014 prevents Nat.succ ?_ from pretty printing as ?_.succ, which\nshould make apply? be more usable.* #6085 improves the term info for coercions marked with\nCoeFnType.coeFun (such as DFunLike.coe in Mathlib), making \"go to\ndefinition\" on the function name work. Hovering over such a coerced\nfunction will show the coercee rather than the coercion expression. The\ncoercion expression can still be seen by hovering over the whitespace in\nthe function application.* #6096 improves the #print command for structures to show all fields\nand which parents the fields were inherited from, hiding internal\ndetails such as which parents are represented as subobjects. This\ninformation is still present in the constructor if needed. The pretty\nprinter for private constants is also improved, and it now handles\nprivate names from the current module like any other name; private names\nfrom other modules are made hygienic.* #6119 adds a new delab option pp.coercions.types which, when\nenabled, will display all coercions with an explicit type ascription.* #6161 ensures whitespace is printed before +opt and -opt\nconfiguration options when pretty printing, improving the experience of\ntactics such as simp?.* #6181 fixes a bug where the signature pretty printer would ignore the\ncurrent setting of pp.raw. This fixes an issue where #check ident\nwould not heed pp.raw. Closes #6090.* #6213 exposes the difference in \"synthesized type class instance is\nnot definitionally equal\" errors.Documentation* #6009 fixes a typo in the docstring for prec and makes the text\nslightly more precise.* #6040 join → flatten in docstring* #6110 does some mild refactoring of the Lean.Elab.StructInst module\nwhile adding documentation.* #6144 converts 3 doc-string to module docs since it seems that this is\nwhat they were intended to be!* #6150 refine kernel code comments* #6158 adjust file reference in Data.Sum* #6239 explains the order in which Expr.abstract introduces de Bruijn\nindices.Server* #5835 adds auto-completion for the fields of structure instance notation. Specifically, querying the completions via Ctrl+Space in the whitespace of a structure instance notation will now bring up the full list of fields. Whitespace structure completion can be enabled for custom syntax by wrapping the parser for the list of fields in a structInstFields parser.* #5837 fixes an old auto-completion bug where x. would issue\nnonsensical completions when x. could not be elaborated as a dot\ncompletion.* #5996 avoid max heartbeat error in completion* #6031 fixes a regression with go-to-definition and document highlight\nmisbehaving on tactic blocks.* #6246 fixes a performance issue where the Lean language server would\nwalk the full project file tree every time a file was saved, blocking\nthe processing of all other requests and notifications and significantly\nincreasing overall language server latency after saving.Lake* #5684 update toolchain on lake update* #6026 adds a newline at end of each Lean file generated by lake new\ntemplates.* #6218 makes Lake no longer automatically fetch GitHub cloud releases\nif the package build directory is already present (mirroring the\nbehavior of the Reservoir cache). This prevents the cache from\nclobbering existing prebuilt artifacts. Users can still manually fetch\nthe cache and clobber the build directory by running lake build <pkg>:release.* #6225 makes lake build also eagerly print package materialization\nlog lines. Previously, only a lake update performed eager logging.* #6231 improves the errors Lake produces when it fails to fetch a\ndependency from Reservoir. If the package is not indexed, it will\nproduce a suggestion about how to require it from GitHub.Other* #6137 adds support for displaying multiple threads in the trace\nprofiler output.* #6138 fixes trace.profiler.pp not using the term pretty printer.* #6259 ensures that nesting trace nodes are annotated with timing\ninformation iff trace.profiler is active.\n\n"},"/Interacting-with-Lean/#repr-instance-howto":{"id":"/Interacting-with-Lean/#repr-instance-howto","header":"3.7.2.1. How To Write a  Repr  Instance","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Repr","contents":"Lean can produce an appropriate Repr instance for most types automatically using instance deriving.\nIn some cases, however, it's necessary to write an instance by hand:\n\n\n\n\n\nWhen writing a custom Repr instance, please follow these conventions:\n\n Precedence\n\nCheck precedence, adding parentheses as needed, and pass the correct precedence to the reprPrec instances of embedded data.\n  Each instance is responsible for surrounding itself in parentheses if needed; instances should generally not parenthesize recursive calls to reprPrec.Function application has the maximum precedence, max_prec.\n  The helpers Repr.addAppParen and reprArg respectively insert parentheses around applications when needed and pass the appropriate precedence to function arguments.\n\n Fully-Qualified Names\n\nA Repr instance does have access to the set of open namespaces in a given position.\n  All names of constants in the environment should be fully qualified to remove ambiguity.\n\n Default Nesting\n\nNested data should be indented using nestD to ensure consistent indentation across instances.\n\n Grouping and Line Breaks\n\nThe output of every Repr instance that includes line breaks should be surrounded in a group.\n  Furthermore, if the resulting code contains notional expressions that are nested, a group should be inserted around each nested level.\n  Line breaks should usually be inserted in the following positions:* Between a constructor and each of its arguments* After :=* After ,* Between the opening and closing braces of structure instance notation and its contents* After, but not before, an infix operator\n\n Parentheses and Brackets\n\nParentheses and brackets should be inserted using Std.Format.bracket or its specializations Std.Format.paren for parentheses and Std.Format.sbracket for square brackets.\n  These operators align the contents of the parenthesized or bracketed expression in the same way that Lean's do.\n  Trailing parentheses and brackets should not be placed on their own line, but rather stay with their contents.\n\n\n\nAdds parentheses to f if the precedence prec from the context is at least that of function\napplication.Together with reprArg, this can be used to correctly parenthesize function application\nsyntax.\n\nTurns a into a Format using its Repr instance, with the precedence level set to that of\nfunction application.Together with Repr.addAppParen, this can be used to correctly parenthesize function application\nsyntax.\n\nInductive Types with ConstructorsThe inductive type N.NatOrInt can contain a Nat or an Int:namespace N\n\ninductive NatOrInt where\n  | nat : Nat → NatOrInt\n  | int : Int → NatOrInt\n\nThe Repr NatOrInt instance adheres to the conventions:* The right-hand side is a function application, so it uses Repr.addAppParen to add parentheses if necessary.* Parentheses are wrapped around the entire body with no additional lines.* The entire function application is grouped, and it is nested the default amount.* The function is separated from its parameters by a use of line; this newline will usually be a space because the Repr Nat and Repr Int instances are unlikely to produce long output.* Recursive calls to reprPrec pass max_prec because they are in function parameter positions, and function application has the highest precedence.instance : Repr NatOrInt where\n  reprPrec\n    | .nat n =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.nat\" ++ .line ++ reprPrec n max_prec\n    | .int i =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.int\" ++ .line ++ reprPrec i max_prec\n#eval IO.println (repr (NatOrInt.nat 5))\nN.NatOrInt.nat 5\n#eval IO.println (repr (NatOrInt.int 5))\nN.NatOrInt.int 5\n#eval IO.println (repr (NatOrInt.int (-5)))\nN.NatOrInt.int (-5)\n#eval IO.println (repr (some (NatOrInt.int (-5))))\nsome (N.NatOrInt.int (-5))\n#eval IO.println (repr <| (List.range 10).map (NatOrInt.nat))\n[N.NatOrInt.nat 0,\n N.NatOrInt.nat 1,\n N.NatOrInt.nat 2,\n N.NatOrInt.nat 3,\n N.NatOrInt.nat 4,\n N.NatOrInt.nat 5,\n N.NatOrInt.nat 6,\n N.NatOrInt.nat 7,\n N.NatOrInt.nat 8,\n N.NatOrInt.nat 9]\n#eval IO.println (Std.Format.pretty (width := 3) (repr <| (List.range 10).map (NatOrInt.nat)))\n[N.NatOrInt.nat\n   0,\n N.NatOrInt.nat\n   1,\n N.NatOrInt.nat\n   2,\n N.NatOrInt.nat\n   3,\n N.NatOrInt.nat\n   4,\n N.NatOrInt.nat\n   5,\n N.NatOrInt.nat\n   6,\n N.NatOrInt.nat\n   7,\n N.NatOrInt.nat\n   8,\n N.NatOrInt.nat\n   9]\n\n\nInfix Syntaxinductive AddExpr where\n  | nat : Nat → AddExpr\n  | add : AddExpr → AddExpr → AddExpr\n\ninstance : OfNat AddExpr n where\n  ofNat := .nat n\n\ninstance : Add AddExpr where\n  add := .add\n\nprotected def AddExpr.reprPrec : AddExpr → Nat → Std.Format\n  | .nat n, p  =>\n    Repr.reprPrec n p\n  | .add e1 e2, p =>\n    let out : Std.Format :=\n      .nestD <| .group <|\n        AddExpr.reprPrec e1 64 ++ \" \" ++ \"+\" ++ .line ++\n        AddExpr.reprPrec e2 65\n    if p ≥ 65 then out.paren else out\n\ninstance : Repr AddExpr := ⟨AddExpr.reprPrec⟩\n#eval IO.println (repr (((2 + 3) + 4) : AddExpr))\n#eval IO.println (repr ((2 + 3 + 4) : AddExpr))\n#eval IO.println (repr ((2 + (3 + 4)) : AddExpr))\n#eval IO.println (repr ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr))\n#eval IO.println <| (repr ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr)).pretty (width := 0)\n\n\n"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties":{"id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties","header":"14.5. Varieties of Monads","context":"Lean Reference\u0009Functors, Monads and  do -Notation","contents":"The IO monad has many, many effects, and is used for writing programs that need to interact with the world.\nIt is described in its own section.\nPrograms that use IO are essentially black boxes: they are typically not particularly amenable to verification.\n\nMany algorithms are easiest to express with a much smaller set of effects.\nThese effects can often be simulated; for example, mutable state can be simulated by passing around a tuple that contains both the program's value and the state.\nThese simulated effects are easier to reason formally about, because they are defined using ordinary code rather than new language primitives.\n\nThe standard library provides abstractions for working with commonly-used effects.\nMany frequently-used effects fall into a small number of categories:\n\n State monads have mutable state\n\nComputations that have access to some data that may be modified by other parts of the computation use mutable state.\n  State can be implemented in a variety of ways, described in the section on state monads and captured in the MonadState type class.\n\n Reader monads are parameterized computations\n\nComputations that can read the value of some parameter provided by a context exist in most programming languages, but many languages that feature state and exceptions as first-class features do not have built-in facilities for defining new parameterized computations.\n  Typically, these computations are provided with a parameter value when invoked, and sometimes they can locally override it.\n  Parameter values have dynamic extent: the value provided most recently in the call stack is the one that is used.\n  They can be simulated by passing a value unchanged through a sequence of function calls; however, this technique can make code harder to read and introduces a risk that the values may be passed incorrectly to further calls by mistake.\n  They can also be simulated using mutable state with a careful discipline surrounding the modification of the state.\n  Monads that maintain a parameter, potentially allowing it to be overridden in a section of the call stack, are called reader monads.\n  Reader monads are captured in the MonadReader type class.\n  Additionally, reader monads that allow the parameter value to be locally overridden are captured in the MonadWithReader type class.\n\n Exception monads have exceptions\n\nComputations that may terminate early with an exceptional value use exceptions.\n  They are typically modeled with a sum type that has a constructor for ordinary termination and a constructor for early termination with errors.\n  Exception monads are described in the section on exception monads, and captured in the MonadExcept type class.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Build-Tools-and-Distribution/Lake/#lake-facets":{"id":"/Build-Tools-and-Distribution/Lake/#lake-facets","header":"22.1.1.2. Facets","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","contents":"A facet describes the production of a target from another.\nConceptually, any target may have facets.\nHowever, executables, external libraries, and custom targets provide only a single implicit facet.\nPackages, libraries, and modules have multiple facets that can be requested by name when invoking build to select the corresponding target.\n\nWhen no facet is explicitly requested, but an initial target is designated, build produces the initial target's default facet.\nEach type of initial target has a corresponding default facet (e.g. producing an executable binary from an executable target or building a package's default targets); other facets may be explicitly requested in the package configuration or via Lake's command-line interface.\nLake's internal API may be used to write custom facets.\n\n\n\nThe facets available for packages are: extraDep\n\nThe default facets of the package's extra dependency targets, specified in the extraDepTargets field.\n\n deps\n\nThe package's direct dependencies.\n\n transDeps\n\nThe package's transitive dependencies, topologically sorted.\n\n optCache\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n cache\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optBarrel\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n barrel\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optRelease\n\nA package's optional build archive from a GitHub release.\n  Will not cause the whole build to fail if the release cannot be fetched.\n\n release\n\nA package's build archive from a GitHub release.\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n\n\n\n\nThe facets available for libraries are: leanArts\n\nThe artifacts that the Lean compiler produces for the library or executable (*.olean, *.ilean, and *.c files).\n\n static\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file).\n\n static.export\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file), with exported symbols.\n\n shared\n\nThe shared library produced by the C compiler from the leanArts (that is, a *.so, *.dll, or *.dylib file, depending on the platform).\n\n extraDep\n\nA Lean library's extraDepTargets and those of its package.\n\n\n\nExecutables have a single exe facet that consists of the executable binary.\n\n\n\nThe facets available for modules are: lean\n\nThe module's Lean source file.\n\n leanArts (default)\n\nThe module's Lean artifacts (*.olean, *.ilean, *.c files).\n\n deps\n\nThe module's dependencies (e.g., imports or shared libraries).\n\n olean\n\nThe module's .olean file. \n\n ilean\n\nThe module's .ilean file, which is metadata used by the Lean language server.\n\n header\n\nThe parsed module header of the module's source file.\n\n input\n\nThe module's processed Lean source file. Combines tracing the file with parsing its header.\n\n imports\n\nThe immediate imports of the Lean module, but not the full set of transitive imports.\n\n precompileImports\n\nThe transitive imports of the Lean module, compiled to object code.\n\n transImports\n\nThe transitive imports of the Lean module, as .olean files.\n\n allImports\n\nBoth the immediate and transitive imports of the Lean module.\n\n setup\n\nAll of a module's dependencies: transitive local imports and shared libraries to be loaded with --load-dynlib.\n  Returns the list of shared libraries to load along with their search path.\n\n c\n\nThe C file produced by the Lean compiler.\n\n bc\n\nLLVM bitcode file, produced by the Lean compiler.\n\n c.o\n\nThe compiled object file, produced from the C file. On Windows, this is equivalent to .c.o.noexport, while it is equivalent to .c.o.export on other platforms.\n\n c.o.export\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n c.o.noexport\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n bc.o\n\nThe compiled object file, produced from the LLVM bitcode file.\n\n o\n\nThe compiled object file for the configured backend.\n\n dynlib\n\nA shared library (e.g., for the Lean option --load-dynlib).\n\n\n\n"},"/Build-Tools-and-Distribution/Lake/#lake-config":{"id":"/Build-Tools-and-Distribution/Lake/#lake-config","header":"22.1.3. Configuration File Format","context":"Lean Reference\u0009Build Tools\u0009Lake","contents":"Lake offers two formats for package configuration files: TOML\n\nThe TOML configuration format is fully declarative.\n  Projects that don't include custom targets, facets, or scripts can use the TOML format.\n  Because TOML parsers are available for a wide variety of languages, using this format facilitates integration with tools that are not written in Lean.\n\n Lean\n\nThe Lean configuration format is more flexible and allows for custom targets, facets, and scripts.\n  It features an embedded domain-specific language for describing the declarative subset of configuration options that is available from the TOML format.\n  Additionally, the Lake API can be used to express build configurations that are outside of the possibilities of the declarative options.\n\nThe command translate-config can be used to automatically convert between the two formats.\n\nBoth formats are processed similarly by Lake, which extracts the package configuration from the configuration file in the form of internal structure types.\nWhen the package is configured, the resulting data structures are written to lakefile.olean in the build directory.\n\n\n\n\n\n"},"/Basic-Types/Natural-Numbers/#nat-runtime":{"id":"/Basic-Types/Natural-Numbers/#nat-runtime","header":"19.1.2. Run-Time Representation","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","contents":"The representation suggested by the declaration of Nat would be horrendously inefficient, as it's essentially a linked list.\nThe length of the list would be the number.\nWith this representation, addition would take time linear in the size of one of the addends, and numbers would take at least as many machine words as their magnitude in memory.\nThus, natural numbers have special support in both the kernel and the compiler that avoids this overhead.\n\nIn the kernel, there are special Nat literal values that use a widely-trusted, efficient arbitrary-precision integer library (usually GMP).\nBasic functions such as addition are overridden by primitives that use this representation.\nBecause they are part of the kernel, if these primitives did not correspond to their definitions as Lean functions, it could undermine soundness.\n\nIn compiled code, sufficiently-small natural numbers are represented without pointer indirections: the lowest-order bit in an object pointer is used to indicate that the value is not, in fact, a pointer, and the remaining bits are used to store the number.\n31 bits are available on 32-bits architectures for pointer-free Nats, while 63 bits are available on 64-bit architectures.\nIn other words, natural numbers smaller than 2^{31} = 2,147,483,648 or 2^{63} = 9,223,372,036,854,775,808 do not require allocations.\nIf an natural number is too large for this representation, it is instead allocated as an ordinary Lean object that consists of an object header and an arbitrary-precision integer value.\n\n\n\n"},"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model":{"id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model","header":"19.4.1. Logical Model","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","contents":"Fixed-width integers may be unsigned or signed.\nFurthermore, they are available in five sizes: 8, 16, 32, and 64 bits, along with the current architecture's word size.\nIn their logical models, the unsigned integers are structures that wrap a BitVec of the appropriate width.\nSigned integers wrap the corresponding unsigned integers, and use a twos-complement representation.\n\n\n\n\n\n"}});