window.docContents[164].resolve({"/The-Type-System/Propositions/#propositions":{"id":"/The-Type-System/Propositions/#propositions","header":"4.2. Propositions","context":"Lean Reference\u0009Type System","contents":"Propositions are meaningful statements that admit proof. \nNonsensical statements are not propositions, but false statements are.\nAll propositions are classified by Prop.\n\nPropositions have the following properties:\n\n Definitional proof irrelevance\n\nAny two proofs of the same proposition are completely interchangeable.\n\n Run-time irrelevance\n\nPropositions are erased from compiled code.\n\n Impredicativity\n\nPropositions may quantify over types from any universe whatsoever.\n\n Restricted Elimination\n\nWith the exception of subsingletons, propositions cannot be eliminated into non-proposition types.\n\n Extensionality \n\nAny two logically equivalent propositions can be proven to be equal with the propext axiom.\n\n\n\nThe axiom of propositional extensionality. It asserts that if propositions\na and b are logically equivalent (i.e. we can prove a from b and vice versa),\nthen a and b are equal, meaning that we can replace a with b in all\ncontexts.For simple expressions like a ∧ c ∨ d → e we can prove that because all the logical\nconnectives respect logical equivalence, we can replace a with b in this expression\nwithout using propext. However, for higher order expressions like P a where\nP : Prop → Prop is unknown, or indeed for a = b itself, we cannot replace a with b\nwithout an axiom which says exactly this.This is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using #reduce to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type Nat normalize to numerals,\nfails to hold when this (or any) axiom is used:set_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True → True) ↔ True := ⟨λ _ => trivial, λ _ _ => trivial⟩\n  have := propext this ▸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } ▸ 2\n\n#eval foo -- 2\n#eval can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so propext, whose return type is a proposition,\ncan never block it.\n\n"},"/Tactic-Proofs/The-Tactic-Language/#tactic-language-hygiene":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-hygiene","header":"13.3.2. Names and Hygiene","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language","contents":"Behind the scenes, tactics generate proof terms.\nThese proof terms exist in a local context, because assumptions in proof states correspond to local binders in terms.\nUses of assumptions correspond to variable references.\nIt is very important that the naming of assumptions be predictable; otherwise, small changes to the internal implementation of a tactic could either lead to variable capture or to a broken reference if they cause different names to be selected.\n\nLean's tactic language is hygienic. \nThis means that the tactic language respects lexical scope: names that occur in a tactic refer to the enclosing binding in the source code, rather than being determined by the generated code, and the tactic framework is responsible for maintaining this property.\nVariable references in tactic scripts refer either to names that were in scope at the beginning of the script or to bindings that were explicitly introduced as part of the tactics, rather than to the names chosen for use in the proof term behind the scenes.\n\nA consequence of hygienic tactics is that the only way to refer to an assumption is to explicitly name it.\nTactics cannot assign assumption names themselves, but must rather accept names from users; users are correspondingly obligated to provide names for assumptions that they wish to refer to.\nWhen an assumption does not have a user-provided name, it is shown in the proof state with a dagger ('†', DAGGER\u00090x2020).\nThe dagger indicates that the name is inaccessible and cannot be explicitly referred to.\n\nHygiene can be disabled by setting the option tactic.hygienic to false.\nThis is not recommended, as many tactics rely on the hygiene system to prevent capture and thus do not incur the overhead of careful manual name selection.\n\nmake sure tactics are hygienic\n\nTactic hygiene: inaccessible assumptionsWhen proving that ∀ (n : Nat), 0 + n = n, the initial proof state is:⊢ ∀ (n : Nat), 0 + n = n\nThe tactic intro results in a proof state with an inaccessible assumption:n✝ : Nat\n⊢ 0 + n✝ = n✝\n\n\nTactic hygiene: accessible assumptionsWhen proving that ∀ (n : Nat), 0 + n = n, the initial proof state is:⊢ ∀ (n : Nat), 0 + n = n\nThe tactic intro n, with the explicit name n, results in a proof state with an accessibly-named assumption:n : Nat\n⊢ 0 + n = n\n\n\n\n\n"},"/Tactic-Proofs/Tactic-Reference/#tactic-ref":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref","header":"13.5. Tactic Reference","context":"Lean Reference\u0009Tactic Proofs","contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Interacting-with-Lean/#The-Lean-Language-Reference--Interacting-with-Lean--Formatted-Output--Format--The--ToFormat--Class":{"id":"/Interacting-with-Lean/#The-Lean-Language-Reference--Interacting-with-Lean--Formatted-Output--Format--The--ToFormat--Class","header":"3.7.1.7. The  ToFormat  Class","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Format","contents":"The Std.ToFormat class is used to provide a standard means to format a value, with no expectation that this formatting be valid Lean syntax.\nThese instances are used in error messages and by some of the sequence concatenation operators.\n\nSpecifies a “user-facing” way to convert from the type α to a Format object. There is no\nexpectation that the resulting string is valid code.The Repr class is similar, but the expectation is that instances produce valid Lean code.\n\n"},"/Basic-Types/Bitvectors/#BitVec-automation":{"id":"/Basic-Types/Bitvectors/#BitVec-automation","header":"19.5.4. Automation","context":"Lean Reference\u0009Basic Types\u0009Bitvectors","contents":"In addition to the full suite of automation and tools provided by Lean for every type, the bv_decide tactic can solve many bitvector-related problems.\nThis tactic invokes an external automated theorem prover (cadical) and reconstructs the proof that it provides in Lean's own logic.\nThe resulting proofs rely only on the axiom Lean.ofReduceBool; the external prover is not part of the trusted code base.\n\nPopcountThe function popcount returns the number of set bits in a bitvector.\nIt can be implemented as a 32-iteration loop that tests each bit, incrementing a counter if the bit is set:def popcount_spec (x : BitVec 32) : BitVec 32 :=\n  (32 : Nat).fold (init := 0) fun i _ pop =>\n    pop + ((x >>> i) &&& 1)\nAn alternative implementation of popcount is described in Hacker's Delight, Second Edition, by Henry S. Warren,\nJr. in Figure 5-2 on p. 82.\nIt uses low-level bitwise operations to compute the same value with far fewer operations:def popcount (x : BitVec 32) : BitVec 32 :=\n  let x := x - ((x >>> 1) &&& 0x55555555)\n  let x := (x &&& 0x33333333) + ((x >>> 2) &&& 0x33333333)\n  let x := (x + (x >>> 4)) &&& 0x0F0F0F0F\n  let x := x + (x >>> 8)\n  let x := x + (x >>> 16)\n  let x := x &&& 0x0000003F\n  x\nThese two implementations can be proven equivalent using bv_decide:theorem popcount_correct : popcount = popcount_spec := by\n  funext x\n  simp [popcount, popcount_spec]\n  bv_decide\n\n\n"}});