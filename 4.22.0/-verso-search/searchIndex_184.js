window.docContents[184].resolve({"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals":{"id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-goals","header":"13.6.2. Goal Selection","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","contents":"all_goals tac runs tac on each goal, concatenating the resulting goals, if any.\n\nany_goals tac applies the tactic tac to every goal, and succeeds if at\nleast one application succeeds.\n\n* case tag => tac focuses on the goal with case name tag and solves it using tac,\nor else fails.* case tag x₁ ... xₙ => tac additionally renames the n most recent hypotheses\nwith inaccessible names to the given names.* case tag₁ | tag₂ => tac is equivalent to (case tag₁ => tac); (case tag₂ => tac).\n\ncase' is similar to the case tag => tac tactic, but does not ensure the goal\nhas been solved after applying tac, nor admits the goal if tac failed.\nRecall that case closes the goal using sorry when tac fails, and\nthe tactic execution is not interrupted.\n\nnext => tac focuses on the next goal and solves it using tac, or else fails.\nnext x₁ ... xₙ => tac additionally renames the n most recent hypotheses with\ninaccessible names to the given names.\n\nfocus tac focuses on the main goal, suppressing all other goals, and runs tac on it.\nUsually · tac, which enforces that the goal is closed by tac, should be preferred.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\n· conv focuses on the main conv goal and tries to solve it using s.\n\nfail_if_success t fails if the tactic t succeeds.\n\n"},"/Build-Tools-and-Distribution/Lake/#test-lint-drivers":{"id":"/Build-Tools-and-Distribution/Lake/#test-lint-drivers","header":"22.1.1.4. Test and Lint Drivers","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","contents":"A test driver is responsible for running the tests for a package.\nTest drivers may be executable targets or Lake scripts, in which case the test command runs them, or they may be libraries, in which case test causes them to be elaborated, with the expectation that test failures are registered as elaboration failures.\n\nSimilarly, a lint driver is responsible for checking the code for stylistic issues.\nLint drivers may be executables or scripts, which are run by lint.\n\nA test or lint driver can be configured by either setting the testDriver or lintDriver package configuration options or by tagging a script, executable, or library with the test_driver or lint_driver attribute in a Lean-format configuration file.\nA definition in a dependency can be used as a test or lint driver by using the <pkg>/<name> syntax for the appropriate configuration option.\n\n\n\n"}});