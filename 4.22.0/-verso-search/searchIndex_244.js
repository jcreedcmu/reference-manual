window.docContents[244].resolve({"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-formal-statement":{"id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if---then---else--Normalization--The-formal-statement","header":"17.9.2.2. The formal statement","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if - then - else  Normalization","contents":"To formalize the statement in Lean, we use an inductive type IfExpr:\n\n/--\nAn if-expression is either boolean literal, a\nnumbered variable, or an if-then-else expression\nwhere each subexpression is an if-expression.\n-/\ninductive IfExpr\n  | lit : Bool → IfExpr\n  | var : Nat → IfExpr\n  | ite : IfExpr → IfExpr → IfExpr → IfExpr\nderiving DecidableEq\n\n\nand define some inductive predicates and an eval function, so we can state the four desired properties:\n\nnamespace IfExpr\n\n/--\nAn if-expression has a \"nested if\" if it contains\nan if-then-else where the \"if\" is itself an if-then-else.\n-/\ndef hasNestedIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (ite _ _ _) _ _ => true\n  | ite _ t e => t.hasNestedIf || e.hasNestedIf\n\n/--\nAn if-expression has a \"constant if\" if it contains\nan if-then-else where the \"if\" is itself a literal.\n-/\ndef hasConstantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite (lit _) _ _ => true\n  | ite i t e =>\n    i.hasConstantIf || t.hasConstantIf || e.hasConstantIf\n\n/--\nAn if-expression has a \"redundant if\" if\nit contains an if-then-else where\nthe \"then\" and \"else\" clauses are identical.\n-/\ndef hasRedundantIf : IfExpr → Bool\n  | lit _ => false\n  | var _ => false\n  | ite i t e => t == e || i.hasRedundantIf ||\n      t.hasRedundantIf || e.hasRedundantIf\n\n/--\nAll the variables appearing in an if-expressions,\nread left to right, without removing duplicates.\n-/\ndef vars : IfExpr → List Nat\n  | lit _ => []\n  | var i => [i]\n  | ite i t e => i.vars ++ t.vars ++ e.vars\n\n/--\nA helper function to specify that two lists are disjoint.\n-/\ndef _root_.List.disjoint {α} [DecidableEq α] :\n    List α → List α → Bool\n  | [], _ => true\n  | x::xs, ys => x ∉ ys && xs.disjoint ys\n\n/--\nAn if expression evaluates each variable at most once if\nfor each if-then-else the variables in the \"if\" clause\nare disjoint from the variables in the \"then\" clause\nand the variables in the \"if\" clause\nare disjoint from the variables in the \"else\" clause.\n-/\ndef disjoint : IfExpr → Bool\n  | lit _ => true\n  | var _ => true\n  | ite i t e =>\n      i.vars.disjoint t.vars && i.vars.disjoint e.vars &&\n        i.disjoint && t.disjoint && e.disjoint\n\n/--\nAn if expression is \"normalized\" if it has\nno nested, constant, or redundant ifs,\nand it evaluates each variable at most once.\n-/\ndef normalized (e : IfExpr) : Bool :=\n  !e.hasNestedIf && !e.hasConstantIf &&\n    !e.hasRedundantIf && e.disjoint\n\n/--\nThe evaluation of an if expression\nat some assignment of variables.\n-/\ndef eval (f : Nat → Bool) : IfExpr → Bool\n  | lit b => b\n  | var i => f i\n  | ite i t e => bif i.eval f then t.eval f else e.eval f\n\nend IfExpr\n\n\nUsing these we can state the problem. The challenge is to inhabit the following type (and to do so nicely!):\n\ndef IfNormalization : Type :=\n  { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }\n\n\n"},"/Definitions/Headers-and-Signatures/#The-Lean-Language-Reference--Definitions--Headers-and-Signatures--Declaration-Names":{"id":"/Definitions/Headers-and-Signatures/#The-Lean-Language-Reference--Definitions--Headers-and-Signatures--Declaration-Names","header":"7.2.1. Declaration Names","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","contents":"Most headers begin with a declaration name, which is followed by the signature proper: its parameters and the resulting type.\nA declaration name is a name that may optionally include universe parameters.\n\nDeclaration NamesDeclaration names without universe parameters consist of an identifier:Declaration names with universe parameters consist of an identifier followed by a period and one or more universe parameter names in braces:These universe parameter names are binding occurrences.\n\nExamples do not include declaration names, and names are optional for instance declarations.\n\n"},"/Coercions/Implementation-Details/#coercion-unfold-impl":{"id":"/Coercions/Implementation-Details/#coercion-unfold-impl","header":"12.5.1. Unfolding Coercions","context":"Lean Reference\u0009Coercions\u0009Implementation Details","contents":"The coercion insertion mechanism unfolds applications of coercions, which allows them to control the specific shape of the resulting term.\nThis is important both to ensure readable proof goals and to control evaluation of the coerced term in compiled code.\nUnfolding coercions is controlled by the coe_decl attribute, which is applied to each coercion method (e.g. Coe.coe).\nThis attribute should be considered part of the internals of the coercion mechanism, rather than part of the public coercion API.\n\n"},"/Basic-Types/Characters/#char-api-classes":{"id":"/Basic-Types/Characters/#char-api-classes","header":"19.7.4.2. Character Classes","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","contents":"Returns true if the character is an ASCII letter.The ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.\n\nReturns true if the character is an ASCII letter or digit.The ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.\nThe ASCII digits are the following: 0123456789.\n\nReturns true if the character is an ASCII digit.The ASCII digits are the following: 0123456789.\n\nReturns true if the character is a lowercase ASCII letter.The lowercase ASCII letters are the following: abcdefghijklmnopqrstuvwxyz.\n\nReturns true if the character is a uppercase ASCII letter.The uppercase ASCII letters are the following: ABCDEFGHIJKLMNOPQRSTUVWXYZ.\n\nReturns true if the character is a space (' ', U+0020), a tab ('\\t', U+0009), a carriage\nreturn ('\\r', U+000D), or a newline ('\\n', U+000A).\n\n"},"/Basic-Propositions/Propositional-Equality/#propositional-equality":{"id":"/Basic-Propositions/Propositional-Equality/#propositional-equality","header":"18.4. Propositional Equality","context":"Lean Reference\u0009Basic Propositions","contents":"Propositional equality is the operator that allows the equality of two terms to be stated as a proposition.\nDefinitional equality is checked automatically where necessary.\nAs a result, its expressive power is limited in order to keep the algorithm that checks it fast and understandable.\nPropositional equality, on the other hand, must be explicitly proved and explicitly used—Lean checks the validity of the proofs, rather than determining whether the statement is true.\nIn exchange, it is much more expressive: many terms are propositionally equal without being definitionally equal.\n\nPropositional equality is defined as an inductive type.\nIts sole constructor Eq.refl requires that both of the equated values be the same; this is implicitly an appeal to definitional equality.\nPropositional equality can also be thought of as the least reflexive relation modulo definitional equality.\nIn addition to Eq.refl, equality proofs are generated by the propext and Quot.sound axioms.\n\nThe equality relation. It has one introduction rule, Eq.refl.\nWe use a = b as notation for Eq a b.\nA fundamental property of equality is that it is an equivalence relation.variable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given h1 : a = b and h2 : p a, we can construct a proof for p b using substitution: Eq.subst h1 h2.\nExample:example (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\nThe triangle in the second presentation is a macro built on top of Eq.subst and Eq.symm, and you can enter it by typing \\t.\nFor more information: EqualityConventions for notations in identifiers:* The recommended spelling of = in identifiers is eq.Eq.refl a : a = a is reflexivity, the unique constructor of the\nequality type. See also rfl, which is usually used instead.\n\nPropositional EqualityPropositional equality is typically denoted by the infix = operator.\n\nrfl : a = a is the unique constructor of the equality type. This is the\nsame as Eq.refl except that it takes a implicitly instead of explicitly.This is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is a = a, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, 2 + 2 = 4 is proven in\nLean by rfl, because both sides are the same up to definitional equality.\n\nEquality is symmetric: if a = b then b = a.Because this is in the Eq namespace, if you have a variable h : a = b,\nh.symm can be used as shorthand for Eq.symm h as a proof of b = a.For more information: Equality\n\nEquality is transitive: if a = b and b = c then a = c.Because this is in the Eq namespace, if you have variables or expressions\nh₁ : a = b and h₂ : b = c, you can use h₁.trans h₂ : a = c as shorthand\nfor Eq.trans h₁ h₂.For more information: Equality\n\nThe substitution principle for equality. If a = b  and P a holds,\nthen P b also holds. We conventionally use the name motive for P here,\nso that you can specify it explicitly using e.g.\nEq.subst (motive := fun x => x < 5) if it is not otherwise inferred correctly.This theorem is the underlying mechanism behind the rw tactic, which is\nessentially a fancy algorithm for finding good motive arguments to usefully\napply this theorem to replace occurrences of a with b in the goal or\nhypotheses.For more information: Equality\n\nCast across a type equality. If h : α = β is an equality of types, and\na : α, then a : β will usually not typecheck directly, but this function\nwill allow you to work around this and embed a in type β as cast h a : β.It is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.For more information: Equality\n\nCongruence in both function and argument. If f₁ = f₂ and a₁ = a₂ then\nf₁ a₁ = f₂ a₂. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.For more information: Equality\n\nCongruence in the function part of an application: If f = g then f a = g a.\n\nCongruence in the function argument: if a₁ = a₂ then f a₁ = f a₂ for\nany (nondependent) function f. This is more powerful than it might look at first, because\nyou can also use a lambda expression for f to prove that\n<something containing a₁> = <something containing a₂>. This function is used\ninternally by tactics like congr and simp to apply equalities inside\nsubterms.For more information: Equality\n\nIf h : α = β is a proof of type equality, then h.mp : α → β is the induced\n\"cast\" operation, mapping elements of α to elements of β.You can prove theorems about the resulting element by induction on h, since\nrfl.mp is definitionally the identity function.\n\nIf h : α = β is a proof of type equality, then h.mpr : β → α is the induced\n\"cast\" operation in the reverse direction, mapping elements of β to elements of α.You can prove theorems about the resulting element by induction on h, since\nrfl.mpr is definitionally the identity function.\n\nCastingWhen a term's type includes one side of an equality as a sub-term, it can be rewritten using the ▸ operator.\nIf the both sides of the equality occur in the term's type, then the left side is rewritten to the right.\n\n\n\n\n\n"}});