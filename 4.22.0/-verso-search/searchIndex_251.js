window.docContents[251].resolve({"/Type-Classes/#type-classes":{"id":"/Type-Classes/#type-classes","header":"11. Type Classes","context":"Lean Reference","contents":"An operation is polymorphic if it can be used with multiple types.\nIn Lean, polymorphism comes in three varieties:\n\n1. universe polymorphism, where the sorts in a definition can be instantiated in various ways,2. functions that take types as (potentially implicit) parameters, allowing a single body of code to work with any type, and3. ad-hoc polymorphism, implemented with type classes, in which operations to be overloaded may have different implementations for different types.\n\nBecause Lean does not allow case analysis of types, polymorphic functions implement operations that are uniform for any choice of type argument; for example, List.map does not suddenly compute differently depending on whether the input list contains Strings or Nats.\nAd-hoc polymorphic operations are useful when there is no “uniform” way to implement an operation; the canonical use case is for overloading arithmetic operators so that they work with Nat, Int, Float, and any other type that has a sensible notion of addition.\nAd-hoc polymorphism may also involve multiple types; looking up a value at a given index in a collection involves the collection type, the index type, and the type of member elements to be extracted.\nA type classType classes were first described in  describes a collection of overloaded operations (called methods) together with the involved types.\n\nType classes are very flexible.\nOverloading may involve multiple types; operations like indexing into a data structure can be overloaded for a specific choice of data structure, index type, element type, and even a predicate that asserts the presence of the key in the structure.\nDue to Lean's expressive type system, overloading operations is not restricted only to types; type classes may be parameterized by ordinary values, by families of types, and even by predicates or propositions.\nAll of these possibilities are used in practice:\n\n Natural number literals\n\nThe OfNat type class is used to interpret natural number literals.\n  Instances may depend not only on the type being instantiated, but also on the number literal itself.\n\n Computational effects\n\nType classes such as Monad, whose parameter is a function from one type to another, are used to provide special syntax for programs with side effects.\n  The “type” for which operations are overloaded is actually a type-level function, such as Option, IO, or Except.\n\n Predicates and propositions\n\nThe Decidable type class allows a decision procedure for a proposition to be found automatically by Lean.\n  This is used as the basis for if-expressions, which may branch on any decidable proposition.\n\n\n\nWhile ordinary polymorphic definitions simply expect instantiation with arbitrary parameters, the operators overloaded with type classes are to be instantiated with instances that define the overloaded operation for some specific set of parameters.\nThese instance-implicit parameters are indicated in square brackets.\nAt invocation sites, Lean either synthesizes   a suitable instance from the available candidates or signals an error.\nBecause instances may themselves have instance parameters, this search process may be recursive and result in a final composite instance value that combines code from a variety of instances.\nThus, type class instance synthesis is also a means of constructing programs in a type-directed manner.\n\nHere are some typical use cases for type classes:\n\n* Type classes may represent overloaded operators, such as arithmetic that can be used with a variety of types of numbers or a membership predicate that can be used for a variety of data structures. There is often a single canonical choice of operator for a given type—after all, there is no sensible alternative definition of addition for Nat—but this is not an essential property, and libraries may provide alternative instances if needed.* Type classes can represent an algebraic structure, providing both the extra structure and the axioms required by the structure. For example, a type class that represents an Abelian group may contain methods for a binary operator, a unary inverse operator, an identity element, as well as proofs that the binary operator is associative and commutative, that the identity is an identity, and that the inverse operator yields the identity element on both sides of the operator. Here, there may not be a canonical choice of structure, and a library may provide many ways to instantiate a given set of axioms; there are two equally canonical monoid structures over the integers.* A type class can represent a relation between two types that allows them to be used together in some novel way by a library.\n   The Coe class represents automatically-inserted coercions from one type to another, and MonadLift represents a way to run operations with one kind of effect in a context that expects another kind.* Type classes can represent a framework of type-driven code generation, where instances for polymorphic types each contribute some portion of a final program.\n    The Repr class defines a canonical pretty printer for a type, and polymorphic types end up with polymorphic Repr instances.\n    When pretty printing is finally invoked on an expression with a known concrete type, such as List (Nat × (String ⊕ Int)), the resulting pretty printer contains code assembled from the Repr instances for List, Prod, Nat, Sum, String, and Int.\n\n\n\n\n\n\n\n\n\n\n\n"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Positions":{"id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Positions","header":"19.8.4.10.2. Positions","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","contents":"Checks whether a position in a substring is precisely equal to its ending position.The position is understood relative to the substring's starting position, rather than the underlying\nstring's starting position.\n\nReturns the substring-relative position of the first occurrence of c in s, or s.bsize if c\ndoesn't occur.\n\nReturns the next position in a substring after the given position. If the position is at the end of\nthe substring, it is returned unmodified.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the position that's the specified number of characters forward from the given position in a\nsubstring. If the end position of the substring is reached, it is returned.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the previous position in a substring, just prior to the given position. If the position is\nat the beginning of the substring, it is returned unmodified.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\nReturns the position that's the specified number of characters prior to the given position in a\nsubstring. If the start position of the substring is reached, it is returned.Both the input position and the returned position are interpreted relative to the substring's start\nposition, not the underlying string.\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Queries","header":"19.17.10.3. Queries","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","contents":"Returns true if a, or an element equal to a according to the comparator cmp, is contained\nin the set. There is also a Prop-valued version of this: a ∈ t is equivalent to\nt.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains uses\n== for equality checks, while for tree sets, both use the given comparator cmp.\n\nRetrieves the key from the set that matches a. Ensures that such a key exists by requiring a proof\nof a ∈ m. The result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the map.\n\nChecks if given key is contained and returns the key if it is, otherwise fallback.\nIf they key is contained the result is guaranteed to be pointer equal to the key in the set.\n\n\n\n"}});