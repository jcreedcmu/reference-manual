window.docContents[124].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-quantifiers","header":"13.5.3. Quantifiers","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"exists e₁, e₂, ... is shorthand for refine ⟨e₁, e₂, ...⟩; try trivial.\nIt is useful for existential goals.\n\nIntroduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a let or function type.* intro by itself introduces one anonymous hypothesis, which can be accessed\nby e.g. assumption.* intro x y introduces two hypotheses and names them. Individual hypotheses\ncan be anonymized via _, or matched against a pattern:-- ... ⊢ α × β → ...\nintro (a, b)\n-- ..., a : α, b : β ⊢ ...\n* Alternatively, intro can be combined with pattern matching much like fun:intro\n| n + 1, 0 => tac\n| ...\n\n\nIntroduces zero or more hypotheses, optionally naming them.* intros is equivalent to repeatedly applying intro\nuntil the goal is not an obvious candidate for intro, which is to say\nthat so long as the goal is a let or a pi type (e.g. an implication, function, or universal quantifier),\nthe intros tactic will introduce an anonymous hypothesis.\nThis tactic does not unfold definitions.* intros x y ... is equivalent to intro x y ...,\nintroducing hypotheses for each supplied argument and unfolding definitions as necessary.\nEach argument can be either an identifier or a _.\nAn identifier indicates a name to use for the corresponding introduced hypothesis,\nand a _ indicates that the hypotheses should be introduced anonymously.ExamplesBasic properties:def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\nImplications:example (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\nLet bindings:example : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n\n\nThe tacticintro\n| pat1 => tac1\n| pat2 => tac2\nis the same as:intro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\nThat is, intro can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to fun with match arms in term mode.\n\nThe rintro tactic is a combination of the intros tactic with rcases to\nallow for destructuring patterns while introducing variables. See rcases for\na description of supported patterns. For example, rintro (a | ⟨b, c⟩) ⟨d, e⟩\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables a d e and the other with b c d e.rintro, unlike rcases, also supports the form (x y : ty) for introducing\nand type-ascripting multiple variables at once, similar to binders.\n\n"},"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Modifications":{"id":"/Basic-Types/Strings/#The-Lean-Language-Reference--Basic-Types--Strings--API-Reference--Substrings--Modifications","header":"19.8.4.10.7. Modifications","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference\u0009Substrings","contents":"Removes the specified number of characters (Unicode code points) from the beginning of a substring\nby advancing its start position.If the substring's end position is reached, the start position is not advanced past it.\n\nRemoves the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position. The start position is moved to the position of\nthe first character for which the predicate returns false, or to the substring's end position if\nthe predicate always returns true.\n\nRemoves the specified number of characters (Unicode code points) from the end of a substring\nby moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRemoves the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position. The end position is moved just after the position\nof the last character for which the predicate returns false, or to the substring's start position\nif the predicate always returns true.\n\nRetains only the specified number of characters (Unicode code points) at the beginning of a\nsubstring, by moving its end position towards its start position.If the substring's start position is reached, the end position is not retracted past it.\n\nRetains only the longest prefix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's end position towards its start position.\n\nRetains only the specified number of characters (Unicode code points) at the end of a substring, by\nmoving its start position towards its end position.If the substring's end position is reached, the start position is not advanced past it.\n\nRetains only the longest suffix of a substring in which a Boolean predicate returns true for all\ncharacters by moving the substring's start position towards its end position.\n\nReturns the region of the substring delimited by the provided start and stop positions, as a\nsubstring. The positions are interpreted with respect to the substring's start position, rather than\nthe underlying string.If the resulting substring is empty, then the resulting substring is a substring of the empty string\n\"\". Otherwise, the underlying string is that of the input substring with the beginning and end\npositions adjusted.\n\nRemoves leading and trailing whitespace from a substring by first moving its start position to the\nfirst non-whitespace character, and then moving its end position to the last non-whitespace\ncharacter.If the substring consists only of whitespace, then the resulting substring's start position is moved\nto its end position.“Whitespace” is defined as characters for which Char.isWhitespace returns true.Examples:* \" red green blue \".toSubstring.trim.toString = \"red green blue\"* \" red green blue \".toSubstring.trim.startPos = ⟨1⟩* \" red green blue \".toSubstring.trim.stopPos = ⟨15⟩* \"     \".toSubstring.trim.startPos = ⟨5⟩\n\nRemoves leading whitespace from a substring by moving its start position to the first non-whitespace\ncharacter, or to its end position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nRemoves trailing whitespace from a substring by moving its end position to the last non-whitespace\ncharacter, or to its start position if there is no non-whitespace character.“Whitespace” is defined as characters for which Char.isWhitespace returns true.\n\nSplits a substring s on occurrences of the separator string sep. The default separator is \" \".When sep is empty, the result is [s]. When sep occurs in overlapping patterns, the first match\nis taken. There will always be exactly n+1 elements in the returned list if there were n\nnon-overlapping matches of sep in the string. The separators are not included in the returned\nsubstrings, which are all substrings of s's string.\n\n"}});