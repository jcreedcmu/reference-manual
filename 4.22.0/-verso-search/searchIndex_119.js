window.docContents[119].resolve({"/The--grind--tactic/Congruence-Closure/#congruence-closure":{"id":"/The--grind--tactic/Congruence-Closure/#congruence-closure","header":"17.2. Congruence Closure","context":"Lean Reference\u0009The  grind  tactic","contents":"Congruence closure maintains equivalence classes of terms under the reflexive, symmetric, and transitive closure of “is equal to” and the rule that equal arguments yield equal function results.\nFormally, if a = a' and b = b', then f a b = f a' b' is added.\nThe algorithm merges equivalence classes until a fixed point is reached.\nIf a contradiction is discovered, then the goal can be closed immediately.\n\nUsing the analogy of the shared whiteboard:1. Every hypothesis h : t₁ = t₂ writes a line connecting t₁ and t₂.2. Whenever two terms are connected by one or more lines, they're considered to be equal.\n   Soon, whole constellations (f a, g (f a), …) are connected.3. If two different constructors of the same inductive type are connected by one or more lines, then a contradiction is discovered and the goal is closed.\n   For example, equating True and False or none and some 1 would be a contradiction.\n\nCongruence ClosureThis theorem is proved using congruence closure:example {α} (f g : α → α) (x y : α)\n    (h₁ : x = y) (h₂ : f y = g y) :\n    f x = g x := by\n  grind\nInitially, f y, g y, x, and y are in separate equivalence classes.\nThe congruence closure engine uses h₁ to merge x and y, after which the equivalence classes are {x, y}, f y, and g y.\nNext, h₂ is used to merge f y and g y, after which the classes are {x, y} and {f y, g y}.\nThis is sufficient to prove that f x = g x, because y and x are in the same class.Similar reasoning is used for constructors:example (a b c : Nat) (h : a = b) : (a, c) = (b, c) := by\n  grind\nBecause the pair constructor Prod.mk obeys congruence, the tuples become equal as soon as a and b are placed in the same class.\n\n\n\n"},"/Basic-Types/Maps-and-Sets/#DHashMap":{"id":"/Basic-Types/Maps-and-Sets/#DHashMap","header":"19.17.3. Dependent Hash Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.DHashMap.\n\nDependent hash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DHashMap.Raw and\nStd.DHashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nDHashMap over DHashMap.Raw.For a variant that is more convenient for use in proofs because of extensionalities, see\nStd.ExtDHashMap which is defined in the module Std.Data.ExtDHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});