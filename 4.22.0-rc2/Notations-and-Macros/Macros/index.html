<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Macros</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="static/search/fuzzysort.js"></script>
    <script src="static/print.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/colors.css">
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/print.css">
    <link rel="stylesheet" href="static/search/search-box.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
a.elan-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.elan-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
a.lake-command {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.lake-command:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
span.TODO {
  border: 3px solid red;
  display: inline;
  position: relative;
  float: right;
  clear: right;
  margin-top: 1rem;
  width: 15vw;
  margin-right: -17vw;
  color: red;
  font-size: large;
  font-weight: bold;
}
</style><style>
.hl.lean.tactic-view {
  white-space: collapse;
}
.hl.lean.tactic-view .tactic-state {
  display: block;
  left: 0;
  padding: 0;
  border: none;
}
.hl.lean.tactic-view .tactic-state .goal {
  margin-top: 1em;
  margin-bottom: 1em;
  display: block;
}
.hl.lean.tactic-view .tactic-state .goal:first-child {
  margin-top: 0.25em;
}
.hl.lean.tactic-view .tactic-state .goal:last-child {
  margin-bottom: 0.25em;
}


</style><style>
.namedocs .title {
  font-family: var(--verso-structure-font-family);
  font-size: 1.1rem;
  margin-top: 0;
  margin-left: 1rem;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  display: inline-block;
}
</style><style>
.marginalia .note {
  position: relative;
  padding: 0.5rem;
}

/* Wide viewport */
@media screen and (min-width: 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    margin-right: -16rem;
    width: 13rem;
    margin-top: 1rem;
  }
}

/* Very wide viewport */
@media screen and (min-width: 1600px) {
  .marginalia .note {
    margin-right: -19vw;
    width: 15vw;
  }
}

.marginalia:hover, .marginalia:hover .note, .marginalia:has(.note:hover) {
  background-color: var(--lean-accent-light-blue);
}

/* Medium viewport */
@media screen and (700px < width <= 1400px) {
  .marginalia .note {
    float: right;
    clear: right;
    width: 40%;
    margin: 1rem 0;
    margin-left: 10%;
  }
}

/* Narrow viewport (e.g. phone) */
@media screen and (width <= 700px) {
  .marginalia .note {
    float: left;
    clear: left;
    width: 90%;
    margin: 1rem 5%;
  }
}

body {
  counter-reset: margin-note-counter;
}
.marginalia .note {
  counter-increment: margin-note-counter;
}
.marginalia .note::before {
  content: counter(margin-note-counter) ".";
  position: absolute;
  vertical-align: baseline;
  font-size: 0.9em;
  font-weight: bold;
  left: -3rem;
  width: 3rem;
  text-align: right;
}
.marginalia::after {
  content: counter(margin-note-counter);
  vertical-align: super;
  font-size: 0.7em;
  font-weight: bold;
  margin-right: 0.5em;
}
</style><style>
.namedocs {
  position: relative;
  border: solid 1px #98B2C0;
  border-radius: .5rem;
  padding-top: var(--verso--box-padding);
  margin-top: var(--verso--box-vertical-margin);
  margin-bottom: var(--verso--box-vertical-margin);
}

.namedocs .text {
  /* Causes margins on child elements to collapse inside the element, such
     that the margins don't extend into parent with the background color.
     The effect is that weird borders in the definition box don't happen anymore. */
  display: flow-root;
  /* Add a padding. this is the same as the margin applied to the first and last child.
     The effect is that the padding looks the same size on all sides. */
  padding: 0 var(--verso--box-padding);
  border-top: 1px solid #98B2C0;
}

.namedocs .text > pre {
  overflow-x: auto;
}

.namedocs .signature {
  font-family: var(--verso-code-font-family);
  margin-top: 0 !important;
  margin-left: var(--verso--box-padding) !important;
  margin-bottom: .75rem !important;
}

.namedocs .label {
  display: block;
  font-size: small;
  font-family: var(--verso-structure-font-family);
  position: absolute;
  top: -0.65rem;
  left: 1rem;
  background: #fff;
  padding: 0 .5rem .125rem;
  border: 1px solid #98B2C0;
  border-radius: 1rem;
  color: #555;
}

.namedocs h1 {
  font-size: inherit;
  font-weight: bold
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.namedocs > .text .constructor {
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  margin-top: 0.5rem;
  margin-bottom: 1.5rem;
}

.namedocs > .text .constructor::before {
  content: '| ';
  display: block;
  font-family: var(--verso-code-font-family);
  font-weight: bold;
  float: left;
  width: 0.5rem;
  white-space: pre;
}

.namedocs > .text .constructor .name-and-type {
  padding-left: 0.5rem;
  float: left;
  margin-top: 0;
  max-width: calc(100% - 1rem);
}
.namedocs > .text .constructor .docs {
  clear: both;
  padding-left: 1rem;
}

/* These margins work together with the padding on .text */
.namedocs .text > :first-child {
  margin-top: var(--verso--box-padding);
}
.namedocs .text > :last-child {
  margin-bottom: var(--verso--box-padding);
}

.namedocs .methods td, .namedocs .fields td {
  vertical-align: top;
}
.namedocs .inheritance {
  vertical-align: top;
  font-size: smaller;
  font-family: var(--verso-structure-font-family);
}
.namedocs .inheritance ol {
  display: inline-block;
  margin: 0;
  padding: 0;
}
.namedocs .inheritance ol li {
  list-style-type: none;
  display: inline-block;
}
.namedocs .inheritance ol li::after {
  content: " > "
}
.namedocs .inheritance ol li:last-child::after {
  content: "";
}

.namedocs .extends {
  display: inline;
  margin: 0;
  padding: 0;
}

.namedocs .extends li {
  list-style-type: none;
  display: inline-block;
}

.namedocs .extends li label {
  padding-right: 1rem;
}

.namedocs .subdocs .name-and-type {
  font-size: 1rem;
  margin-left: 0;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs .subdocs .docs {
  margin-left: 1.5rem;
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0.5rem;
}

.namedocs:has(input[data-parent-idx]) [data-inherited-from] {
  transition-property: opacity, display;
  transition-duration: 0.4s;
  transition-behavior: allow-discrete;
  @starting-style { opacity: 0 !important; }
}

#this-page-items .tactic-name { font-weight: bold; }
.namedocs:has(input[data-parent-idx="0"]) [data-inherited-from="0"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="0"]:checked) [data-inherited-from="0"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="0"]:checked):has(.inheritance[data-inherited-from="0"]:hover) [data-inherited-from]:not([data-inherited-from="0"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="1"]) [data-inherited-from="1"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="1"]:checked) [data-inherited-from="1"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="1"]:checked):has(.inheritance[data-inherited-from="1"]:hover) [data-inherited-from]:not([data-inherited-from="1"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="2"]) [data-inherited-from="2"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="2"]:checked) [data-inherited-from="2"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="2"]:checked):has(.inheritance[data-inherited-from="2"]:hover) [data-inherited-from]:not([data-inherited-from="2"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="3"]) [data-inherited-from="3"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="3"]:checked) [data-inherited-from="3"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="3"]:checked):has(.inheritance[data-inherited-from="3"]:hover) [data-inherited-from]:not([data-inherited-from="3"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="4"]) [data-inherited-from="4"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="4"]:checked) [data-inherited-from="4"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="4"]:checked):has(.inheritance[data-inherited-from="4"]:hover) [data-inherited-from]:not([data-inherited-from="4"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="5"]) [data-inherited-from="5"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="5"]:checked) [data-inherited-from="5"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="5"]:checked):has(.inheritance[data-inherited-from="5"]:hover) [data-inherited-from]:not([data-inherited-from="5"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="6"]) [data-inherited-from="6"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="6"]:checked) [data-inherited-from="6"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="6"]:checked):has(.inheritance[data-inherited-from="6"]:hover) [data-inherited-from]:not([data-inherited-from="6"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="7"]) [data-inherited-from="7"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="7"]:checked) [data-inherited-from="7"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="7"]:checked):has(.inheritance[data-inherited-from="7"]:hover) [data-inherited-from]:not([data-inherited-from="7"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="8"]) [data-inherited-from="8"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="8"]:checked) [data-inherited-from="8"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="8"]:checked):has(.inheritance[data-inherited-from="8"]:hover) [data-inherited-from]:not([data-inherited-from="8"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="9"]) [data-inherited-from="9"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="9"]:checked) [data-inherited-from="9"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="9"]:checked):has(.inheritance[data-inherited-from="9"]:hover) [data-inherited-from]:not([data-inherited-from="9"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="10"]) [data-inherited-from="10"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="10"]:checked) [data-inherited-from="10"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="10"]:checked):has(.inheritance[data-inherited-from="10"]:hover) [data-inherited-from]:not([data-inherited-from="10"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="11"]) [data-inherited-from="11"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="11"]:checked) [data-inherited-from="11"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="11"]:checked):has(.inheritance[data-inherited-from="11"]:hover) [data-inherited-from]:not([data-inherited-from="11"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="12"]) [data-inherited-from="12"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="12"]:checked) [data-inherited-from="12"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="12"]:checked):has(.inheritance[data-inherited-from="12"]:hover) [data-inherited-from]:not([data-inherited-from="12"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="13"]) [data-inherited-from="13"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="13"]:checked) [data-inherited-from="13"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="13"]:checked):has(.inheritance[data-inherited-from="13"]:hover) [data-inherited-from]:not([data-inherited-from="13"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="14"]) [data-inherited-from="14"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="14"]:checked) [data-inherited-from="14"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="14"]:checked):has(.inheritance[data-inherited-from="14"]:hover) [data-inherited-from]:not([data-inherited-from="14"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="15"]) [data-inherited-from="15"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="15"]:checked) [data-inherited-from="15"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="15"]:checked):has(.inheritance[data-inherited-from="15"]:hover) [data-inherited-from]:not([data-inherited-from="15"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="16"]) [data-inherited-from="16"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="16"]:checked) [data-inherited-from="16"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="16"]:checked):has(.inheritance[data-inherited-from="16"]:hover) [data-inherited-from]:not([data-inherited-from="16"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="17"]) [data-inherited-from="17"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="17"]:checked) [data-inherited-from="17"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="17"]:checked):has(.inheritance[data-inherited-from="17"]:hover) [data-inherited-from]:not([data-inherited-from="17"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="18"]) [data-inherited-from="18"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="18"]:checked) [data-inherited-from="18"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="18"]:checked):has(.inheritance[data-inherited-from="18"]:hover) [data-inherited-from]:not([data-inherited-from="18"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="19"]) [data-inherited-from="19"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="19"]:checked) [data-inherited-from="19"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="19"]:checked):has(.inheritance[data-inherited-from="19"]:hover) [data-inherited-from]:not([data-inherited-from="19"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="20"]) [data-inherited-from="20"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="20"]:checked) [data-inherited-from="20"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="20"]:checked):has(.inheritance[data-inherited-from="20"]:hover) [data-inherited-from]:not([data-inherited-from="20"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="21"]) [data-inherited-from="21"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="21"]:checked) [data-inherited-from="21"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="21"]:checked):has(.inheritance[data-inherited-from="21"]:hover) [data-inherited-from]:not([data-inherited-from="21"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="22"]) [data-inherited-from="22"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="22"]:checked) [data-inherited-from="22"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="22"]:checked):has(.inheritance[data-inherited-from="22"]:hover) [data-inherited-from]:not([data-inherited-from="22"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="23"]) [data-inherited-from="23"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="23"]:checked) [data-inherited-from="23"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="23"]:checked):has(.inheritance[data-inherited-from="23"]:hover) [data-inherited-from]:not([data-inherited-from="23"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="24"]) [data-inherited-from="24"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="24"]:checked) [data-inherited-from="24"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="24"]:checked):has(.inheritance[data-inherited-from="24"]:hover) [data-inherited-from]:not([data-inherited-from="24"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="25"]) [data-inherited-from="25"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="25"]:checked) [data-inherited-from="25"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="25"]:checked):has(.inheritance[data-inherited-from="25"]:hover) [data-inherited-from]:not([data-inherited-from="25"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="26"]) [data-inherited-from="26"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="26"]:checked) [data-inherited-from="26"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="26"]:checked):has(.inheritance[data-inherited-from="26"]:hover) [data-inherited-from]:not([data-inherited-from="26"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="27"]) [data-inherited-from="27"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="27"]:checked) [data-inherited-from="27"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="27"]:checked):has(.inheritance[data-inherited-from="27"]:hover) [data-inherited-from]:not([data-inherited-from="27"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="28"]) [data-inherited-from="28"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="28"]:checked) [data-inherited-from="28"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="28"]:checked):has(.inheritance[data-inherited-from="28"]:hover) [data-inherited-from]:not([data-inherited-from="28"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="29"]) [data-inherited-from="29"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="29"]:checked) [data-inherited-from="29"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="29"]:checked):has(.inheritance[data-inherited-from="29"]:hover) [data-inherited-from]:not([data-inherited-from="29"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="30"]) [data-inherited-from="30"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="30"]:checked) [data-inherited-from="30"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="30"]:checked):has(.inheritance[data-inherited-from="30"]:hover) [data-inherited-from]:not([data-inherited-from="30"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="31"]) [data-inherited-from="31"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="31"]:checked) [data-inherited-from="31"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="31"]:checked):has(.inheritance[data-inherited-from="31"]:hover) [data-inherited-from]:not([data-inherited-from="31"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="32"]) [data-inherited-from="32"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="32"]:checked) [data-inherited-from="32"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="32"]:checked):has(.inheritance[data-inherited-from="32"]:hover) [data-inherited-from]:not([data-inherited-from="32"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="33"]) [data-inherited-from="33"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="33"]:checked) [data-inherited-from="33"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="33"]:checked):has(.inheritance[data-inherited-from="33"]:hover) [data-inherited-from]:not([data-inherited-from="33"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="34"]) [data-inherited-from="34"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="34"]:checked) [data-inherited-from="34"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="34"]:checked):has(.inheritance[data-inherited-from="34"]:hover) [data-inherited-from]:not([data-inherited-from="34"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="35"]) [data-inherited-from="35"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="35"]:checked) [data-inherited-from="35"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="35"]:checked):has(.inheritance[data-inherited-from="35"]:hover) [data-inherited-from]:not([data-inherited-from="35"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="36"]) [data-inherited-from="36"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="36"]:checked) [data-inherited-from="36"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="36"]:checked):has(.inheritance[data-inherited-from="36"]:hover) [data-inherited-from]:not([data-inherited-from="36"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="37"]) [data-inherited-from="37"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="37"]:checked) [data-inherited-from="37"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="37"]:checked):has(.inheritance[data-inherited-from="37"]:hover) [data-inherited-from]:not([data-inherited-from="37"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="38"]) [data-inherited-from="38"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="38"]:checked) [data-inherited-from="38"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="38"]:checked):has(.inheritance[data-inherited-from="38"]:hover) [data-inherited-from]:not([data-inherited-from="38"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="39"]) [data-inherited-from="39"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="39"]:checked) [data-inherited-from="39"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="39"]:checked):has(.inheritance[data-inherited-from="39"]:hover) [data-inherited-from]:not([data-inherited-from="39"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="40"]) [data-inherited-from="40"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="40"]:checked) [data-inherited-from="40"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="40"]:checked):has(.inheritance[data-inherited-from="40"]:hover) [data-inherited-from]:not([data-inherited-from="40"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="41"]) [data-inherited-from="41"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="41"]:checked) [data-inherited-from="41"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="41"]:checked):has(.inheritance[data-inherited-from="41"]:hover) [data-inherited-from]:not([data-inherited-from="41"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="42"]) [data-inherited-from="42"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="42"]:checked) [data-inherited-from="42"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="42"]:checked):has(.inheritance[data-inherited-from="42"]:hover) [data-inherited-from]:not([data-inherited-from="42"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="43"]) [data-inherited-from="43"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="43"]:checked) [data-inherited-from="43"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="43"]:checked):has(.inheritance[data-inherited-from="43"]:hover) [data-inherited-from]:not([data-inherited-from="43"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="44"]) [data-inherited-from="44"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="44"]:checked) [data-inherited-from="44"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="44"]:checked):has(.inheritance[data-inherited-from="44"]:hover) [data-inherited-from]:not([data-inherited-from="44"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="45"]) [data-inherited-from="45"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="45"]:checked) [data-inherited-from="45"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="45"]:checked):has(.inheritance[data-inherited-from="45"]:hover) [data-inherited-from]:not([data-inherited-from="45"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="46"]) [data-inherited-from="46"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="46"]:checked) [data-inherited-from="46"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="46"]:checked):has(.inheritance[data-inherited-from="46"]:hover) [data-inherited-from]:not([data-inherited-from="46"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="47"]) [data-inherited-from="47"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="47"]:checked) [data-inherited-from="47"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="47"]:checked):has(.inheritance[data-inherited-from="47"]:hover) [data-inherited-from]:not([data-inherited-from="47"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="48"]) [data-inherited-from="48"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="48"]:checked) [data-inherited-from="48"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="48"]:checked):has(.inheritance[data-inherited-from="48"]:hover) [data-inherited-from]:not([data-inherited-from="48"]) {
  opacity: 0.5;
}
.namedocs:has(input[data-parent-idx="49"]) [data-inherited-from="49"] {
  display: none;
  opacity: 0;
}
.namedocs:has(input[data-parent-idx="49"]:checked) [data-inherited-from="49"] {
  display: block;
  transform: none;
  opacity: 1;
}
.namedocs:has(input[data-parent-idx="49"]:checked):has(.inheritance[data-inherited-from="49"]:hover) [data-inherited-from]:not([data-inherited-from="49"]) {
  opacity: 0.5;
}
</style><style>
.field-category > :first-child {
}

.field-category > :not(:first-child) {
  margin-left: 1rem;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>
dl.toml-table-field-spec {
}
</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>.keyword-of .kw {
  font-weight: 500;
}
.keyword-of .hover-info {
  display: none;
}
.keyword-of .kw:hover {
  background-color: #eee;
  border-radius: 2px;
}
</style><style>.grammar .keyword {
  font-weight: 500 !important;
}

.grammar {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

.grammar .comment {
  font-style: italic;
  font-family: var(--verso-text-font-family);
  /* TODO add background and text colors to Verso theme, then compute a background here */
  background-color: #fafafa;
  border: 1px solid #f0f0f0;
}

.grammar .local-name {
  font-family: var(--verso-code-font-family);
  font-style: italic;
}

.grammar .nonterminal {
  font-style: italic;
}
.grammar .nonterminal > .hover-info, .grammar .from-nonterminal > .hover-info, .grammar .local-name > .hover-info {
  display: none;
}
.grammar .active {
  background-color: #eee;
  border-radius: 2px;
}
.grammar a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
</style><style>
.c .type { font-weight: 600; }
.c .kw { font-weight: 600; }
.c .comment { font-style: italic; }
</style><style>.namedocs .label a { color: inherit; }</style><style>#toc .split-toc > ol .syntax .keyword { font-family: var(--verso-code-font-family); font-weight: 600; }</style><style>
  .error-explanation-metadata {
    margin-bottom: 2rem; /* Double the paragraph margin */
  }

  .error-explanation-metadatum:not(:last-child):after {
    content: '|';
    margin: 0 10px;
  }
  .error-explanation-removed-warning {
    border: 1px solid var(--verso-warning-color);
    border-radius: 0.5rem;
    padding-left: var(--verso--box-padding);
    padding-right: var(--verso--box-padding);
  }
  </style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.lake-opt a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.lake-opt a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>
div.TODO {
  border: 5px solid red;
  position: relative;
}
div.TODO::before {
  content: "TODO";
  position: absolute;
  top: 0;
  right: 0;
  color: red;
  font-size: large;
  font-weight: bold;
  transform: rotate(-90deg) translate(-2em);
}
</style><style>
.toml {
  font-family: var(--verso-code-font-family);
}

pre.toml {
  margin: 0.5rem .75rem;
  padding: 0.1rem 0;
}

.toml .bool, .toml .table-header {
    font-weight: 600;
}

.toml .table-header .key {
    color: #3030c0;
}

.toml .bool {
    color: #107090;
}

.toml .string {
    color: #0a5020;
}

.toml a, .toml a:link {
    color: inherit;
    text-decoration: none;
    border-bottom: 1px dotted #a2a2a2;
}

.toml a:hover {
    border-bottom-style: solid;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><style>
    main .theIndex {
      padding-left: 0;
      font-family: var(--verso-text-font-family);
    }

    main .theIndex nav {
      position: sticky;
      top: var(--verso-header-height);
      background: white;
      font-family: var(--verso-structure-font-family);
    }

    main .theIndex [id] {
      /* This needs the combined height of the index header and the page header. We
         know the height of the page header, but the index header height varies, so
         we use the maximum height it gets which also works well for readers with
         wide screens */
      scroll-margin-top: calc(var(--verso-header-height) + 7.5rem);
    }

    @media screen and (max-width: 700px) {
      /* On mobile, the sticky index takes up half the screen. */
      main .theIndex nav {
        position: static;
      }

      main .theIndex [id] {
        /* On mobile, the index header is not sticky, so we just need to
        be below the page header. */
        scroll-margin-top: var(--verso-header-height);
      }
    }

    main .theIndex nav ol {
      padding: 0;
    }

    main .theIndex nav ol li {
      display: inline-block;
    }

    main .theIndex nav ol li a {
      /* Padding instead of margin to have a bigger click target */
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
    /* Increase the size of the touch target on phones */
    @media screen and (max-width: 700px) {
      main .theIndex nav ol li a {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
    }

    main .theIndex nav ol li:first-child a {
      padding-left: 0;
    }

    main .theIndex nav ol li + li:before {
      content: "|";
    }

    main .theIndex h1,
    main .theIndex h2,
    main .theIndex h3,
    main .theIndex h4,
    main .theIndex h5,
    main .theIndex h6 {
      margin-top: 0;
    }

    main .theIndex ol {
      list-style-type: none;
    }

    main .theIndex .division > ol {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      overflow-wrap: break-word;
    }

   main .theIndex .division > ol > li {
      margin-bottom: 0.5rem;
    }

    main .theIndex .division ol ol {
      padding-left: 1rem;
    }

    main .theIndex .division {
      break-inside: avoid;
      counter-reset: none;
      max-width: none;
      width: auto;
    }
    </style><style>
.toml-field a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.toml-field a:hover {
  text-decoration: currentcolor underline solid;
}
</style><style>.error-explanation-short-name { hyphenate-character: ''; }</style><style>
.env-var a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
.env-var a:hover {
  text-decoration: currentcolor underline solid;
}

</style><style>.plain-keyword {
  font-weight: 500;
}
</style><style>.example {
  border: 1px solid #98B2C0;
  border-radius: 0.5rem;
  margin-bottom: var(--verso--box-vertical-margin);
  margin-top: var(--verso--box-vertical-margin);
}
/* 1400 px is the cutoff for when the margin notes move out of the margin and into floated elements. */
@media screen and (700px < width <= 1400px) {
  .example {
    clear: both; /* Don't overlap margin notes with examples */
  }
}
.example .description::before {
  content: "Example: ";
}
.example .description {
  font-style: italic;
  font-family: var(--verso-structure-font-family);
  padding: var(--verso--box-padding);
}
.example[open] .description {
  margin-bottom: 0;
}
.example-content {
  padding: 0 var(--verso--box-padding) var(--verso--box-padding);
}
.example-content > :first-child {
  margin-top: 0;
}
.example-content p:last-child {
  margin-bottom:0;
}
.example .hl.lean.block {
  overflow-x: auto;
}
</style><style>
.error-example-container:not(:last-child) {
  border-bottom: 1px solid gray;
  padding-bottom: var(--verso--box-padding);
}
.error-example-tab-list [role="tab"] {
  position: relative;
  z-index: 1;
  background: white;
  border: 0;
  padding: 0.2em;
  cursor: pointer;
}
.error-example-tab-list [role="tab"]:not(:last-child) {
  margin-right: 1rem;
}
.error-example-tab-list [role="tab"][aria-selected="true"] {
  border-bottom: 1px solid gray;
}
/* this rule and the following ensure that all tabs are the same height */
.error-example-tab-view {
  display: flex;
}
.error-example-tabpanel {
  margin-right: -100%;
  width: 100%;
  display: block;
}
.error-example-tabpanel.error-example-tabpanel-hidden {
  visibility: hidden;
}
.error-example-tabpanel .hl.lean .token {
  /* unset transition to avoid lag when switching panels */
  transition: visibility 0s;
}
  </style><style>
.syntax-error {
  white-space: normal;
}
.syntax-error::before {
  counter-reset: linenumber;
}
.syntax-error > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.syntax-error > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}

:is(.syntax-error > .line):has(.parse-message)::before {
  color: red;
  font-weight: bold;
}

.syntax-error .parse-message > code.hover-info {
  display:none;
}

.syntax-error .parse-message {
  white-space: pre;
  text-decoration-skip-ink: none;
  color: red;
  font-weight: 600;
}
</style><script>
      
window.addEventListener("load", () => {
  const innerProps = {
    onShow(inst) { console.log(inst); },
    onHide(inst) { console.log(inst); },
    content(tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  };
  const outerProps = {
    allowHtml: true,
    theme: "lean",
    placement: 'bottom-start',
    maxWidth: "none",
    delay: 100,
    moveTransition: 'transform 0.2s ease-out',
    onTrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
      ref.classList.add("active");
    },
    onUntrigger(inst, event) {
      const ref = event.currentTarget;
      const block = ref.closest('.hl.lean');
      block.querySelectorAll('.active').forEach((i) => i.classList.remove('active'));
    }
  };
  tippy.createSingleton(tippy('pre.grammar.hl.lean .nonterminal.documented, pre.grammar.hl.lean .from-nonterminal.documented, pre.grammar.hl.lean .local-name.documented', innerProps), outerProps);
});
</script>
    <script>
      
window.addEventListener("load", () => {
  tippy('.keyword-of.hl.lean', {
    allowHtml: true,
    /* DEBUG -- remove the space: * /
    onHide(any) { return false; },
    trigger: "click",
    // */
    maxWidth: "none",

    theme: "lean",
    placement: 'bottom-start',
    content (tgt) {
      const content = document.createElement("span");
      const state = tgt.querySelector(".hover-info").cloneNode(true);
      state.style.display = "block";
      content.appendChild(state);
      /* Render docstrings - TODO server-side */
      if ('undefined' !== typeof marked) {
          for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
              const str = d.innerText;
              const html = marked.parse(str);
              const rendered = document.createElement("div");
              rendered.classList.add("docstring");
              rendered.innerHTML = html;
              d.parentNode.replaceChild(rendered, d);
          }
      }
      content.style.display = "block";
      content.className = "hl lean popup";
      return content;
    }
  });
});
</script>
    <script>
      
window.addEventListener('DOMContentLoaded', () => {
  const tabLists = document.querySelectorAll('.error-example-tab-list')
  tabLists.forEach(tabList => {
    const tabs = tabList.querySelectorAll(':scope > [role="tab"]')

    const setActiveTab = (e) => {
      for (const tab of tabs) {
        const controllee = document.getElementById(tab.getAttribute('aria-controls'))
        if (tab === e.target) {
          tab.setAttribute('aria-selected', true)
          controllee.classList.remove('error-example-tabpanel-hidden')
        } else {
          tab.setAttribute('aria-selected', false)
          controllee.classList.add('error-example-tabpanel-hidden')
        }
      }
    }

    tabs.forEach(tab => {
      tab.addEventListener('click', setActiveTab)
    })

    let focusedIdx = 0
    tabList.addEventListener('keydown', e => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
        tabs[focusedIdx].setAttribute('tabindex', -1)
        focusedIdx =
          e.key === 'ArrowRight'
          ? (focusedIdx + 1) % tabs.length
          : (focusedIdx - 1 + tabs.length) % tabs.length
        tabs[focusedIdx].setAttribute('tabindex', 0)
        tabs[focusedIdx].focus()
      }
    })
  })
})
  </script>
    <script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <script type="module" src="static/search/search-init.js"></script>
    <script defer="defer" data-domain="lean-lang.org/doc/reference/latest" src="https://plausible.io/js/script.outbound-links.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            The Lean Language Reference</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              The Lean Language Reference</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#introduction">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Elaboration-and-Compilation/#The-Lean-Language-Reference--Elaboration-and-Compilation">Elaboration and Compilation</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Interacting-with-Lean/#interaction">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="The-Type-System/#type-system">The Type System</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Source-Files-and-Modules/#files">Source Files and Modules</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Namespaces-and-Sections/#namespaces-sections">Namespaces and Sections</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Definitions/#definitions">Definitions</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Axioms/#axioms">Axioms</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Attributes/#attributes">Attributes</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Terms/#terms">Terms</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Coercions/#coercions">Coercions</a></td></tr><tr class="numbered"><td class="num">13.</td><td><a href="Tactic-Proofs/#tactics">Tactic Proofs</a></td></tr><tr class="numbered"><td class="num">14.</td><td><a href="Functors___-Monads-and--do--Notation/#monads-and-do">Functors, Monads and <code>do</code>-Notation</a></td></tr><tr class="numbered"><td class="num">15.</td><td><a href="IO/#io">IO</a></td></tr><tr class="numbered"><td class="num">16.</td><td><a href="The-Simplifier/#the-simplifier">The Simplifier</a></td></tr><tr class="numbered"><td class="num">17.</td><td><a href="The--grind--tactic/#grind">The <code>grind</code> tactic</a></td></tr><tr class="numbered"><td class="num">18.</td><td><a href="Basic-Propositions/#basic-props">Basic Propositions</a></td></tr><tr class="numbered"><td class="num">19.</td><td><a href="Basic-Types/#basic-types">Basic Types</a></td></tr><tr class="current numbered"><td class="num">20.</td><td><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></td></tr><tr class="numbered"><td class="num">21.</td><td><a href="Run-Time-Code/#runtime">Run-Time Code</a></td></tr><tr class="numbered"><td class="num">22.</td><td><a href="Build-Tools-and-Distribution/#build-tools-and-distribution">Build Tools and Distribution</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Error-Explanations/#The-Lean-Language-Reference--Error-Explanations">Error Explanations</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="releases/#release-notes">Release Notes</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="the-index/#The-Lean-Language-Reference--Index">Index</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-language-extension" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-language-extension" checked="checked"></label><span class="number">20.</span> <span class=""><a href="Notations-and-Macros/#language-extension">Notations and Macros</a></span></div>
              <table><tr class="numbered"><td class="num">20.1.</td><td><a href="Notations-and-Macros/Custom-Operators/#operators">Custom Operators</a></td></tr><tr class="numbered"><td class="num">20.2.</td><td><a href="Notations-and-Macros/Precedence/#precedence">Precedence</a></td></tr><tr class="numbered"><td class="num">20.3.</td><td><a href="Notations-and-Macros/Notations/#notations">Notations</a></td></tr><tr class="numbered"><td class="num">20.4.</td><td><a href="Notations-and-Macros/Defining-New-Syntax/#syntax-ext">Defining New Syntax</a></td></tr><tr class="current numbered"><td class="num">20.5.</td><td><a href="Notations-and-Macros/Macros/#macros">Macros</a></td></tr><tr class="numbered"><td class="num">20.6.</td><td><a href="Notations-and-Macros/Elaborators/#elaborators">Elaborators</a></td></tr><tr class="numbered"><td class="num">20.7.</td><td><a href="Notations-and-Macros/Extending-Lean___s-Output/#unexpand-and-delab">Extending Lean's Output</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-macros" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-macros" checked="checked"></label><span class="number">20.5.</span> <span class="current"><a href="Notations-and-Macros/Macros/#macros">Macros</a></span></div>
              <ol>
                <li>
                  <span class="header head-1"><span class="level-num">1.</span> <a href="Notations-and-Macros/Macros/#macro-hygiene">Hygiene</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">2.</span> <a href="Notations-and-Macros/Macros/#macro-monad">The Macro Monad</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___MacroM"><code>MacroM</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___expandMacro___"><code>expandMacro?</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___trace"><code>trace</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.1.</span> <a href="Notations-and-Macros/Macros/#macro-exceptions">Exceptions and Errors</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported"><code>throwUnsupported</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax"><code>unsupportedSyntax</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___throwError"><code>throwError</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___throwErrorAt"><code>throwErrorAt</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.2.</span> <a href="Notations-and-Macros/Macros/#macro-monad-hygiene">Hygiene-Related Operations</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___withFreshMacroScope"><code>withFreshMacroScope</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___addMacroScope"><code>addMacroScope</code></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">2.3.</span> <a href="Notations-and-Macros/Macros/#macro-environment">Querying the Environment</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___hasDecl"><code>hasDecl</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___getCurrNamespace"><code>getCurrNamespace</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___resolveNamespace"><code>resolveNamespace</code></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Macro___resolveGlobalName"><code>resolveGlobalName</code></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">3.</span> <a href="Notations-and-Macros/Macros/#quotation">Quotation</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Manual___FreeSyntax___more-next-next"><span class="syntax"></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.1.</span> <a href="Notations-and-Macros/Macros/#quasiquotation">Quasiquotation</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Manual___FreeSyntax___more-next-next-next"><span class="syntax"></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.2.</span> <a href="Notations-and-Macros/Macros/#splices">Splices</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">3.3.</span> <a href="Notations-and-Macros/Macros/#token-antiquotations">Token Antiquotations</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Manual___FreeSyntax___done"><span class="syntax"></span></a></li>
                <li>
                  <span class="header head-1"><span class="level-num">4.</span> <a href="Notations-and-Macros/Macros/#quote-patterns">Matching Syntax</a></span></li>
                <li>
                  <span class="header head-1"><span class="level-num">5.</span> <a href="Notations-and-Macros/Macros/#defining-macros">Defining Macros</a></span></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.1.</span> <a href="Notations-and-Macros/Macros/#macro_rules">The <code>macro_rules</code> Command</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><span class="syntax"><span class="meta">(</span><span class="keyword">@[</span><span class="meta">…</span><span class="keyword">]</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">macro_rules</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">kind</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">|</span><span class="ws"> </span><span class="keyword">`(</span><span class="meta">(</span><span class="meta">:</span><span class="meta">…</span><span class="keyword">|</span><span class="meta">)?</span><span class="ws"> </span><span class="keyword">)</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span><span class="meta">)*</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.2.</span> <a href="Notations-and-Macros/Macros/#macro-command">The <code>macro</code> Command</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><span class="syntax"><span class="meta">(</span><span class="keyword">@[</span><span class="meta">…</span><span class="keyword">]</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">macro</span><span class="meta">(</span><span class="keyword">:</span><span class="meta">…</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">name</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">(</span><span class="keyword">(</span><span class="keyword">priority</span><span class="ws"> </span><span class="keyword">:=</span><span class="ws"> </span><span class="meta">…</span><span class="keyword">)</span><span class="meta">)?</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">:</span><span class="ws"> </span><span class="meta">…</span><span class="ws"> </span><span class="keyword">=&gt;</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macroArg-next-next"><span class="syntax"><span class="meta">…</span><span class="keyword">:</span><span class="meta">…</span></span></a></li>
                <li>
                  <span class="header head-2"><span class="level-num">5.3.</span> <a href="Notations-and-Macros/Macros/#macro-attribute">The Macro Attribute</a></span></li>
                <li>
                  <a href="Notations-and-Macros/Macros/#Lean___Parser___Attr___macro"><span class="syntax"><span class="keyword">macro</span><span class="ws"> </span><span class="meta">…</span></span></a></li>
                </ol>
              </div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/reference-manual">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/reference-manual/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Notations-and-Macros/Defining-New-Syntax/#syntax-ext" rel="prev" title="20.4. Defining New Syntax"><span class="arrow">←</span><span class="where">20.4. Defining New Syntax</span></a><a class="local-button active" href="Notations-and-Macros/Elaborators/#elaborators" rel="next" title="20.6. Elaborators"><span class="where">20.6. Elaborators</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              20.5. Macros<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macros" title="Permalink">🔗</a></span></h1>
            <p>
              <span id="--tech-term-Macros" class="def-technical-term"><em>Macros</em></span> are transformations from <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code> to <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code> that occur during <a class="technical-term" href="Notations-and-Macros/Elaborators/#--tech-term-elaborators">elaboration</a> and during <a href="Tactic-Proofs/Custom-Tactics/#tactic-macros">tactic execution</a>.
Replacing syntax with the result of transforming it with a macro is called <span id="--tech-term-macro-expansion" class="def-technical-term"><em>macro expansion</em></span>.
Multiple macros may be associated with a single <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-kind">syntax kind</a>, and they are attempted in order of definition.
Macros are run in a <a class="technical-term" href="Functors___-Monads-and--do--Notation/#--tech-term-Monad">monad</a> that has access to some compile-time metadata and has the ability to either emit an error message or to delegate to subsequent macros, but the macro monad is much less powerful than the elaboration monads.</p>
            <p>
              Macros are associated with <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-kind">syntax kinds</a>.
An internal table maps syntax kinds to macros of type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code>.
Macros delegate to the next entry in the table by throwing the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code> exception.
A given <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code> value <em>is a macro</em> when there is a macro associated with its syntax kind that does not throw <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code>.
If a macro throws any other exception, an error is reported to the user.
<a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-categories">Syntax categories</a> are irrelevant to macro expansion; however, because each syntax kind is typically associated with a single syntax category, they do not interfere in practice.</p>
            <details class="example"><summary class="description">Macro Error Reporting</summary><div class="example-content">
                <p>
                  The following macro reports an error when its parameter is the literal numeral five.
It expands to its argument in all other cases.</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-4874">syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">&</span><span class="literal string token" data-binding="" data-verso-hover="5507">"notFive"</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="unknown token" data-binding="">:</span><a href="Notations-and-Macros/Precedence/#precArg" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-precArg-4897" data-verso-hover="5394">arg</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="inter-text">
</span><a href="Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-4908" data-verso-hover="121">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Lean</span><span class="inter-text"> </span><a href="Namespaces-and-Sections/#Lean___Parser___Command___in" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-4908">in</span></a><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-4921">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">notFive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwError" title="Documentation for Lean.Macro.throwError"><span class="const token" data-binding="const-Lean.Macro.throwError" data-verso-hover="5509">Macro.throwError</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5510">"'5' is not allowed here"</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="unknown token" data-binding="">|</span><span class="unknown token" data-binding="">notFive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.158" data-verso-hover="5430">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Functors___-Monads-and--do--Notation/#Pure___mk" title="Documentation for Pure.pure"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1146">pure</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.158" data-verso-hover="5430">e</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                  When applied to terms that are not syntactically the numeral five, elaboration succeeds:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5165" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">notFive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                  <pre>5
</pre></div>
                <p>
                  When the error case is triggered, the user receives an error message:</p>
                <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5339" data-verso-hover="8">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">'5' is not allowed here</code></span></span><span class="unknown token" data-binding="">notFive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                  <pre>'5' is not allowed here
</pre></div>
                </div>
              </details><p>
              Before elaborating a piece of syntax, the elaborator checks whether its <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-kind">syntax kind</a> has macros associated with it.
These are attempted in order.
If a macro succeeds, potentially returning syntax with a different kind, the check is repeated and macros are expanded again until the outermost layer of syntax is no longer a macro.
Elaboration or tactic execution can then proceed.
Only the outermost layer of syntax (typically a <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax.node"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="5413">node</span></a></code>) is expanded, and the output of macro expansion may contain nested syntax that is a macro.
These nested macros are expanded in turn when the elaborator reaches them.</p>
            <p>
              In particular, macro expansion occurs in three situations in Lean:</p>
            <ol start="1">
              <li>
                <p>
                  During term elaboration, macros in the outermost layer of the syntax to be elaborated are expanded prior to invoking the <a href="Notations-and-Macros/Elaborators/#elaborators">syntax's term elaborator</a>.</p>
                </li>
              <li>
                <p>
                  During command elaboration, macros in the outermost layer of the syntax to be elaborated are expanded prior to invoking the <a href="Notations-and-Macros/Elaborators/#elaborators">syntax's command elaborator</a>.</p>
                </li>
              <li>
                <p>
                  During tactic execution, macros in the outermost layer of the syntax to be elaborated are expanded <a href="Tactic-Proofs/Custom-Tactics/#tactic-macros">prior to executing the syntax as a tactic</a>.</p>
                </li>
              </ol>
            <section>
              <h2 id="macro-hygiene">
                20.5.1. Hygiene<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-hygiene" title="Permalink">🔗</a></span></h2>
              <p>
                A macro is <span id="--tech-term-hygienic" class="def-technical-term"><em>hygienic</em></span> if its expansion cannot result in identifier capture.
<span id="--tech-term-Identifier-capture" class="def-technical-term">Identifier capture</span> is when an identifier ends up referring to a binding site other than that which is in scope where the identifier occurs in the source code.
There are two types of identifier capture:</p>
              <ul>
                <li>
                  <p>
                    If a macro's expansion introduces binders, then identifiers that are parameters to the macro may end up referring to the introduced binders if their names happen to match.</p>
                  </li>
                <li>
                  <p>
                    If a macro's expansion is intended to refer to a name, but the macro is used in a context that either locally binds this name or in which a new global name has been introduced, it may end up referring to the wrong name.</p>
                  </li>
                </ul>
              <p>
                The first kind of variable capture can be avoided by ensuring that every binding introduced by a macro uses a freshly generated, globally-unique name, while the second can be avoided by always using fully-qualified names to refer to constants.
The fresh names must be generated again at each invocation of the macro to avoid variable capture in recursive macros.
These techniques are error-prone.
Variable capture issues are difficult to test for because they rely on coincidences of name choices, and consistently applying these techniques results in noisy code.</p>
              <p>
                Lean features automatic hygiene: in almost all cases, macros are automatically hygienic.
Capture by introduced bindings is avoided by annotating identifiers introduced by a macro with <span id="--tech-term-macro-scopes" class="def-technical-term"><em>macro scopes</em></span>, which uniquely identify each invocation of macro expansion.
If the binding and the use of the identifier have the same macro scopes, then they were introduced by the same step of macro expansion and should refer to one another.
Similarly, uses of global names in code generated by a macro are not captured by local bindings in the context in which they are expanded because these use sites have macro scopes that are not present in the binding occurrence.
Capture by newly-introduced global names is prevented by annotating potential global name references with the set of global names that match at quotation time in code produced in the macro's body.
Identifiers annotated with potential referents are called <span id="--tech-term-pre-resolved-identifiers" class="def-technical-term"><em>pre-resolved identifiers</em></span>, and the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Preresolved___namespace" title="Documentation for Lean.Syntax.Preresolved"><span class="const token" data-binding="const-Lean.Syntax.Preresolved" data-verso-hover="5409">Syntax.Preresolved</span></a></code> field on the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax.ident"><span class="const token" data-binding="const-Lean.Syntax.ident" data-verso-hover="5438">Syntax.ident</span></a></code> constructor is used to store the potential referents.
During elaboration, if an identifier has pre-resolved global names associated with it, then other global names are not considered as valid reference targets.</p>
              <p>
                The introduction of macro scopes and pre-resolved identifiers to generated syntax occurs during <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Quotation">quotation</a>.
Macros that construct syntax by other means than quotation should also ensure hygiene by some other means.
For more details on Lean's hygiene algorithm, please consult Ullrich and de Moura (2020)<span class="marginalia"><span class="note"><span class="citation">Sebastian Ullrich and Leonardo de Moura, 2020. “Beyond notations: Hygienic macro expansion for theorem proving languages”. In <em>Proceedings of the International Joint Conference on Automated Reasoning.</em></span></span></span> and Ullrich (2023)<span class="marginalia"><span class="note"><span class="citation">Sebastian Ullrich, 2023. <em><a href="https://www.lean-lang.org/papers/thesis-sebastian.pdf">An Extensible Theorem Proving Frontend</a></em>. Dr. Ing. dissertation, Karlsruhe Institute of Technology</span></span></span>.</p>
              </section>
            <section>
              <h2 id="macro-monad">
                20.5.2. The Macro Monad<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-monad" title="Permalink">🔗</a></span></h2>
              <p>
                The macro monad <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a></code> is sufficiently powerful to implement hygiene and report errors.
Macro expansion does not have the ability to modify the environment directly, to carry out unification, to examine the current local context, or to do anything else that only makes sense in one particular context.
This allows the same macro mechanism to be used throughout Lean, and it makes macros much easier to write than <a class="technical-term" href="Notations-and-Macros/Elaborators/#--tech-term-elaborators">elaborators</a>.</p>
              <div class="namedocs" id="Lean___MacroM">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.MacroM" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.MacroM</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3655" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.MacroM</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3655" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span></div></pre><div class="text">
                  <p>
                    The <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">MacroM</span></code> monad is the main monad for macro expansion. It has the
information needed to handle hygienic name generation, and is the monad that
<code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">macro</span></code> definitions live in.</p>
                  <p>
                    Notably, this is a (relatively) pure monad: there is no <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Logical-Model/#IO" title="Documentation for IO"><span class="const token" data-binding="const-IO" data-verso-hover="3">IO</span></a></code> and no access to
the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Environment</span></code>. That means that things like declaration lookup are
impossible here, as well as <code class="hl lean inline" data-lean-context="docstring-examples"><a href="IO/Mutable-References/#IO___Ref" title="Documentation for IO.Ref"><span class="const token" data-binding="const-IO.Ref" data-verso-hover="3127">IO.Ref</span></a></code> or other side-effecting operations.
For more capabilities, macros can instead be written as <code class="hl lean inline" data-lean-context="docstring-examples"><span class="keyword token" data-binding="kw-occ-null-0">elab</span></code> using <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">adaptExpander</span></code>.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Macro___expandMacro___">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.expandMacro?" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.expandMacro?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3940" data-verso-hover="1582">stx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.expandMacro?</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3940" data-verso-hover="1582">stx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span></div></pre><div class="text">
                  <p>
                    <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">expandMacro?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">stx</span></code> returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3901" data-verso-hover="5511">stxNew</span></code> if <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3849" data-verso-hover="1582">stx</span></code> is a macro,
and <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.3901" data-verso-hover="5511">stxNew</span></code> is its expansion.</p>
                  </div>
                </div>
              <div class="namedocs" id="Lean___Macro___trace">
                <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.trace" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.trace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4075" data-verso-hover="3422">clsName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4076" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="5">Unit</span></a></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.trace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4075" data-verso-hover="3422">clsName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4076" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><a href="Basic-Types/The-Unit-Type/#Unit" title="Documentation for Unit"><span class="const token" data-binding="const-Unit" data-verso-hover="5">Unit</span></a></div></pre><div class="text">
                  <p>
                    Add a new trace message, with the given trace class and message.</p>
                  </div>
                </div>
              <section>
                <h3 id="macro-exceptions">
                  20.5.2.1. Exceptions and Errors<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-exceptions" title="Permalink">🔗</a></span></h3>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code> exception is used for control flow during macro expansion.
It indicates that the current macro is incapable of expanding the received syntax, but that an error has not occurred.
The exceptions thrown by <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___throwError" title="Documentation for Lean.Macro.throwError"><span class="const token" data-binding="const-Lean.Macro.throwError" data-verso-hover="5512">throwError</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___throwErrorAt" title="Documentation for Lean.Macro.throwErrorAt"><span class="const token" data-binding="const-Lean.Macro.throwErrorAt" data-verso-hover="5513">throwErrorAt</span></a></code> terminate macro expansion, reporting the error to the user.</p>
                <div class="namedocs" id="Lean___Macro___throwUnsupported">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.throwUnsupported" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.throwUnsupported</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4323" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4323" data-verso-hover="287">α</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.throwUnsupported</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4323" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4323" data-verso-hover="287">α</span></div></pre><div class="text">
                    <p>
                      Throw an <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">unsupportedSyntax</span></code> exception.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___Exception___unsupportedSyntax">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.Exception.unsupportedSyntax" title="Permalink">🔗</a></span><span class="label">constructor of Lean.Macro.Exception</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.Exception.unsupportedSyntax</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Macro.Exception" data-verso-hover="5514">Lean.Macro.Exception</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.Exception.unsupportedSyntax</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Lean.Macro.Exception" data-verso-hover="5514">Lean.Macro.Exception</span></div></pre><div class="text">
                    <p>
                      An unsupported syntax exception. We keep this separate because it is
used for control flow: if one macro does not support a syntax then we try
the next one.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___throwError">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.throwError" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.throwError</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4441" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4441" data-verso-hover="287">α</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.throwError</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4441" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4442" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4441" data-verso-hover="287">α</span></div></pre><div class="text">
                    <p>
                      Throw an error with the given message,
using the <code class="hl lean inline" data-lean-context="docstring-examples"><span class="const token" data-binding="const-Verso.Genre.Manual.ref" data-verso-hover="5515">ref</span></code> for the location information.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___throwErrorAt">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.throwErrorAt" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.throwErrorAt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4538" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4539" data-verso-hover="1582">ref</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4540" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4538" data-verso-hover="287">α</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.throwErrorAt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4538" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4539" data-verso-hover="1582">ref</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Lean.Syntax</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4540" data-verso-hover="145">msg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4538" data-verso-hover="287">α</span></div></pre><div class="text">
                    <p>
                      Throw an error with the given message and location information.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="macro-monad-hygiene">
                  20.5.2.2. Hygiene-Related Operations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-monad-hygiene" title="Permalink">🔗</a></span></h3>
                <p>
                  <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-hygienic">Hygiene</a> is implemented by adding <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> to the identifiers that occur in syntax.
Ordinarily, the process of <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Quotation">quotation</a> adds all necessary scopes, but macros that construct syntax directly must add macro scopes to the identifiers that they introduce.</p>
                <div class="namedocs" id="Lean___Macro___withFreshMacroScope">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.withFreshMacroScope" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.withFreshMacroScope</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4902" data-verso-hover="5516">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.withFreshMacroScope</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4902" data-verso-hover="5516">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4900" data-verso-hover="287">α</span></div></pre><div class="text">
                    <p>
                      Increments the macro scope counter so that inside the body of <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.4895" data-verso-hover="5516">x</span></code> the macro
scope is fresh.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___addMacroScope">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.addMacroScope" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.addMacroScope</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5006" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.addMacroScope</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5006" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span></div></pre><div class="text">
                    <p>
                      Add a new macro scope to the name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5003" data-verso-hover="3422">n</span></code>.</p>
                    </div>
                  </div>
                </section>
              <section>
                <h3 id="macro-environment">
                  20.5.2.3. Querying the Environment<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-environment" title="Permalink">🔗</a></span></h3>
                <p>
                  Macros have only limited support for querying the environment.
They can check whether a constant exists and resolve names, but further introspection is unavailable.</p>
                <div class="namedocs" id="Lean___Macro___hasDecl">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.hasDecl" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.hasDecl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5099" data-verso-hover="3422">declName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="184">Bool</span></a></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.hasDecl</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5099" data-verso-hover="3422">declName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool"><span class="const token" data-binding="const-Bool" data-verso-hover="184">Bool</span></a></div></pre><div class="text">
                    <p>
                      Returns <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Booleans/#Bool___false" title="Documentation for Bool.true"><span class="const token" data-binding="const-Bool.true" data-verso-hover="41">true</span></a></code> if the environment contains a declaration with name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="var token" data-binding="var-_uniq.5096" data-verso-hover="3422">declName</span></code></p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___getCurrNamespace">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.getCurrNamespace" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.getCurrNamespace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.getCurrNamespace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span></div></pre><div class="text">
                    <p>
                      Gets the current namespace given the position in the file.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___resolveNamespace">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.resolveNamespace" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.resolveNamespace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5227" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.resolveNamespace</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5227" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span></div></pre><div class="text">
                    <p>
                      Resolves the given name to an overload list of namespaces.</p>
                    </div>
                  </div>
                <div class="namedocs" id="Lean___Macro___resolveGlobalName">
                  <span class="permalink-widget block"><a href="find/?domain=Verso.Genre.Manual.doc&amp;name=Lean.Macro.resolveGlobalName" title="Permalink">🔗</a></span><span class="label">def</span><pre class="signature hl lean block"><div class="wide-only"><span class="unknown token" data-binding="">Lean.Macro.resolveGlobalName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5347" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">(</span></a><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">×</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">)</span></a><span class="unknown token" data-binding="">)</span></div><div class="narrow-only"><span class="unknown token" data-binding="">Lean.Macro.resolveGlobalName</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5347" data-verso-hover="3422">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">Lean.MacroM</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">(</span></a><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Lean.Name</span><span class="inter-text"> </span><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">×</span></a><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a><a href="Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod"><span class="const token" data-binding="const-Prod" data-verso-hover="313">)</span></a><span class="unknown token" data-binding="">)</span></div></pre><div class="text">
                    <p>
                      Resolves the given name to an overload list of global definitions.
The <code class="hl lean inline" data-lean-context="docstring-examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Strings/#String___mk" title="Documentation for String"><span class="const token" data-binding="const-String" data-verso-hover="142">String</span></a></code> in each alternative is the deduced list of projections
(which are ambiguous with name components).</p>
                    <p>
                      Remark: it will not trigger actions associated with reserved names. Recall that Lean
has reserved names. For example, a definition <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> has a reserved name <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo.def</span></code> for theorem
containing stating that <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo</span></code> is equal to its definition. The action associated with <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">foo.def</span></code>
automatically proves the theorem. At the macro level, the name is resolved, but the action is not
executed. The actions are executed by the elaborator when converting <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Syntax</span></code> into <code class="hl lean inline" data-lean-context="docstring-examples"><span class="unknown token" data-binding="">Expr</span></code>.</p>
                    </div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="quotation">
                20.5.3. Quotation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=quotation" title="Permalink">🔗</a></span></h2>
              <p>
                <span id="--tech-term-Quotation" class="def-technical-term"><em>Quotation</em></span> marks code for representation as data of type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code>.
Quoted code is parsed, but not elaborated—while it must be syntactically correct, it need not make sense.
Quotation makes it much easier to programmatically generate code: rather than reverse-engineering the specific nesting of <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax.node"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="5413">node</span></a></code> values that Lean's parser would produce, the parser can be directly invoked to create them.
This is also more robust in the face of refactoring of the grammar that may change the internals of the parse tree without affecting the user-visible concrete syntax.
Quotation in Lean is surrounded by <code>`(</code> and <code>)</code>.</p>
              <p>
                The syntactic category or parser being quoted may be indicated by placing its name after the opening backtick and parenthesis, followed by a vertical bar (<code>|</code>).
As a special case, the name <code>tactic</code> may be used to parse either tactics or sequences of tactics.
If no syntactic category or parser is provided, Lean attempts to parse the quotation both as a term and as a non-empty sequence of commands.
Term quotations have higher priority than command quotations, so in cases of ambiguity, the interpretation as a term is chosen; this can be overridden by explicitly indicating that the quotation is of a command sequence.</p>
              <details class="example"><summary class="description">Term vs Command Quotation Syntax</summary><div class="example-content">
                  <p>
                    In the following example, the contents of the quotation could either be a function application or a sequence of commands.
Both match the same region of the file, so the <a class="technical-term" href="Notations-and-Macros/Custom-Operators/#--tech-term-local-longest-match-rule">local longest-match rule</a> is not relevant.
Term quotation has a higher priority than command quotation, so the quotation is interpreted as a term.
Terms expect their <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-antiquotations">antiquotations</a> to have type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`term</span></code> rather than <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span></code>.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14079">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Application type mismatch: In the application
  cmd1.raw
the argument
  cmd1
has type
  TSyntax `command : Type
but is expected to have type
  TSyntax `term : Type</code></span></span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">Application type mismatch: In the application
  cmd2.raw
the argument
  cmd2
has type
  TSyntax `command : Type
but is expected to have type
  TSyntax `term : Type</code></span></span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span></span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    The result is two type errors like the following:</p>
                  <div class="error">
                    <pre>Application type mismatch: In the application
  cmd1.raw
the argument
  cmd1
has type
  TSyntax `command : Type
but is expected to have type
  TSyntax `term : Type
</pre></div>
                  <p>
                    The type of the quotation (<code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span></code>) is not used to select a result because syntax priorities are applied prior to elaboration.
In this case, specifying that the antiquotations are commands resolves the ambiguity because function application would require terms in these positions:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14726">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-14803">command</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-14817">command</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                    Similarly, inserting a command into the quotation eliminates the possibility that it could be a term:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14941">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`command</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1872">cmd1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1872">cmd2</span><span class="inter-text"> </span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15025" data-verso-hover="8">#eval</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5517">"hello!"</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                </details><div class="namedocs" id="term-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                <span class="label">syntax</span><span class="title">Quotations</span><div class="text">
                  <p>
                    Lean's syntax includes quotations for terms, commands, tactics, and sequences of tactics, as well as a general quotation syntax that allows any input that Lean can parse to be quoted.
Term quotations have the highest priority, followed by tactic quotations, general quotations, and finally command quotations.</p>
                  <pre class="grammar hl lean" data-lean-context="--grammar" id="Manual___FreeSyntax___more-next-next"><span class="nonterminal" data-kind="term">term</span> <span class="bnf">::=</span>
      <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.quot"><code class="hover-info"><code class="docstring">Syntax quotation for terms. </code></code><span class="keyword">`(</span><span class="nonterminal" data-kind="term.pseudo">term</span><span class="keyword">)</span></span></span></span>
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="keyword">`(</span><span class="nonterminal" data-kind="command">command</span><span class="bnf">+</span><span class="keyword">)</span></span></span>
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Tactic.quot"><span class="keyword">`(tactic|</span><span class="nonterminal" data-kind="tactic.pseudo">tactic</span><span class="keyword">)</span></span></span></span>
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Tactic.quotSeq"><span class="keyword">`(tactic|</span><span class="from-nonterminal" data-kind="Lean.Parser.Tactic.seq1"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="tactic.pseudo">tactic</span><span class="bnf">;*</span></span></span><span class="keyword">)</span></span></span></span>
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="keyword">`(</span><span class="local-name token documented" data-kind="ident" data-binding="grammar-var-3-p"><code class="hover-info"><code>p : ident</code></code>p</span><span class="bnf">:</span><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">|</span><span class="comment">Parse a <span class="local-name token documented" data-kind="ident" data-binding="grammar-var-3-p"><code class="hover-info"><code>p : ident</code></code>p</span> here </span><span class="keyword">)</span></span></span></pre></div>
                </div>
              <p>
                Rather than having type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code>, quotations are monadic actions with type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.7447" data-verso-hover="80">m</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a></code>.
Quotation is monadic because it implements <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-hygienic">hygiene</a> by adding <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> and pre-resolving identifiers, as described in <a href="Notations-and-Macros/Macros/#macro-hygiene">the section on hygiene</a>.
The specific monad to be used is an implicit parameter to the quotation, and any monad for which there is an instance of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span></code> type class is suitable.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span></code> extends <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.MonadRef" data-verso-hover="5519">MonadRef</span></code>, which gives the quotation access to the source location of the syntax that the macro expander or elaborator is currently processing. <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span></code> additionally includes the ability to add <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-macro-scopes">macro scopes</a> to identifiers and use a fresh macro scope for a sub-task.
Monads that support quotation include <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Term.TermElabM" data-verso-hover="77">TermElabM</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="76">CommandElabM</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="2705">TacticM</span></code>.</p>
              <section>
                <h3 id="quasiquotation">
                  20.5.3.1. Quasiquotation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=quasiquotation" title="Permalink">🔗</a></span></h3>
                <p>
                  <span id="--tech-term-Quasiquotation" class="def-technical-term"><em>Quasiquotation</em></span> is a form of quotation that may contain <span id="--tech-term-antiquotations" class="def-technical-term"><em>antiquotations</em></span>, which are regions of the quotation that are not quoted, but instead are expressions that are evaluated to yield syntax.
A quasiquotation is essentially a template; the outer quoted region provides a fixed framework that always yields the same outer syntax, while the antiquotations yield the parts of the final syntax that vary.
All quotations in Lean are quasiquotations, so no special syntax is needed to distinguish quasiquotations from other quotations.
The quotation process does not add macro scopes to identifiers that are inserted via antiquotations, because these identifiers either come from another quotation (in which case they already have macro scopes) or from the macro's input (in which case they should not have macro scopes, because they are not introduced by the macro).</p>
                <p>
                  Basic antiquotations consist of a dollar sign (<code>$</code>) immediately followed by an identifier.
This means that the value of the corresponding variable, which should be a syntax tree, is to be substituted into this position of the quoted syntax.
Entire expressions may be used as antiquotations by wrapping them in parentheses.</p>
                <p>
                  Lean's parser assigns every antiquotation a syntax category based on what the parser expects at the given position.
If the parser expects syntax category <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8627" data-verso-hover="5520">c</span></code>, then the antiquotation's type is <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8629" data-verso-hover="5520">c</span></code>.</p>
                <p>
                  Some syntax categories can be matched by elements of other categories.
For example, numeric and string literals are valid terms in addition to being their own syntax categories.
Antiquotations may be annotated with the expected category by suffixing them with a colon and the category name, which causes the parser to validate that the annotated category is acceptable in the given position and construct any intermediate layers that are required in the parse tree.</p>
                <div class="namedocs" id="antiquot">
                  <span class="label">syntax</span><span class="title">Antiquotations</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Manual___FreeSyntax___more-next-next-next"><span class="nonterminal" data-kind="antiquot">antiquot</span> <span class="bnf">::=</span>
      <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="keyword">$</span><span class="nonterminal" data-kind="ident">ident</span><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">)?</span></span></span>
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="keyword">$(</span><span class="nonterminal" data-kind="term">term</span><span class="keyword">)</span><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">:</span><span class="nonterminal" data-kind="ident">ident</span></span><span class="bnf">)?</span></span></span></pre><p>
                      Whitespace is not permitted between the dollar sign ('$') that initiates an antiquotation and the identifier or parenthesized term that follows.
Similarly, no whitespace is permitted around the colon that annotates the syntax category of the antiquotation.</p>
                    </div>
                  </div>
                <details class="example"><summary class="description">Quasiquotation</summary><div class="example-content">
                    <p>
                      Both forms of antiquotation are used in this example.
Because natural numbers are not syntax, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="5521">quote</span></code> is used to transform a number into syntax that represents it.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-21830" data-verso-hover="121">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Lean</span><span class="inter-text"> </span><a href="Namespaces-and-Sections/#Lean___Parser___Command___in" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-21830">in</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-21843">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="207">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5522">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term" title="Documentation for Lean.Syntax.Term"><span class="const token" data-binding="const-Lean.Syntax.Term" data-verso-hover="2123">Term</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="80">m</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5522">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="1873">quote</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
                  </details><details class="example"><summary class="description">Antiquotation Annotations</summary><div class="example-content">
                    <p>
                      This example requires that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9474" data-verso-hover="80">m</span></code> is a monad that can perform quotation.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-22127" data-verso-hover="123">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="207">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      By default, the antiquotation <code>$e</code> is expected to be a term, because that's the syntactic category that's immediately expected as the second argument to addition.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22375">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex1" data-verso-hover="5523">ex1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5430">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-22390">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-22399">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5430">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `term) : m (TSyntax `term)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-22414">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-ex1" data-verso-hover="5523">ex1</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `term) : m (TSyntax `term)
</pre></div>
                    <p>
                      Annotating <code>$e</code> as a numeric literal succeeds, because numeric literals are also valid terms.
The expected type of the parameter <code>e</code> changes to <code>TSyntax `num</code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22729">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex2" data-verso-hover="5524">ex2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5525">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-22744">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-22753">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="5525">e</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-22766">num</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `num) : m (TSyntax `term)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-22772">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-ex2" data-verso-hover="5524">ex2</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (e : TSyntax `num) : m (TSyntax `term)
</pre></div>
                    <p>
                      Spaces are not allowed between the dollar sign and the identifier.</p>
                    <pre class="syntax-error hl lean"><code class="line">def ex2 (e) := show m _ from `(2 +<span class="parse-message has-info error"><code class="hover-info">unexpected token '$'; expected '`(tactic|' or no space before spliced term</code> $</span> e:num)</code></pre><div class="error">
                      <pre>&lt;example&gt;:1:34-1:36: unexpected token '$'; expected '`(tactic|' or no space before spliced term</pre></div>
                    <p>
                      Spaces are also not allowed before the colon:</p>
                    <pre class="syntax-error hl lean"><code class="line">def ex2 (e) := show m _ from `(2 + $e<span class="parse-message has-info error"><code class="hover-info">unexpected token ':'; expected ')'</code> :</span>num)</code></pre><div class="error">
                      <pre>&lt;example&gt;:1:37-1:39: unexpected token ':'; expected ')'</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Expanding Quasiquotation</summary><div class="example-content">
                    <p>
                      Printing the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-f" data-verso-hover="5526">f</span></code> demonstrates the expansion of a quasiquotation.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-23572" data-verso-hover="121">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Lean</span><span class="inter-text"> </span><a href="Namespaces-and-Sections/#Lean___Parser___Command___in" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-23572">in</span></a><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-23585">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-f" data-verso-hover="5527">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="207">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="5522">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term" title="Documentation for Lean.Syntax.Term"><span class="const token" data-binding="const-Lean.Syntax.Term" data-verso-hover="2123">Term</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax"><span class="const token" data-binding="const-Lean.Syntax" data-verso-hover="31">Syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-23663">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="5522">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="1873">quote</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">def f : {m : Type → Type} → [Monad m] → [Lean.MonadQuotation m] → Lean.Term → Nat → m Syntax :=
fun {m} [Monad m] [Lean.MonadQuotation m] x n =&gt; do
  let info ← Lean.MonadRef.mkInfoFromRefPos
  let scp ← Lean.getCurrMacroScope
  let mainModule ← Lean.getMainModule
  pure
      {
          raw :=
            Syntax.node2 info `Lean.Parser.Term.fun (Syntax.atom info "fun")
              (Syntax.node4 info `Lean.Parser.Term.basicFun
                (Syntax.node1 info `null (Syntax.ident info "k".toSubstring' (Lean.addMacroScope mainModule `k scp) []))
                (Syntax.node info `null #[]) (Syntax.atom info "=&gt;")
                (Syntax.node3 info `«term_+_»
                  (Syntax.node3 info `«term_+_» x.raw (Syntax.atom info "+") (Lean.quote `term (n + 2)).raw)
                  (Syntax.atom info "+")
                  (Syntax.ident info "k".toSubstring' (Lean.addMacroScope mainModule `k scp) []))) }.raw</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-23699">#print</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-f" data-verso-hover="5528">f</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>def f : {m : Type → Type} → [Monad m] → [Lean.MonadQuotation m] → Lean.Term → Nat → m Syntax :=
fun {m} [Monad m] [Lean.MonadQuotation m] x n =&gt; do
  let info ← Lean.MonadRef.mkInfoFromRefPos
  let scp ← Lean.getCurrMacroScope
  let mainModule ← Lean.getMainModule
  pure
      {
          raw :=
            Syntax.node2 info `Lean.Parser.Term.fun (Syntax.atom info "fun")
              (Syntax.node4 info `Lean.Parser.Term.basicFun
                (Syntax.node1 info `null (Syntax.ident info "k".toSubstring' (Lean.addMacroScope mainModule `k scp) []))
                (Syntax.node info `null #[]) (Syntax.atom info "=&gt;")
                (Syntax.node3 info `«term_+_»
                  (Syntax.node3 info `«term_+_» x.raw (Syntax.atom info "+") (Lean.quote `term (n + 2)).raw)
                  (Syntax.atom info "+")
                  (Syntax.ident info "k".toSubstring' (Lean.addMacroScope mainModule `k scp) []))) }.raw
</pre></div>
                    <div class="paragraph">
                      <p>
                        In this output, the quotation is a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.do : term</code></code><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do"><code class="kw">do</code></a></span> block.
It begins by constructing the source information for the resulting syntax, obtained by querying the compiler about the current user syntax being processed.
It then obtains the current macro scope and the name of the module being processed, because macro scopes are added with respect to a module to enable independent compilation and avoid the need for a global counter.
It then constructs a node using helpers such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Syntax.node1" data-verso-hover="5529">Syntax.node1</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Syntax.node2" data-verso-hover="5530">Syntax.node2</span></code>, which create a <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax.node"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="5413">Syntax.node</span></a></code> with the indicated number of children.
The macro scope is added to each identifier, and <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax.raw"><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="5531">TSyntax.raw</span></a></code> is used to extract the contents of typed syntax wrappers.
The antiquotations of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.10347" data-verso-hover="5522">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="5521">quote</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10353" data-verso-hover="9">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">)</span></code> occur directly in the expansion, as parameters to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Syntax.node3" data-verso-hover="5532">Syntax.node3</span></code>.</p>
                      </div>
                    </div>
                  </details></section>
              <section>
                <h3 id="splices">
                  20.5.3.2. Splices<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=splices" title="Permalink">🔗</a></span></h3>
                <p>
                  In addition to including other syntax via antiquotations, quasiquotations can include <span id="--tech-term-splices" class="def-technical-term"><em>splices</em></span>.
Splices indicate that the elements of an array are to be inserted in order.
The repeated elements may include separators, such as the commas between list or array elements.
Splices may consist of an ordinary antiquotation with a <span id="--tech-term-splice-suffix" class="def-technical-term"><em>splice suffix</em></span>, or they may be <span id="--tech-term-extended-splices" class="def-technical-term"><em>extended splices</em></span> that provide additional repeated structure.</p>
                <p>
                  Splice suffixes consist of either an asterisk or a valid atom followed by an asterisk (<code>*</code>).
Suffixes may follow any identifier or term antiquotation.
An antiquotation with the splice suffix <code>*</code> corresponds to a use of <code>many</code> or <code>many1</code>; both the <code>*</code> and <code>+</code> suffixes in syntax rules correspond to the <code>*</code> splice suffix.
An antiquotation with a splice suffix that includes an atom prior to the asterisk corresponds to a use of <code>sepBy</code> or <code>sepBy1</code>.
The splice suffix <code>?</code> corresponds to a use of <code>optional</code> or the <code>?</code> suffix in a syntax rule.
Because <code>?</code> is a valid identifier character, identifiers must be parenthesized to use it as a suffix.</p>
                <p>
                  While there is overlap between repetition specifiers for syntax and antiquotation suffixes, they have distinct syntaxes.
When defining syntax, the suffixes <code>*</code>, <code>+</code>, <code>,*</code>, <code>,+</code>, <code>,*,?</code>, and <code>,+,?</code> are built in to Lean.
There is no shorter way to specify separators other than <code>,</code>.
Antiquotation suffixes are either just <code>*</code> or whatever atom was provided to <code>sepBy</code> or <code>sepBy1</code> followed by <code>*</code>.
The syntax repetitions <code>+</code> and <code>*</code> correspond to the splice suffix <code>*</code>; the repetitions <code>,*</code>, <code>,+</code>, <code>,*,?</code>, and <code>,+,?</code> correspond to <code>,*</code>.
The optional suffix <code>?</code> in syntax and splices correspond with each other.</p>
                <table class="tabular"><thead><tr><th><p>
                          Syntax Repetition</p>
                        </th><th><p>
                          Splice Suffix</p>
                        </th></tr></thead><tr><td><p>
                        <code>+</code> <code>*</code></p>
                      </td><td><p>
                        <code>*</code></p>
                      </td></tr><tr><td><p>
                        <code>,*</code> <code>,+</code> <code>,*,?</code> <code>,+,?</code></p>
                      </td><td><p>
                        <code>,*</code></p>
                      </td></tr><tr><td><p>
                        <code>sepBy(_, "S")</code> <code>sepBy1(_, "S")</code></p>
                      </td><td><p>
                        <code>S*</code></p>
                      </td></tr><tr><td><p>
                        <code>?</code></p>
                      </td><td><p>
                        <code>?</code></p>
                      </td></tr></table><details class="example"><summary class="description">Suffixed Splices</summary><div class="example-content">
                    <p>
                      This example requires that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.12304" data-verso-hover="80">m</span></code> is a monad that can perform quotation.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-27911" data-verso-hover="123">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="207">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      By default, the antiquotation <code>$e</code> is expected to be an array of terms separated by commas, as is expected in the body of a list:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28126">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex1" data-verso-hover="5533">ex1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="5534">xs</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-28142">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-28151">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="5534">xs</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Syntax.TSepArray `term ",") : m (TSyntax `term)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-28168">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-ex1" data-verso-hover="5533">ex1</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>ex1 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Syntax.TSepArray `term ",") : m (TSyntax `term)
</pre></div>
                    <p>
                      However, Lean includes a collection of coercions between various representations of arrays that will automatically insert or remove separators, so an ordinary array of terms is also acceptable:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28529">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex2" data-verso-hover="5535">ex2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="5536">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="284">Array</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">`term</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-28571">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="80">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-28580">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.98" data-verso-hover="5536">xs</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Array (TSyntax `term)) : m (TSyntax `term)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-28597">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-ex2" data-verso-hover="5535">ex2</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>ex2 {m : Type → Type} [Monad m] [MonadQuotation m] (xs : Array (TSyntax `term)) : m (TSyntax `term)
</pre></div>
                    <p>
                      Repetition annotations may also be used with term antiquotations and syntax category annotations.
This example is in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="76">CommandElabM</span></code> so the result can be conveniently logged.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28970">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex3" data-verso-hover="5537" id="ex3">ex3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="9">size</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-28994">show</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Command.CommandElabM" data-verso-hover="76">CommandElabM</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-29014">from</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-29019">do</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-29024">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-29028">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.219" data-verso-hover="283">nums</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="284">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-29058" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.213" data-verso-hover="9">i</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-29062">in</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="unknown token" data-binding="">:</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="9">size</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-29058" data-verso-hover="1144">do</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.219" data-verso-hover="283">nums</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.219" data-verso-hover="283">nums</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___push" title="Documentation for Array.push"><span class="const token" data-binding="const-Array.push" data-verso-hover="353">push</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.213" data-verso-hover="9">i</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-29105">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.981" data-verso-hover="5430">stx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.219" data-verso-hover="283">nums</span><span class="unknown token" data-binding="">.</span><a href="Basic-Types/Arrays/#Array___map" title="Documentation for Array.map"><span class="const token" data-binding="const-Array.map" data-verso-hover="5031">map</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Syntax.mkNumLit" data-verso-hover="1870">Syntax.mkNumLit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∘</span><span class="inter-text"> </span><span class="const token" data-binding="const-ToString.toString" data-verso-hover="756">toString</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-29163">num</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  -- Using logInfo here causes the syntax to be rendered via
  -- the pretty printer.
  </span><span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="5432">logInfo</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.981" data-verso-hover="5430">stx</span><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">#[0, 1, 2, 3]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-29273" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#ex3" title="Definition of example ex3"><span class="const token" data-binding="const-ex3" data-verso-hover="5537">ex3</span></a><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>#[0, 1, 2, 3]
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Non-Comma Separators</summary><div class="example-content">
                    <p>
                      The following unconventional syntax for lists separates numeric elements by either em dashes or double asterisks, rather than by commas.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-29526">syntax</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5538">"⟦"</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Syntax.sepBy1-29539">sepBy1(</span><span class="const token" data-binding="const-Lean.Parser.numLit" data-verso-hover="5539">num</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5540">" — "</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5541">"⟧"</span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="inter-text">
</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-29572">syntax</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5538">"⟦"</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Syntax.sepBy1-29585">sepBy1(</span><span class="const token" data-binding="const-Lean.Parser.numLit" data-verso-hover="5539">num</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5542">" ** "</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5541">"⟧"</span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      This means that <code>—*</code> and <code>***</code> are valid splice suffixes between the <code>⟦</code> and <code>⟧</code> atoms.
In the case of <code>***</code>, the first two asterisks are the atom in the syntax rule, while the third is the repetition suffix.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-29844">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">⟦</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.57" data-verso-hover="5543">n</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-29867">num</span><span class="unknown token" data-binding="">—*</span><span class="unknown token" data-binding="">⟧</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">⟦</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.57" data-verso-hover="5543">n</span><span class="unknown token" data-binding="">***</span><span class="unknown token" data-binding="">⟧</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">⟦</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.2638" data-verso-hover="5544">n</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-29909">num</span><span class="unknown token" data-binding="">***</span><span class="unknown token" data-binding="">⟧</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.2638" data-verso-hover="5544">n</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">[1, 2, 3]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-29965" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟦</span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">—</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">—</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">⟧</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>[1, 2, 3]
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Optional Splices</summary><div class="example-content">
                    <p>
                      The following syntax declaration optionally matches a term between two tokens.
The parentheses around the nested <code>term</code> are needed because <code>term?</code> is a valid identifier.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-30300">syntax</span></a><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5545">"⟨| "</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5546">" |⟩"</span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The <code>?</code> splice suffix for a term expects an <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term" title="Documentation for Lean.Syntax.Term"><span class="const token" data-binding="const-Lean.Syntax.Term" data-verso-hover="2123">Term</span></a></code>:</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30415">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-mkStx" data-verso-hover="5547" id="mkStx">mkStx</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Functors___-Monads-and--do--Notation/#Monad___mk" title="Documentation for Monad"><span class="const token" data-binding="const-Monad" data-verso-hover="207">Monad</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation" data-verso-hover="5518">MonadQuotation</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="5548">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term" title="Documentation for Lean.Syntax.Term"><span class="const token" data-binding="const-Lean.Syntax.Term" data-verso-hover="2123">Term</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="80">m</span><span class="inter-text"> </span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___Term" title="Documentation for Lean.Syntax.Term"><span class="const token" data-binding="const-Lean.Syntax.Term" data-verso-hover="2123">Term</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">⟨|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="5548">e</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|⟩</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">mkStx {m : Type → Type} [Monad m] [MonadQuotation m] (e : Option Term) : m Term</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-30542">#check</span></a></span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#mkStx" title="Definition of example mkStx"><span class="const token" data-binding="const-mkStx" data-verso-hover="5547">mkStx</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>mkStx {m : Type → Type} [Monad m] [MonadQuotation m] (e : Option Term) : m Term
</pre></div>
                    <p>
                      Supplying <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a></code> results in the optional term being present.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">⟨| 5 |⟩</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-30766" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-30772">do</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="5432">logInfo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#mkStx" title="Definition of example mkStx"><span class="const token" data-binding="const-mkStx" data-verso-hover="5547">mkStx</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.some"><span class="const token" data-binding="const-Option.some" data-verso-hover="47">some</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote" data-verso-hover="1873">quote</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">5</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>⟨| 5 |⟩
</pre></div>
                    <p>
                      Supplying <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a></code> results in the optional term being absent.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">⟨| |⟩</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-30951" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-30957">do</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="5432">logInfo</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#mkStx" title="Definition of example mkStx"><span class="const token" data-binding="const-mkStx" data-verso-hover="5547">mkStx</span></a><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option.none"><span class="const token" data-binding="const-Option.none" data-verso-hover="48">none</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>⟨| |⟩
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="token-antiquotations">
                  20.5.3.3. Token Antiquotations<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=token-antiquotations" title="Permalink">🔗</a></span></h3>
                <p>
                  In addition to antiquotations of complete syntax, Lean features <span id="--tech-term-token-antiquotations" class="def-technical-term"><em>token antiquotations</em></span> which allow the source information of an atom to be replaced with the source information from some other syntax.
The resulting synthetic source information is marked <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-canonical">canonical</a> so that it will be used for error messages, proof states, and other feedback.
This is primarily useful to control the placement of error messages or other information that Lean reports to users.
A token antiquotation does not allow an arbitrary atom to be inserted via evaluation.
A token antiquotation consists of an atom (that is, a keyword)</p>
                <div class="namedocs" id="antiquot-next">
                  <span class="label">syntax</span><span class="title">Token Antiquotations</span><div class="text">
                    <p>
                      Token antiquotations replace the source information (of type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___SourceInfo___original" title="Documentation for Lean.SourceInfo"><span class="const token" data-binding="const-Lean.SourceInfo" data-verso-hover="33">SourceInfo</span></a></code>) on a token with the source information from some other syntax.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Manual___FreeSyntax___done"><span class="nonterminal" data-kind="antiquot">antiquot</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Manual.FreeSyntax.rule"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="atom">atom</span><span class="keyword">%$</span><span class="nonterminal" data-kind="ident">ident</span></span></span></pre></div>
                  </div>
                </section>
              </section>
            <section>
              <h2 id="quote-patterns">
                20.5.4. Matching Syntax<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=quote-patterns" title="Permalink">🔗</a></span></h2>
              <p>
                Quasiquotations can be used in pattern matching to recognize syntax that matches a template.
Just as antiquotations in a quotation that's used as a term are regions that are treated as ordinary non-quoted expressions, antiquotations in patterns are regions that are treated as ordinary Lean patterns.
Quote patterns are compiled differently from other patterns, so they can't be intermixed with non-quote patterns in a single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span> expression.
Like ordinary quotations, quote patterns are first processed by Lean's parser.
The parser's output is then compiled into code that determines whether there is a match.
Syntax matching assumes that the syntax being matched was produced by Lean's parser, either via quotation or directly in user code, and uses this to omit some checks.
For example, if nothing but a particular keyword can be present in a given position, the check may be omitted.</p>
              <p>
                Syntax matches a quote pattern in the following cases:</p>
              <dl><dt> Atoms</dt><dd><p>
                    Keyword atoms (such as <span class="hl lean keyword-of"><code class="hover-info"><code>termIfThenElse : term</code><span class="sep"></span><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></code><a href="Terms/Conditionals/#termIfThenElse"><code class="kw">if</code></a></span> or <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Term.match : term</code><span class="sep"></span><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></code><a href="Terms/Pattern-Matching/#Lean___Parser___Term___match"><code class="kw">match</code></a></span>) result in singleton nodes whose kind is <code>token.</code> followed by the atom.
  In many cases, it is not necessary to check for specific atom values because the grammar allows only a single keyword, and no checking will be performed.
  If the syntax of the term being matched requires the check, then the node kind is compared.</p>
                  <p>
                    Literals, such as string or numeric literals, are compared via their underlying string representation.
  The pattern <code>`(0x15)</code> and the quotation <code>`(21)</code> do not match.</p>
                  </dd><dt> Nodes</dt><dd><p>
                    If both the pattern and the value being matched represent <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Syntax___missing" title="Documentation for Lean.Syntax.node"><span class="const token" data-binding="const-Lean.Syntax.node" data-verso-hover="5413">Syntax.node</span></a></code>, there is a match when both have the same syntax kind, the same number of children, and each child pattern matches the corresponding child value.</p>
                  </dd><dt> Identifiers</dt><dd><p>
                    If both the pattern and the value being matched are identifiers, then their literal <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Lean.Name" data-verso-hover="1627">Name</span></code> values are compared for equality modulo macro scopes.
  Identifiers that “look” the same match, and it does not matter if they refer to the same binding.
  This design choice allows quote pattern matching to be used in contexts that don't have access to a compile-time environment in which names can be compared by reference.</p>
                  </dd></dl><p>
                Because quotation pattern matching is based on the node kinds emitted by the parser, quotations that look identical may not match if they come from different syntax categories.
If in doubt, including the syntax category in the quotation can help.</p>
              </section>
            <section>
              <h2 id="defining-macros">
                20.5.5. Defining Macros<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=defining-macros" title="Permalink">🔗</a></span></h2>
              <p>
                There are two primary ways to define macros: the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command and the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command associates a macro with existing syntax, while the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command simultaneously defines new syntax and a macro that translates it to existing syntax.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command can be seen as a generalization of <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.notation : command</code></code><a href="Notations-and-Macros/Notations/#Lean___Parser___Command___notation"><code class="kw">notation</code></a></span> that allows the expansion to be generated programmatically, rather than simply by substitution.</p>
              <section>
                <h3 id="macro_rules">
                  20.5.5.1. The <code>macro_rules</code> Command<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro_rules" title="Permalink">🔗</a></span></h3>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Rule-Based Macros With <code class="plain-keyword">macro_rules</code></span><div class="text">
                    <p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command takes a sequence of rewrite rules, specified as syntax pattern matches, and adds each as a macro.
The rules are attempted in order, before previously-defined macros, and later macro definitions may add further macro rules.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___macro_rules"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.macro_rules"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><a href="Definitions/Modifiers/#Lean___Parser___Command___docComment"><span class="nonterminal documented" data-kind="Lean.Parser.Command.docComment"><code class="hover-info"><code class="docstring">A `docComment` parses a "documentation comment" like `/-- foo -/`. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.

A `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this
example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. </code></code>docComment</span></a></span><span class="bnf">?</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.attributes"><a href="Attributes/#Lean___Parser___Term___attributes-next"><span class="keyword">@[</span></a><span class="from-nonterminal" data-kind="null"><a href="Attributes/#Lean___Parser___Term___attrInstance-next"><span class="nonterminal" data-kind="Lean.Parser.Term.attrInstance">attrInstance</span></a><span class="bnf">,*</span></span><a href="Attributes/#Lean___Parser___Term___attributes-next"><span class="keyword">]</span></a></span></span><span class="bnf">)?</span>
      </span><span class="nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code>attrKind</span> <span class="keyword">macro_rules</span> <span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="keyword">(</span><span class="keyword">kind</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="ident">ident</span><span class="keyword">)</span></span><span class="bnf">)?</span>
        </span><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlts"><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.matchAlt"><span class="keyword">|</span> <span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal documented" data-kind="Lean.Parser.Term.quot"><code class="hover-info"><code class="docstring">Syntax quotation for terms. </code></code><span class="keyword">`(</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="local-name token documented" data-kind="ident" data-binding="grammar-var-0-p"><code class="hover-info"><code>p : ident</code></code>p</span><span class="bnf">:</span><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">|</span></span><span class="bnf">)?</span><span class="comment">Suitable syntax for <span class="local-name token documented" data-kind="ident" data-binding="grammar-var-0-p"><code class="hover-info"><code>p : ident</code></code>p</span> </span></span><span class="keyword">)</span> </span></span></span><span class="keyword">=&gt;</span> <span class="nonterminal" data-kind="term.pseudo">term</span></span></span><span class="bnf">)*</span></span></span></span></pre></div>
                  </div>
                <p>
                  The patterns in the macros must be quotation patterns.
They may match syntax from any syntax category, but a given pattern can only ever match a single syntax kind.
If no category or parser is specified for the quotation, then it may match terms or (sequences of) commands, but never both.
In case of ambiguity, the term parser is chosen.</p>
                <p>
                  Internally, macros are tracked in a table that maps each <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-kind">syntax kind</a> to its macros.
The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command may be explicitly annotated with a syntax kind.</p>
                <p>
                  If a syntax kind is explicitly provided, the macro definition checks that each quotation pattern has that kind.
If the parse result for the quotation was a <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-choice-node">choice node</a> (that is, if the parse was ambiguous), then the pattern is duplicated once for each alternative with the specified kind.
It is an error if none of the alternatives have the specified kind.</p>
                <p>
                  If no kind is provided explicitly, then the kind determined by the parser is used for each pattern.
The patterns are not required to all have the same syntax kind; macros are defined for each syntax kind used by at least one of the patterns.
It is an error if the parse result for a quotation pattern was a <a class="technical-term" href="Elaboration-and-Compilation/#--tech-term-choice-node">choice node</a> (that is, if the parse was ambiguous).</p>
                <p>
                  The documentation comment associated with <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> is displayed to users if the syntax itself has no documentation comment.
Otherwise, the documentation comment for the syntax itself is shown.</p>
                <p>
                  As with <a href="Notations-and-Macros/Notations/#notations">notations</a> and <a href="Notations-and-Macros/Custom-Operators/#operators">operators</a>, macro rules may be declared <code>scoped</code> or <code>local</code>.
Scoped macros are only active when the current namespace is open, and local macro rules are only active in the current <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scope</a>.</p>
                <details class="example"><summary class="description">Idiom Brackets</summary><div class="example-content">
                    <p>
                      Idiom brackets are an alternative syntax for working with applicative functors.
If the idiom brackets contain a function application, then the function is wrapped in <code class="hl lean inline" data-lean-context="examples"><a href="Functors___-Monads-and--do--Notation/#Pure___mk" title="Documentation for Pure.pure"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="1146">pure</span></a></code> and applied to each argument using <code>&lt;*&gt;</code>. 
Lean does not support idiom brackets by default, but they can be defined using a macro.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-38751">syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedName-38758">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-idiom" data-verso-hover="5549">idiom</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5538">"⟦"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="unknown token" data-binding="">:</span><a href="Notations-and-Macros/Precedence/#precArg" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-precArg-38786" data-verso-hover="5394">arg</span></a><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5541">"⟧"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="inter-text">

</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-38806">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">⟦</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="945">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="5550">args</span><span class="unknown token" data-binding="">*</span><span class="unknown token" data-binding="">⟧</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-38844">do</span></a><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-38851">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-38855">mut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.810" data-verso-hover="945">out</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">pure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.198" data-verso-hover="945">f</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-38882" data-verso-hover="1144">for</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.804" data-verso-hover="945">arg</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-38886">in</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="5550">args</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-38882" data-verso-hover="1144">do</span><span class="inter-text">
      </span><span class="var token" data-binding="var-_uniq.810" data-verso-hover="945">out</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.810" data-verso-hover="945">out</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;*&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.804" data-verso-hover="945">arg</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-38936" data-verso-hover="360">return</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.810" data-verso-hover="945">out</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      This new syntax can be used immediately.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-39001">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addFirstThird" data-verso-hover="5551" id="addFirstThird">addFirstThird</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><a href="Type-Classes/Basic-Classes/#Add___mk" title="Documentation for Add"><span class="const token" data-binding="const-Add" data-verso-hover="250">Add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="52">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="Basic-Types/Optional-Values/#Option___none" title="Documentation for Option"><span class="const token" data-binding="const-Option" data-verso-hover="45">Option</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="44">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">⟦</span><a href="Type-Classes/Basic-Classes/#Add___mk" title="Documentation for Add.add"><span class="const token" data-binding="const-Add.add" data-verso-hover="1661">Add.add</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="52">xs</span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11" data-verso-hover="52">xs</span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">?</span><span class="unknown token" data-binding="">⟧</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-39117" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#addFirstThird" title="Definition of example addFirstThird"><span class="const token" data-binding="const-addFirstThird" data-verso-hover="5551">addFirstThird</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>none
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-39211" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#addFirstThird" title="Definition of example addFirstThird"><span class="const token" data-binding="const-addFirstThird" data-verso-hover="5551">addFirstThird</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>none
</pre></div>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">some 4</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-39294" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#addFirstThird" title="Definition of example addFirstThird"><span class="const token" data-binding="const-addFirstThird" data-verso-hover="5551">addFirstThird</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="9">1</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">,</span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>some 4
</pre></div>
                    </div>
                  </details><details class="example"><summary class="description">Scoped Macros</summary><div class="example-content">
                    <p>
                      Scoped macro rules are active only in their namespace.
When the namespace <code>ConfusingNumbers</code> is open, numeric literals will be assigned an incorrect meaning.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___namespace" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-39575" data-verso-hover="122">namespace</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">ConfusingNumbers</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The following macro recognizes terms that are odd numeric literals, and replaces them with double their value.
If it unconditionally replaced them with double their value, then macro expansion would become an infinite loop because the same rule would always match the output.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.scoped-39892">scoped</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-39892">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="5552">n</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-39919">num</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___do" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-39928">do</span></a><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-39935">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="5552">n</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getNat" title="Documentation for Lean.TSyntax.getNat"><span class="const token" data-binding="const-Lean.TSyntax.getNat" data-verso-hover="5553">getNat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">%</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">0</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-39935">then</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">Lean.Macro.throwUnsupported</span></a><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-39992">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.405" data-verso-hover="9">n'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="5552">n</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getNat" title="Documentation for Lean.TSyntax.getNat"><span class="const token" data-binding="const-Lean.TSyntax.getNat" data-verso-hover="5553">getNat</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Syntax.mkNumLit" data-verso-hover="5555">Syntax.mkNumLit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">info</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="5552">n</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax.raw"><span class="const token" data-binding="const-Lean.TSyntax.raw" data-verso-hover="5556">raw</span></a><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Syntax.getHeadInfo" data-verso-hover="5557">getHeadInfo</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-ToString.toString" data-verso-hover="756">toString</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.405" data-verso-hover="9">n'</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Once the namespace ends, the macro is no longer used.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-40152" data-verso-hover="126">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ConfusingNumbers</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Without opening the namespace, numeric literals function in the usual way.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(3, 4)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-40277" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>(3, 4)
</pre></div>
                    <p>
                      When the namespace is open, the macro replaces <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="9">3</span></code> with <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="9">6</span></code>.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-40423" data-verso-hover="121">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">ConfusingNumbers</span><span class="inter-text">

</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(6, 4)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-40446" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="9">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="9">4</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>(6, 4)
</pre></div>
                    <p>
                      It is not typically useful to change the interpretation of numeric or other literals in macros.
However, scoped macros can be very useful when adding new rules to extensible tactics such as <code class="hl lean inline" data-lean-context="examples"><a href="Tactic-Proofs/Tactic-Reference/#trivial" title="Documentation for tactic"><span class="keyword token" data-binding="" data-verso-hover="387">trivial</span></a></code> that work well with the contents of the namespaces but should not always be used.</p>
                    </div>
                  </details><p>
                  Behind the scenes, a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command generates one macro function for each syntax kind that is matched in its quote patterns.
This function has a default case that throws the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code> exception, so further macros may be attempted.</p>
                <p>
                  A single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command with two rules is not always equivalent to two separate single-match commands.
First, the rules in a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> are tried from top to bottom, but recently-declared macros are attempted first, so the order would need to be reversed.
Additionally, if an earlier rule in the macro throws the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code> exception, then the later rules are not tried; if they were instead in separate <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> commands, then they would be attempted.</p>
                <details class="example"><summary class="description">One vs. Two Sets of Macro Rules</summary><div class="example-content">
                    <p>
                      The <code>arbitrary!</code> macro is intended to expand to some arbitrarily-determined value of a given type.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-41985">syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedName-41992">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-arbitrary!" data-verso-hover="5558">arbitrary!</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5559">"arbitrary! "</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="unknown token" data-binding="">:</span><a href="Notations-and-Macros/Precedence/#precArg" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-precArg-42032" data-verso-hover="5394">arg</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5481">term</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-42067">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42085">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42115">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">42</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42146">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.1095" data-verso-hover="945">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.1088" data-verso-hover="945">t2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42177">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.1095" data-verso-hover="945">t1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-arbitrary!-42193">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.1088" data-verso-hover="945">t2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42216">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Users may extend it by defining further sets of macro rules, such as this rule for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/The-Empty-Type/#Empty" title="Documentation for Empty"><span class="const token" data-binding="const-Empty" data-verso-hover="395">Empty</span></a></code> that fails:</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-42362">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42380">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Empty</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">throwUnsupported</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(42, 42)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-42446" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-arbitrary!-42452">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>(42, 42)
</pre></div>
                    <p>
                      If all of the macro rules had been defined as individual cases, then the result would have instead used the later case for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a></code>.
This is because the rules in a single <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command are checked from top to bottom, but more recently-defined <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> commands take precedence over earlier ones.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-42935">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42953">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-42981">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-42999">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">42</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43028">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43046">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.4919" data-verso-hover="945">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.4912" data-verso-hover="945">t2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43081">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.4919" data-verso-hover="945">t1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-arbitrary!-43097">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.4912" data-verso-hover="945">t2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43114">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43132">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43160">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43178">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Empty</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">throwUnsupported</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(0, 0)</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-43248" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-arbitrary!-43254">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>(0, 0)
</pre></div>
                    <p>
                      Additionally, if any rule throws the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Macro___Exception___unsupportedSyntax" title="Documentation for Lean.Macro.Exception.unsupportedSyntax"><span class="const token" data-binding="const-Lean.Macro.Exception.unsupportedSyntax" data-verso-hover="5506">unsupportedSyntax</span></a></code> exception, no further rules in that command are checked.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43484">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43502">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">throwUnsupported</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43551">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43583">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43601">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Array</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">42</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.macro_rules-43637">macro_rules</span></a><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="keyword token" data-binding="kw-occ-arbitrary!-43655">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Array</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">throwUnsupported</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      The case for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Linked-Lists/#List___nil" title="Documentation for List"><span class="const token" data-binding="const-List" data-verso-hover="43">List</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a></code> fails to elaborate, because macro expansion did not translate the <span class="hl lean keyword-of"><code class="hover-info"><code>arbitrary! : term</code></code><code class="kw">arbitrary!</code></span> syntax into something supported by the elaborator.</p>
                    <code class="hl lean block" data-lean-context="examples"><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-43924" data-verso-hover="8">#eval</span></a><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">elaboration function for 'arbitrary!' has not been implemented
  arbitrary! (List Nat)</code></span></span><span class="keyword token" data-binding="kw-occ-arbitrary!-43930">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="error">
                      <pre>elaboration function for 'arbitrary!' has not been implemented
  arbitrary! (List Nat)
</pre></div>
                    <p>
                      The case for <code class="hl lean inline" data-lean-context="examples"><a href="Basic-Types/Arrays/#Array___mk" title="Documentation for Array"><span class="const token" data-binding="const-Array" data-verso-hover="284">Array</span></a><span class="inter-text"> </span><a href="Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat"><span class="const token" data-binding="const-Nat" data-verso-hover="24">Nat</span></a></code> succeeds, because the first set of macro rules are attempted after the second throws the exception.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">#[42]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-44221" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-arbitrary!-44227">arbitrary!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Array</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>#[42]
</pre></div>
                    </div>
                  </details></section>
              <section>
                <h3 id="macro-command">
                  20.5.5.2. The <code>macro</code> Command<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-command" title="Permalink">🔗</a></span></h3>
                <p>
                  The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command simultaneously defines a new <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-rules">syntax rule</a> and associates it with a <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Macros">macro</a>.
Unlike <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.notation : command</code></code><a href="Notations-and-Macros/Notations/#Lean___Parser___Command___notation"><code class="kw">notation</code></a></span>, which can define only new term syntax and in which the expansion is a term into which the parameters are to be substituted, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command may define syntax in any <a class="technical-term" href="Notations-and-Macros/Defining-New-Syntax/#--tech-term-syntax-categories">syntax category</a> and it may use arbitrary code in the <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Macros/#Lean___MacroM" title="Documentation for Lean.MacroM"><span class="const token" data-binding="const-Lean.MacroM" data-verso-hover="5505">MacroM</span></a></code> monad to generate the expansion.
Because macros are so much more flexible than notations, Lean cannot automatically generate an unexpander; this means that new syntax implemented via the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command is available for use in <em>input</em> to Lean, but Lean's output does not use it without further work.</p>
                <div class="namedocs" id="command-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">syntax</span><span class="title">Macro Declarations</span><div class="text">
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___macro"><span class="nonterminal" data-kind="command">command</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.macro"><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="null"><a href="Definitions/Modifiers/#Lean___Parser___Command___docComment"><span class="nonterminal documented" data-kind="Lean.Parser.Command.docComment"><code class="hover-info"><code class="docstring">A `docComment` parses a "documentation comment" like `/-- foo -/`. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.

A `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this
example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. </code></code>docComment</span></a></span><span class="bnf">?</span>
      </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Term.attributes"><a href="Attributes/#Lean___Parser___Term___attributes-next"><span class="keyword">@[</span></a><span class="from-nonterminal" data-kind="null"><a href="Attributes/#Lean___Parser___Term___attrInstance-next"><span class="nonterminal" data-kind="Lean.Parser.Term.attrInstance">attrInstance</span></a><span class="bnf">,*</span></span><a href="Attributes/#Lean___Parser___Term___attributes-next"><span class="keyword">]</span></a></span></span><span class="bnf">)?</span>
      </span><span class="nonterminal documented" data-kind="Lean.Parser.Term.attrKind"><code class="hover-info"><code class="docstring">`attrKind` matches `("scoped" &lt;|&gt; "local")?`, used before an attribute like `@[local simp]`. </code></code>attrKind</span> <span class="keyword">macro</span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.precedence"><span class="keyword">:</span><span class="nonterminal" data-kind="prec.pseudo">prec</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.namedName"><span class="keyword">(</span><span class="keyword">name</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="ident">ident</span><span class="keyword">)</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="bnf">(</span><span class="from-nonterminal" data-kind="null"><span class="from-nonterminal" data-kind="Lean.Parser.Command.namedPrio"><span class="keyword">(</span><span class="keyword">priority</span> <span class="keyword">:=</span> <span class="nonterminal" data-kind="prio.pseudo">prio</span><span class="keyword">)</span></span></span><span class="bnf">)?</span> </span><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="Lean.Parser.Command.macroArg">macroArg</span><span class="bnf">*</span> </span><span class="from-nonterminal" data-kind="Lean.Parser.Command.macroTail"><span class="keyword">:</span> <span class="nonterminal" data-kind="ident">ident</span> <span class="keyword">=&gt;</span>
        <span class="nonterminal" data-kind="Lean.Parser.Command.macroRhs">macroRhs</span></span></span></pre></div>
                  </div>
                <div class="namedocs" id="Lean___Parser___Command___macroArg">
                  <span class="label">syntax</span><span class="title">Macro Arguments</span><div class="text">
                    <p>
                      A macro's arguments are either syntax items (as used in the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntax : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><code class="kw">syntax</code></a></span> command) or syntax items with attached names.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___macroArg-next"><span class="nonterminal" data-kind="Lean.Parser.Command.macroArg">macroArg</span> <span class="bnf">::=</span>
    <span class="from-nonterminal" data-kind="Lean.Parser.Command.macroArg"><span class="from-nonterminal" data-kind="null"></span><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></pre><pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Command___macroArg-next-next"><span class="nonterminal" data-kind="Lean.Parser.Command.macroArg">macroArg</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Command.macroArg"><span class="from-nonterminal" data-kind="null"><span class="nonterminal" data-kind="ident">ident</span><span class="keyword">:</span></span><span class="nonterminal" data-kind="stx.pseudo">stx</span></span></pre></div>
                  </div>
                <p>
                  In the expansion, the names that are attached to syntax items are bound; they have type <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="2118">TSyntax</span></a></code> for the appropriate syntax kinds.
If the syntax matched by the parser does not have a defined kind (e.g. because the name is applied to a complex specification), then the type is <code class="hl lean inline" data-lean-context="examples"><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___mk" title="Documentation for Lean.TSyntax"><span class="const token" data-binding="const-Lean.TSyntax" data-verso-hover="1863">TSyntax</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Name.anonymous" data-verso-hover="5560">Name.anonymous</span></code>.</p>
                <p>
                  The documentation comment is associated with the new syntax, and the attribute kind (none, <code>local</code>, or <code>scoped</code>) governs the visibility of the macro just as it does for notations: <code>scoped</code> macros are available in the namespace in which they are defined or in any <a class="technical-term" href="Namespaces-and-Sections/#--tech-term-section-scope">section scope</a> that opens that namespace, while <code>local</code> macros are available only in the local section scope.</p>
                <p>
                  Behind the scenes, the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro"><code class="kw">macro</code></a></span> command is itself implemented by a macro that expands it to a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.syntax : command</code></code><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax"><code class="kw">syntax</code></a></span> command and a <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command.
Any attributes applied to the macro command are applied to the syntax definition, but not to the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Command.macro_rules : command</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Command___macro_rules"><code class="kw">macro_rules</code></a></span> command.</p>
                </section>
              <section>
                <h3 id="macro-attribute">
                  20.5.5.3. The Macro Attribute<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=macro-attribute" title="Permalink">🔗</a></span></h3>
                <p>
                  <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Macros">Macros</a> can be manually added to a syntax kind using the <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Attr.macro : attr</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Attr___macro"><code class="kw">macro</code></a></span> attribute.
This low-level means of specifying macros is typically not useful, except as a result of code generation by macros that themselves generate macro definitions.</p>
                <div class="namedocs" id="attr-next-next-next-next-next-next-next-next-next-next-next-next">
                  <span class="label">attribute</span><span class="title">The <code class="plain-keyword">macro</code> Attribute</span><div class="text">
                    <p>
                      The <span class="hl lean keyword-of"><code class="hover-info"><code>Lean.Parser.Attr.macro : attr</code></code><a href="Notations-and-Macros/Macros/#Lean___Parser___Attr___macro"><code class="kw">macro</code></a></span> attribute specifies that a function is to be considered a <a class="technical-term" href="Notations-and-Macros/Macros/#--tech-term-Macros">macro</a> for the specified syntax kind.</p>
                    <pre class="grammar hl lean" data-lean-context="--grammar" id="Lean___Parser___Attr___macro"><span class="nonterminal" data-kind="attr">attr</span> <span class="bnf">::=</span> ...
    <span class="bnf">|</span> <span class="from-nonterminal" data-kind="Lean.Parser.Attr.macro"><span class="keyword">macro</span> <span class="nonterminal" data-kind="ident">ident</span></span></pre></div>
                  </div>
                <details class="example"><summary class="description">The Macro Attribute</summary><div class="example-content">
                    <code class="hl lean block" data-lean-context="examples"><span class="doc-comment token" data-binding="">/-- Generate a list based on N syntactic copies of a term -/</span><span class="inter-text">
</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___Parser___Command___syntax" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.syntax-48252">syntax</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namedName-48320">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-rep" data-verso-hover="5561">rep</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="190">"["</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.numLit" data-verso-hover="5562">num</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="5563">" !!! "</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="191">"]"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="5508">term</span><span class="inter-text">

</span><span class="unknown token" data-binding="">@[</span><a href="Notations-and-Macros/Macros/#Lean___Parser___Attr___macro" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Attr.macro-48369">macro</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-rep" data-verso-hover="5561">rep</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-48380">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-expandRep" data-verso-hover="5564" id="expandRep">expandRep</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Macro" data-verso-hover="5565">Macro</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">[</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="5525">n</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-48412">num</span><span class="inter-text"> </span><span class="unknown token" data-binding="">!!!</span><span class="inter-text"> </span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.183" data-verso-hover="5430">e</span><span class="unknown token" data-binding="">:</span><span class="keyword token" data-binding="kw-occ-antiquotName-48423">term</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-48438" data-verso-hover="110">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.200" data-verso-hover="5536">e'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">`Array.mkArray` has been deprecated: use `Array.replicate` instead</code></span></span><span class="const token" data-binding="const-Array.mkArray" data-verso-hover="5566">Array.mkArray</span></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.190" data-verso-hover="5525">n</span><span class="unknown token" data-binding="">.</span><a href="Notations-and-Macros/Defining-New-Syntax/#Lean___TSyntax___getNat" title="Documentation for Lean.TSyntax.getNat"><span class="const token" data-binding="const-Lean.TSyntax.getNat" data-verso-hover="5567">getNat</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.183" data-verso-hover="5430">e</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">$</span><span class="var token" data-binding="var-_uniq.200" data-verso-hover="5536">e'</span><span class="unknown token" data-binding="">,*</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><a href="Notations-and-Macros/Macros/#Lean___Macro___throwUnsupported" title="Documentation for Lean.Macro.throwUnsupported"><span class="const token" data-binding="const-Lean.Macro.throwUnsupported" data-verso-hover="5554">throwUnsupported</span></a><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><p>
                      Evaluating this new expression demonstrates that the macro is present.</p>
                    <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">["hello", "hello", "hello"]</code></span></span><a href="Interacting-with-Lean/#Lean___Parser___Command___eval" title="Documentation for syntax"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-48620" data-verso-hover="8">#eval</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">!!!</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="2265">"hello"</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code><div class="information">
                      <pre>["hello", "hello", "hello"]
</pre></div>
                    </div>
                  </details></section>
              </section>
            </section>
          <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=11415071-5949-444a-8c93-ef0905bcd026"><nav class="prev-next-buttons">
            <a class="local-button active" href="Notations-and-Macros/Defining-New-Syntax/#syntax-ext" rel="prev" title="20.4. Defining New Syntax"><span class="arrow">←</span><span class="where">20.4. Defining New Syntax</span></a><a class="local-button active" href="Notations-and-Macros/Elaborators/#elaborators" rel="next" title="20.6. Elaborators"><span class="where">20.6. Elaborators</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

