window.docContents[29].resolve({"/Type-Classes/Basic-Classes/#decidable-propositions":{"id":"/Type-Classes/Basic-Classes/#decidable-propositions","header":"11.5.4. Decidability","context":"Lean Reference\u0009Type Classes\u0009Basic Classes","contents":"A proposition is decidable if it can be checked algorithmically.\nThe Law of the Excluded Middle means that every proposition is true or false, but it provides no way to check which of the two cases holds, which can often be useful.\nBy default, only algorithmic Decidable instances for which code can be generated are in scope; opening the Classical namespace makes every proposition decidable.\n\nEither a proof that p is true or a proof that p is false. This is equivalent to a Bool paired\nwith a proof that the Bool is true if and only if p is true.Decidable instances are primarily used via if-expressions and the tactic decide. In\nconditional expressions, the Decidable instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\nBool-based conditional. In proofs, the tactic decide synthesizes an instance of Decidable p,\nattempts to reduce it to isTrue h, and then succeeds with the proof h if it can.Because Decidable carries data, when writing @[simp] lemmas which include a Decidable instance\non the LHS, it is best to use {_ : Decidable p} rather than [Decidable p] so that non-canonical\ninstances can be found via unification rather than instance synthesis.Proves that p is decidable by supplying a proof of ¬pProves that p is decidable by supplying a proof of p\n\nA decidable predicate.A predicate is decidable if the corresponding proposition is Decidable for each possible argument.\n\nA decidable relation.A relation is decidable if the corresponding proposition is Decidable for all possible arguments.\n\nPropositional equality is Decidable for all elements of a type.In other words, an instance of DecidableEq α is a means of deciding the proposition a = b is\nfor all a b : α.\n\nAbbreviation for DecidableRel (· < · : α → α → Prop).\n\nAbbreviation for DecidableRel (· ≤ · : α → α → Prop).\n\nConverts a decidable proposition into a Bool.If p : Prop is decidable, then decide p : Bool is the Boolean value\nthat is true if p is true and false if p is false.\n\nConstruct a q if some proposition p is decidable, and both the truth and falsity of p are\nsufficient to construct a q.This is a synonym for dite, the dependent if-then-else operator.\n\nExcluded Middle and DecidableThe equality of functions from Nat to Nat is not decidable:example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\nfailed to synthesize\n  Decidable (f = g)\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nOpening Classical makes every proposition decidable; however, declarations and examples that use this fact must be marked noncomputable to indicate that code should not be generated for them.open Classical\nnoncomputable example (f g : Nat → Nat) : Decidable (f = g) := inferInstance\n\n\n"},"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting":{"id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes--Polymorphism--Universe-Lifting","header":"4.3.2.3. Universe Lifting","context":"Lean Reference\u0009Type System\u0009Universes\u0009Polymorphism","contents":"When a type's universe is smaller than the one expected in some context, universe lifting operators can bridge the gap.\nThese are wrappers around terms of a given type that are in larger universes than the wrapped type.\nThere are two lifting operators:\n\n* PLift can lift any type, including propositions, by one level. It can be used to include proofs in data structures such as lists.* ULift can lift any non-proposition type by any number of levels.\n\nLifts a proposition or type to a higher universe level.PLift α wraps a proof or value of type α. The resulting type is in the next largest universe\nafter that of α. In particular, propositions become data.The related type ULift can be used to lift a non-proposition type by any number of levels.Examples:* (False : Prop)* (PLift False : Type)* ([.up (by trivial), .up (by simp), .up (by decide)] : List (PLift True))* (Nat : Type 0)* (PLift Nat : Type 1)Wraps a proof or value to increase its type's universe level by 1.Extracts a wrapped proof or value from a universe-lifted proposition or type.\n\nLifts a type to a higher universe level.ULift α wraps a value of type α. Instead of occupying the same universe as α, which would be\nthe minimal level, it takes a further level parameter and occupies their maximum. The resulting type\nmay occupy any universe that's at least as large as that of α.The resulting universe of the lifting operator is the first parameter, and may be written explicitly\nwhile allowing α's level to be inferred.The related type PLift can be used to lift a proposition or type by one level.Examples:* (Nat : Type 0)* (ULift Nat : Type 0)* (ULift Nat : Type 1)* (ULift Nat : Type 5)* (ULift.{7} (PUnit : Type 3) : Type 7)Wraps a value to increase its type's universe level.Extracts a wrapped value from a universe-lifted type.\n\n"},"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_":{"id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_","header":"17.10. Algebraic Solver (Commutative Rings, Fields)","context":"Lean Reference\u0009The  grind  tactic","contents":"The ring solver is inspired by Gröbner basis computation procedures and term rewriting completion.\nIt views multivariate polynomials as rewriting rules. For example, the polynomial equality x*y + x - 2 = 0\nis treated as a rewriting rule x*y ↦ -x + 2. It uses superposition to ensure the rewriting system is\nconfluent. Users can enable the ring solver for their own types by providing instances of\nthe following type classes, all in the Lean.Grind namespace.\nThe algebraic solvers will self-configure depending on the availability of these typeclasses, so not all need to be provided.\nThe capabilities of the algebraic solvers will of course degrade when some are not available.\n\nA semiring, i.e. a type equipped with addition, multiplication, and a map from the natural numbers,\nsatisfying appropriate compatibilities.Use Ring instead if the type also has negation,\nCommSemiring if the multiplication is commutative,\nor CommRing if the type has negation and multiplication is commutative.In every semiring there is a canonical map from the natural numbers to the semiring,\nproviding the values of 0 and 1. Note that this function need not be injective.Natural number numerals in the semiring.\nThe field ofNat_eq_natCast ensures that these are (propositionally) equal to the values of natCast.Scalar multiplication by natural numbers.Zero is the right identity for addition.Addition is commutative.Addition is associative.Multiplication is associative.One is the right identity for multiplication.One is the left identity for multiplication.Left distributivity of multiplication over addition.Right distributivity of multiplication over addition.Zero is right absorbing for multiplication.Zero is left absorbing for multiplication.The zeroth power of any element is one.The successor power law for exponentiation.Numerals are consistently defined with respect to addition.Numerals are consistently defined with respect to the canonical map from natural numbers.\n\nA ring, i.e. a type equipped with addition, negation, multiplication, and a map from the integers,\nsatisfying appropriate compatibilities.Use CommRing if the multiplication is commutative.In every ring there is a canonical map from the integers to the ring.Scalar multiplication by integers.Negation is the left inverse of addition.Subtraction is addition of the negative.Scalar multiplication by the negation of an integer is the negation of scalar multiplication by that integer.Scalar multiplication by natural numbers is consistent with scalar multiplication by integers.The canonical map from the integers is consistent with the canonical map from the natural numbers.The canonical map from the integers is consistent with negation.\n\nA commutative semiring, i.e. a semiring with commutative multiplication.Use CommRing if the type has negation.Multiplication is commutative.\n\nA commutative ring, i.e. a ring with commutative multiplication.Multiplication is commutative.\n\nA ring α has characteristic p if OfNat.ofNat x = 0 iff x % p = 0.Note that for p = 0, we have x % p = x, so this says that OfNat.ofNat is injective from Nat to α.In the case of a semiring, we take the stronger condition that\nOfNat.ofNat x = OfNat.ofNat y iff x % p = y % p.Two numerals in a semiring are equal iff they are congruent module p in the natural numbers.\n\nA type where addition is right-cancellative, i.e. a + c = b + c implies a = b.Addition is right-cancellative.\n\nWe say a module has no natural number zero divisors if\nk ≠ 0 and k * a = k * b implies a = b (here k is a natural number and a and b are element of the module).For a module over the integers this is equivalent to\nk ≠ 0 and k * a = 0 implies a = 0.\n(See the alternative constructor NoNatZeroDivisors.mk',\nand the theorem eq_zero_of_mul_eq_zero.)If k * a ≠ k * b then k ≠ 0 or a ≠ b.\n\nA field is a commutative ring with inverses for all non-zero elements.Division is multiplication by the inverse.Zero is not equal to one: fields are non trivial.The inverse of zero is zero. This is a \"junk value\" convention.The inverse of a non-zero element is a right inverse.\n\nThe Lean standard library contains the applicable instances for the types defined in core.\nMathlib is also pre-configured. For example, the Mathlib CommRing type class implements\nthe Lean.Grind.CommRing α to ensure the ring solver works out-of-the-box.\n\nThe following examples demonstrate goals that can be decided by the ring solver.\n\nopen Lean Grind\n\nexample [CommRing α] (x : α) : (x + 1)*(x - 1) = x^2 - 1 := by\n  grind\n\n-- The solver \"knows\" that `16*16 = 0` because the\n-- ring characteristic is `256`.\nexample [CommRing α] [IsCharP α 256] (x : α)\n    : (x + 16)*(x - 16) = x^2 := by\n  grind\n\n-- Types in the std library implement the appropriate type classes.\n-- `UInt8` is a commutative ring with characteristic `256`.\nexample (x : UInt8) : (x + 16)*(x - 16) = x^2 := by\n  grind\n\nexample [CommRing α] (a b c : α)\n    : a + b + c = 3 →\n      a^2 + b^2 + c^2 = 5 →\n      a^3 + b^3 + c^3 = 7 →\n      a^4 + b^4 = 9 - c^4 := by\n  grind\n\nexample [CommRing α] (x y : α)\n    : x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind\n\n-- `ring` proves that `a + 1 = 2 + a` is unsatisfiable because\n-- the characteristic is known.\nexample [CommRing α] [IsCharP α 0] (a : α)\n    : a + 1 = 2 + a → False := by\n  grind\n\n\nEven when the characteristic is not initially known, when grind discovers that n = 0 for some numeral n, it makes inferences about the characteristic:\n\nexample [CommRing α] (a b c : α)\n    (h₁ : a + 6 = a) (h₂ : c = c + 9) (h : b + 3*c = 0) :\n    27*a + b = 0 := by\n  grind\n\n\nThe class NoNatZeroDivisors is used to control coefficient growth.\nFor example, the polynomial 2*x*y + 4*z = 0 is simplified to x*y + 2*z = 0.\nIt also used when processing disequalities. In the following example,\nif you remove the local instance [NoNatZeroDivisors α], the goal will not be solved.\n\nexample [CommRing α] [NoNatZeroDivisors α] (a b : α)\n    : 2*a + 2*b = 0 → b ≠ -a → False := by\n  grind\n\n\nThe ring solver also has support for [Field α]. During preprocessing,\nit rewrites the term a/b as a*b⁻¹. It also rewrites every disequality\np ≠ 0 as the equality p * p⁻¹ = 1. This transformation is essential to\nprove the following example:\n\nexample [Field α] (a : α)\n    : a^2 = 0 → a = 0 := by\n  grind\n\n\nThe ring module also performs case-analysis for terms a⁻¹ on whether a is zero or not.\nIn the following example, if 2*a is zero, then a is also zero since\nwe have NoNatZeroDivisors α, and all terms are zero and the equality hold. Otherwise,\nring adds the equalities a*a⁻¹ = 1 and 2*a*(2*a)⁻¹ = 1, and closes the goal.\n\nexample [Field α] [NoNatZeroDivisors α] (a : α)\n    : 1 / a + 1 / (2 * a) = 3 / (2 * a) := by\n  grind\n\n\nWithout NoNatZeroDivisors, grind will perform case splits on numerals being zero as needed:\n\nexample [Field α] (a : α) : (2 * a)⁻¹ = a⁻¹ / 2 := by grind\n\n\nIn the following example, ring does not need to perform any case split because\nthe goal contains the disequalities y ≠ 0 and w ≠ 0.\n\nexample [Field α] {x y z w : α}\n    : x / y = z / w → y ≠ 0 → w ≠ 0 → x * w = z * y := by\n  grind (splits := 0)\n\n\nYou can disable the ring solver using the option grind -ring.\n\nexample [CommRing α] (x y : α)\n    : x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind -ring\n\n\nThe ring solver automatically embeds CommSemirings into a CommRing envelope (using the construction Lean.Grind.Ring.OfSemiring.Q).\nHowever, the embedding is injective only when the CommSemiring implements the type class AddRightCancel.\nThe type Nat is an example of such a commutative semiring implementing AddRightCancel.\n\nexample (x y : Nat)\n    : x^2*y = 1 → x*y^2 = y → y*x = 1 := by\n  grind\n\n\nGröbner basis computation can be very expensive. You can limit the number of steps performed by\nthe ring solver using the option grind (ringSteps := <num>)\n\nexample {α} [CommRing α] [IsCharP α 0] (d t c : α) (d_inv PSO3_inv : α)\n    : d^2 * (d + t - d * t - 2) * (d + t + d * t) = 0 →\n     -d^4 * (d + t - d * t - 2) *\n     (2 * d + 2 * d * t - 4 * d * t^2 + 2 * d * t^4 +\n      2 * d^2 * t^4 - c * (d + t + d * t)) = 0 →\n     d * d_inv = 1 →\n     (d + t - d * t - 2) * PSO3_inv = 1 →\n     t^2 = t + 1 := by\n  -- This example cannot be solved by performing at most 100 steps\n  grind (ringSteps := 100)\n\n\nThe ring solver propagates equalities back to the grind core by normalizing terms using the\ncomputed Gröbner basis. In the following example, the equations x^2*y = 1 and x*y^2 = y imply the equalities\nx = 1 and y = 1. Thus, the terms x*y and 1 are equal, and consequently some (x*y) = some 1\nby congruence.\n\nexample (x y : Int)\n    : x^2*y = 1 → x*y^2 = y → some (y*x) = some 1 := by\n  grind\n\n\nPlanned future features: support for noncommutative rings and semirings.\n\n"},"/Basic-Types/Strings/#string-api-props":{"id":"/Basic-Types/Strings/#string-api-props","header":"19.8.4.3. Properties","context":"Lean Reference\u0009Basic Types\u0009Strings\u0009API Reference","contents":"Checks whether a string is empty.Empty strings are equal to \"\" and have length and end position 0.Examples:* \"\".isEmpty = true* \"empty\".isEmpty = false* \" \".isEmpty = false\n\nReturns the length of a string in Unicode code points.Examples:* \"\".length = 0* \"abc\".length = 3* \"L∃∀N\".length = 4\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Hash-Maps--Conversion","header":"19.17.2.6. Conversion","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Hash Maps","contents":"Creates a hash map from a list of mappings. If the same key appears multiple times, the last\noccurrence takes precedence.\n\nTransforms the hash map into an array of mappings in some order.\n\nTransforms the hash map into a list of mappings in some order.\n\nCreates a hash map from an array of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofArray, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\nCreates a hash map from a list of keys, associating the value () with each key.This is mainly useful to implement HashSet.ofList, so if you are considering using this,\nHashSet or HashSet.Raw might be a better fit for you.\n\n"}});