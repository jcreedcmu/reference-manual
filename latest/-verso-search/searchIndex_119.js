window.docContents[119].resolve({"/Basic-Types/Maps-and-Sets/#DHashMap":{"id":"/Basic-Types/Maps-and-Sets/#DHashMap","header":"19.17.3. Dependent Hash Maps","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"The declarations in this section should be imported using import Std.DHashMap.\n\nDependent hash maps.This is a simple separate-chaining hash table. The data of the hash map consists of a cached size\nand an array of buckets, where each bucket is a linked list of key-value pais. The number of buckets\nis always a power of two. The hash map doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash map is used linearly to\navoid expensive copies.The hash map uses == (provided by the BEq typeclass) to compare keys and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.These hash maps contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.DHashMap.Raw and\nStd.DHashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer\nDHashMap over DHashMap.Raw.For a variant that is more convenient for use in proofs because of extensionalities, see\nStd.ExtDHashMap which is defined in the module Std.Data.ExtDHashMap.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});