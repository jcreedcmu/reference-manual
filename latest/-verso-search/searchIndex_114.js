window.docContents[114].resolve({"/Source-Files-and-Modules/#module-encoding":{"id":"/Source-Files-and-Modules/#module-encoding","header":"5.1. Encoding and Representation","context":"Lean Reference\u0009Source Files and Modules","contents":"Lean modules are Unicode text files encoded in UTF-8. \nLines may end either with newline characters (\"\\n\", Unicode 'LINE FEED (LF)' (U+000A)) or with a form feed and newline sequence (\"\\r\\n\", Unicode 'CARRIAGE RETURN (CR)' (U+000D) followed by 'LINE FEED (LF)' (U+000A)).\nHowever, Lean normalizes line endings when parsing or comparing files, so all files are compared as if all their line endings are \"\\n\".\n\n\n\n"},"/Basic-Types/Maps-and-Sets/#ExtHashSet":{"id":"/Basic-Types/Maps-and-Sets/#ExtHashSet","header":"19.17.7. Extensional Hash Sets","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets","contents":"Hash sets.This is a simple separate-chaining hash table. The data of the hash set consists of a cached size\nand an array of buckets, where each bucket is a linked list of keys. The number of buckets\nis always a power of two. The hash set doubles its size upon inserting an element such that the\nnumber of elements is more than 75% of the number of buckets.The hash table is backed by an Array. Users should make sure that the hash set is used linearly to\navoid expensive copies.The hash set uses == (provided by the BEq typeclass) to compare elements and hash (provided by\nthe Hashable typeclass) to hash them. To ensure that the operations behave as expected, ==\nshould be an equivalence relation and a == b should imply hash a = hash b (see also the\nEquivBEq and LawfulHashable typeclasses). Both of these conditions are automatic if the BEq\ninstance is lawful, i.e., if a == b implies a = b.In contrast to regular hash sets, Std.ExtHashSet offers several extensionality lemmas\nand therefore has more lemmas about equality of hash maps. This however also makes it lose the\nability to iterate freely over hash sets.These hash sets contain a bundled well-formedness invariant, which means that they cannot\nbe used in nested inductive types. For these use cases, Std.HashSet.Raw and\nStd.HashSet.Raw.WF unbundle the invariant from the hash set. When in doubt, prefer\nHashSet or ExtHashSet over HashSet.Raw.Internal implementation detail of the hash set.\n\n\n\n\n\n\n\n\n\n\n\n"}});