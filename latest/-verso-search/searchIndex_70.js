window.docContents[70].resolve({"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors":{"id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-recursors","header":"4.4.5.2. Recursors","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types","contents":"Mutual inductive types are provided with primitive recursors, just like non-mutually-defined inductive types.\nThese recursors take into account that they must process the other types in the group, and thus will have a motive for each inductive type.\nBecause all inductive types in the mutual group are required to have identical parameters, the recursors still take the parameters first, abstracting them over the motives and the rest of the recursor.\nAdditionally, because the recursor must process the group's other types, it will require cases for each constructor of each of the types in the group.\nThe actual dependency structure between the types is not taken into account; even if an additional motive or constructor case is not really required due to there being fewer mutual dependencies than there could be, the generated recursor still requires them.\n\nEven and oddmutual\n  inductive Even : Nat → Prop where\n    | zero : Even 0\n    | succ : Odd n → Even (n + 1)\n  inductive Odd : Nat → Prop where\n    | succ : Even n → Odd (n + 1)\nend\nEven.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : {n : Nat} → (a : Odd n) → motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) →\n  ∀ {a : Nat} (t : Even a), motive_1 a t\nOdd.rec\n  {motive_1 : (a : Nat) → Even a → Prop}\n  {motive_2 : (a : Nat) → Odd a → Prop}\n  (zero : motive_1 0 Even.zero)\n  (succ : ∀ {n : Nat} (a : Odd n), motive_2 n a → motive_1 (n + 1) (Even.succ a)) :\n  (∀ {n : Nat} (a : Even n), motive_1 n a → motive_2 (n + 1) (Odd.succ a)) → ∀ {a : Nat} (t : Odd a), motive_2 a t\n\n\nSpuriously mutual typesThe types Two and Three are defined in a mutual block, even though they do not refer to each other:mutual\n  inductive Two (α : Type) where\n    | mk : α → α → Two α\n  inductive Three (α : Type) where\n    | mk : α → α → α → Three α\nend\nTwo's recursor, Two.rec, nonetheless requires a motive and a case for Three:Two.rec.{u} {α : Type}\n  {motive_1 : Two α → Sort u}\n  {motive_2 : Three α → Sort u}\n  (mk : (a a_1 : α) → motive_1 (Two.mk a a_1)) :\n  ((a a_1 a_2 : α) → motive_2 (Three.mk a a_1 a_2)) → (t : Two α) → motive_1 t\n\n\n"},"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples":{"id":"/Error-Explanations/lean___ctorResultingTypeMismatch/#The-Lean-Language-Reference--Error-Explanations--lean___ctorResultingTypeMismatch--Examples","header":"Examples","context":"Lean Reference\u0009Error Explanations\u0009lean.ctorResultingTypeMismatch","contents":"Typo in resulting typeinductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Treee α\nUnexpected resulting type for constructor 'Tree.node': Expected an application of\n  Tree\nbut found\n  ?m.22\ninductive Tree (α : Type) where\n  | leaf : Tree α\n  | node : α → Tree α → Tree α\n\n\nMissing resulting type after constructor parameterinductive Credential where\n  | pin      : Nat\n  | password : String\nUnexpected resulting type for constructor 'Credential.pin': Expected\n  Credential\nbut found\n  Nat\ninductive Credential where\n  | pin      : Nat → Credential\n  | password : String → Credential\ninductive Credential where\n  | pin (num : Nat)\n  | password (str : String)\nIf the type of a constructor is annotated, the full type—including the resulting type—must be\nprovided. Alternatively, constructor parameters can be written using named binders; this allows the\nomission of the constructor's resulting type because it contains no indices.\n\n"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration":{"id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Iteration","header":"19.12.2.5. Iteration","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","contents":"Option can be thought of as a collection that contains at most one value.\nFrom this perspective, iteration operators can be understood as performing some operation on the contained value, if present, or doing nothing if not.\n\nChecks whether an optional value either satisfies a Boolean predicate or is none.Examples:* `(some 33).all (· % 2 == 0) = false* `(some 22).all (· % 2 == 0) = true* `none.all (fun x : Nat => x % 2 == 0) = true\n\nChecks whether an optional value is not none and satisfies a Boolean predicate.Examples:* `(some 33).any (· % 2 == 0) = false* `(some 22).any (· % 2 == 0) = true* `none.any (fun x : Nat => true) = false\n\nKeeps an optional value only if it satisfies a Boolean predicate.If Option is thought of as a collection that contains at most one element, then Option.filter is\nanalogous to List.filter or Array.filter.Examples:* (some 5).filter (· % 2 == 0) = none* (some 4).filter (· % 2 == 0) = some 4* none.filter (fun x : Nat => x % 2 == 0) = none* none.filter (fun x : Nat => true) = none\n\nExecutes a monadic action on an optional value if it is present, or does nothing if there is no\nvalue.Examples:#eval ((some 5).forM set : StateM Nat Unit).run 0\n((), 5)\n#eval (none.forM (fun x : Nat => set x) : StateM Nat Unit).run 0\n((), 0)\n\n\nApply a function to an optional value, if present.From the perspective of Option as a container with at most one value, this is analogous to\nList.map. It can also be accessed via the Functor Option instance.Examples:* (none : Option Nat).map (· + 1) = none* (some 3).map (· + 1) = some 4\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.This is an alias for Option.mapM, which already works for applicative functors.\n\nApplies a function in some applicative functor to an optional value, returning none with no\neffects if the value is missing.Runs a monadic function f on an optional value, returning the result. If the optional value is\nnone, the function is not called and the result is also none.From the perspective of Option as a container with at most one element, this is analogous to\nList.mapM, returning the result of running the monadic function on all elements of the container.This function only requires m to be an applicative functor. An alias Option.mapA is provided.\n\n"},"/Basic-Types/Characters/#char-syntax":{"id":"/Basic-Types/Characters/#char-syntax","header":"19.7.3. Syntax","context":"Lean Reference\u0009Basic Types\u0009Characters","contents":"Character literals consist of a single character or an escape sequence enclosed in single quotes (', Unicode 'APOSTROPHE' (U+0027)).\nBetween these single quotes, the character literal may contain character other that ', including newlines, which are included literally (with the caveat that all newlines in a Lean source file are interpreted as '\\n', regardless of file encoding and platform).\nSpecial characters may be escaped with a backslash, so '\\'' is a character literal that contains a single quote.\nThe following forms of escape sequences are accepted:\n\n \\r, \\n, \\t, \\\\, \\\", \\'\n\nThese escape sequences have the usual meaning, mapping to CR, LF, tab, backslash, double quote, and single quote, respectively.\n\n \\xNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the two-digit hexadecimal code.\n\n \\uNNNN\n\nWhen NN is a sequence of two hexadecimal digits, this escape denotes the character whose Unicode code point is indicated by the four-digit hexadecimal code.\n\n\n\n"}});