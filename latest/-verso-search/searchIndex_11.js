window.docContents[11].resolve({"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes":{"id":"/The-Type-System/Universes/#The-Lean-Language-Reference--The-Type-System--Universes","header":"4.3. Universes","context":"Lean Reference\u0009Type System","contents":"Types are classified by universes. Universes are also referred to as sorts.\nEach universe has a level,  which is a natural number.\nThe Sort operator constructs a universe from a given level. \nIf the level of a universe is smaller than that of another, the universe itself is said to be smaller.\nWith the exception of propositions (described later in this chapter), types in a given universe may only quantify over types in smaller universes.\nSort 0 is the type of propositions, while each Sort (u + 1) is a type that describes data.\n\nEvery universe is an element of the next larger universe, so Sort 5 includes Sort 4.\nThis means that the following examples are accepted:\n\nexample : Sort 5 := Sort 4\nexample : Sort 2 := Sort 1\n\n\nOn the other hand, Sort 3 is not an element of Sort 5:\n\nexample : Sort 5 := Sort 3\n\n\ntype mismatch\n  Type 2\nhas type\n  Type 3 : Type 4\nbut is expected to have type\n  Type 4 : Type 5\n\n\nSimilarly, because Unit is in Sort 1, it is not in Sort 2:\n\nexample : Sort 1 := Unit\n\n\nexample : Sort 2 := Unit\n\n\ntype mismatch\n  Unit\nhas type\n  Type : Type 1\nbut is expected to have type\n  Type 1 : Type 2\n\n\nBecause propositions and data are used differently and are governed by different rules, the abbreviations Type and Prop are provided to make the distinction more convenient.   \nType u is an abbreviation for Sort (u + 1), so Type 0 is Sort 1 and Type 3 is Sort 4.\nType 0 can also be abbreviated Type, so Unit : Type and Type : Type 1.\nProp is an abbreviation for Sort 0.\n\n\n\n\n\n"},"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-naming":{"id":"/The-Simplifier/Invoking-the-Simplifier/#simp-tactic-naming","header":"16.1. Invoking the Simplifier","context":"Lean Reference\u0009The Simplifier","contents":"Lean's simplifier can be invoked in a variety of ways.\nThe most common patterns are captured in a set of tactics.\nThe tactic reference contains a complete list of simplification tactics.\n\nSimplification tactics all contain simp in their name.\nAside from that, they are named according to a system of prefixes and suffixes that describe their functionality:\n\n -! suffix\n\nSets the autoUnfold configuration option to true, causing the simplifier unfold all definitions\n\n -? suffix\n\nCauses the simplifier to keep track of which rules it employed during simplification and suggest a minimal simp set as an edit to the tactic script\n\n -_arith suffix\n\nEnables the use of linear arithmetic simplification rules\n\n d- prefix\n\nCauses the simplifier to simplify only with rewrites that hold definitionally\n\n -_all suffix\n\nCauses the simplifier to repeatedly simplify all assumptions and the conclusion of the goal, taking as many hypotheses into account as possible, until no further simplification is possible\n\n\n\nThere are two further simplification tactics, simpa and simpa!, which are used to simultaneously simplify a goal and either a proof term or an assumption before discharging the goal.\nThis simultaneous simplification makes proofs more robust to changes in the simp set.\n\n\n\n"},"/Terms/Function-Types/#function-types":{"id":"/Terms/Function-Types/#function-types","header":"10.2. Function Types","context":"Lean Reference\u0009Terms","contents":"Lean's function types describe more than just the function's domain and codomain.\nThey also provide instructions for elaborating application sites by indicating that some parameters are to be discovered automatically via unification or type class synthesis, that others are optional with default values, and that yet others should be synthesized using a custom tactic script.\nFurthermore, their syntax contains support for abbreviating curried functions.\n\nFunction typesDependent function types include an explicit name:Non-dependent function types do not:\n\nCurried Function TypesDependent function types may include multiple parameters that have the same type in a single set of parentheses:This is equivalent to repeating the type annotation for each parameter name in a nested function type.\n\nImplicit, Optional, and Auto ParametersFunction types can describe functions that take implicit, instance implicit, optional, and automatic parameters.\nAll but instance implicit parameters require one or more names.\n\nMultiple Parameters, Same TypeThe type of Nat.add can be written in the following ways:* Nat → Nat → Nat* (a : Nat) → (b : Nat) → Nat* (a b : Nat) → NatThe last two types allow the function to be used with named arguments; aside from this, all three are equivalent.\n\n"},"/Namespaces-and-Sections/#namespaces-sections":{"id":"/Namespaces-and-Sections/#namespaces-sections","header":"6. Namespaces and Sections","context":"Lean Reference","contents":"Names are organized into hierarchical namespaces, which are collections of names.\nNamespaces are the primary means of organizing APIs in Lean: they provide an ontology of operations, grouping related items.\nAdditionally, while this is not done by giving them names in the namespace, the effects of features such as syntax extensions, instances, and attributes can be attached to a namespace.\n\nSorting operations into namespaces organizes libraries conceptually, from a global perspective.\nAny given Lean file will, however, typically not use all names equally.\nSections provide a means of ordering a local view of the globally-available collection of names, as well as a way to precisely control the scope of compiler options along with language extensions, instances, and attributes.\nThey also allow parameters shared by many declarations to be declared centrally and propagated as needed using the variable command.\n\n\n\n\n\n"}});