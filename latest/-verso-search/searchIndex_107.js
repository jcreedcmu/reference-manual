window.docContents[107].resolve({"/The-Type-System/Quotients/#quotient-elim":{"id":"/The-Type-System/Quotients/#quotient-elim","header":"4.5.4.2. Eliminating Quotients","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Quotient API","contents":"Functions from quotients can be defined by proving that a function from the underlying type respects the quotient's equivalence relation.\nThis is accomplished using Quotient.lift or its binary counterpart Quotient.lift₂.\nThe variants Quotient.liftOn and Quotient.liftOn₂ place the quotient parameter first rather than last in the parameter list.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.Given s : Setoid α and a quotient Quotient s, applying a function f : α → β requires a proof\nh that f respects the equivalence relation s.r. In this case, the function\nQuotient.lift f h : Quotient s → β computes the same values as f.Quotient.liftOn is a version of this operation that takes the quotient value as its first explicit\nparameter.\n\nLifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.Given s : Setoid α and a quotient value q : Quotient s, applying a function f : α → β requires\na proof c that f respects the equivalence relation s.r. In this case, the term\nQuotient.liftOn q f h : β reduces to the result of applying f to the underlying α value.Quotient.lift is a version of this operation that takes the quotient value last, rather than\nfirst.\n\nLifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.Quotient.lift is a version of this operation for unary functions. Quotient.liftOn₂ is a version\nthat take the quotient parameters first.\n\nLifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.Quotient.liftOn is a version of this operation for unary functions. Quotient.lift₂ is a version\nthat take the quotient parameters last.\n\nInteger Negation and AdditionGiven the encoding Z of integers as a quotient of pairs of natural numbers, negation can be implemented by swapping the first and second projections:def neg' : Z' → Z\n  | (x, y) => .mk (y, x)\nThis can be transformed into a function from Z to Z by proving that negation respects the equivalence relation:instance : Neg Z where\n  neg :=\n    Quotient.lift neg' <| by\n      intro n k equiv\n      apply Quotient.sound\n      simp only [· ≈ ·, Setoid.r, Z.eq] at *\n      omega\nSimilarly, Quotient.lift₂ is useful for defining binary functions from a quotient type.\nAddition is defined point-wise:def add' (n k : Nat × Nat) : Z :=\n  .mk (n.1 + k.1, n.2 + k.2)\nLifting it to the quotient requires a proof that addition respects the equivalence relation:instance : Add Z where\n  add (n : Z) :=\n    n.lift₂ add' <| by\n      intro n k n' k'\n      intro heq heq'\n      apply Quotient.sound\n      cases n; cases k; cases n'; cases k'\n      simp_all only [· ≈ ·, Setoid.r, Z.eq]\n      omega\n\n\nWhen the function's result type is a subsingleton, Quotient.recOnSubsingleton or Quotient.recOnSubsingleton₂ can be used to define the function.\nBecause all elements of a subsingleton are equal, such a function automatically respects the equivalence relation, so there is no proof obligation.\n\nAn alternative recursion or induction principle for quotients that can be used when the target type\nis a subsingleton, in which all elements are equal.In these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.Quotient.rec does not assume that the target type is a subsingleton.\n\nAn alternative induction or recursion operator for defining binary operations on quotients that can\nbe used when the target type is a subsingleton.In these cases, the proof that the function respects the quotient's equivalence relation is trivial,\nso any function can be lifted.\n\n"},"/The--grind--tactic/Linear-Integer-Arithmetic-Solver/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic-Solver":{"id":"/The--grind--tactic/Linear-Integer-Arithmetic-Solver/#The-Lean-Language-Reference--The--grind--tactic--Linear-Integer-Arithmetic-Solver","header":"17.9. Linear Integer Arithmetic Solver","context":"Lean Reference\u0009The  grind  tactic","contents":"The linear integer arithmetic solver, cutsat, implements a model-based decision procedure for linear integer arithmetic,\ninspired by Section 4 of \"Cutting to the Chase: Solving Linear Integer Arithmetic\".\nThe implementation in grind includes several enhancements and modifications such as\n\n* Extended constraint support (equality and disequality).* Optimized encoding of the Cooper-Left rule using a \"big\"-disjunction instead of fresh variables.* Decision variable tracking for case splits (disequalities, Cooper-Left, Cooper-Right).\n\nThe solver can process four categories of linear polynomial constraints (where p is a linear polynomial):\n\n1. Equality:     p = 02. Divisibility: d ∣ p3. Inequality:   p ≤ 04. Disequality:  p ≠ 0\n\nThe procedure builds a model incrementally, resolving conflicts through constraint generation.\nFor example, given a partial model {x := 1} and constraint 3 ∣ 3*y + x + 1:\n\n* The solve cannot extend the model to y because 3 ∣ 3*y + 2 is unsatisfiable.* Thus, it resolves the conflict by generating the implied constraint 3 ∣ x + 1.* The new constraint forces the solver to find a new assignment for x.\n\nWhen assigning a variable y, the solver considers:\n\n* The best upper and lower bounds (inequalities).* A divisibility constraint.* All disequality constraints where y is the maximal variable.\n\nThe Cooper-Left and Cooper-Right rules handle the combination of inequalities and divisibility.\nFor unsatisfiable disequalities p ≠ 0, the solver generates the case split: p + 1 ≤ 0 ∨ -p + 1 ≤ 0.\n\nThe following examples demonstrate goals that can be decide by cutsat.\n\n-- The left-hand-side is a multiple of 2.\nexample {x y : Int} : 2 * x + 4 * y ≠ 5 := by\n  grind\n\n-- Mixing equalities and inequalities.\nexample {x y : Int} : 2 * x + 3 * y = 0 → 1 ≤ x → y < 1 := by\n  grind\n\n-- Linear divisibility constraints.\nexample (a b : Int) : 2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2*a := by\n  grind\n\n\nYou can disable this solver using the option  grind -cutsat.\n\nexample (a b : Int) : 2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2*a := by\n  grind -cutsat\n\n\nThe solver is complete for linear integer arithmetic.\nThe following example has a rational solution, but does not have integer ones.\n\n-- The following example has rational solutions, but no integer one.\nexample {x y : Int}\n    : 27 ≤ 13*x + 11*y → 13*x + 11*y ≤ 30 →\n      -10 ≤ 9*x - 7*y → 9*x - 7*y > 4 := by\n  grind\n\n\nThe search can become vast with very few constraints, but cutsat was\nnot designed to perform massive case-analysis. You can reduce the search\nspace by instructing cutsat to accept rational solutions using the option\ngrind +qlia.\n\nexample {x y : Int}\n    : 27 ≤ 13*x + 11*y → 13*x + 11*y ≤ 30 →\n      -10 ≤ 9*x - 7*y → 9*x - 7*y > 4 := by\n  grind +qlia\n\n\nIn the example above, you can inspect the rational model constructed by cutsat\nby expanding the section \"Assignment satisfying linear constraints\" in the goal\ndiagnostics.\n\nThe solver currently does not have support for nonlinear constraints, and treats\nnonlinear terms such as x*x as variables. Thus, it fails to solve the following goal.\nYou can use the option trace.grind.cutsat.assert to trace all constraints processed\nby cutsat. Note that the term x*x is \"quoted\" in 「x * x」 + 1 ≤ 0 to indicate\nthat x*x is treated as a variable.\n\nexample (x : Int) : x*x ≥ 0 := by\n  set_option trace.grind.cutsat.assert true in\n  grind\n\n\nThe solver also implements model-based theory combination. This is a mechanism for\npropagating equalities back to the core module that might trigger new congruences.\n\nexample (f : Int → Int) (x y : Int)\n    : f x = 0 → 0 ≤ y → y ≤ 1 → y ≠ 1 →\n      f (x + y) = 0 := by\n  grind\n\n\nIn the example above, the linear inequalities and disequalities imply y = 0,\nand consequently x = x + y, and f x = f (x + y) by congruence.\nModel-based theory combination increases the size of the search space, and you\ncan disable it using the option grind -mbtc\n\nexample (f : Int → Int) (x y : Int)\n    : f x = 0 → 0 ≤ y → y ≤ 1 → y ≠ 1 →\n      f (x + y) = 0 := by\n  grind -mbtc\n\n\nThe cutsat solver can also process linear constraints containing natural numbers.\nIt converts them into integer constraints by using Int.ofNat.\n\nexample (x y z : Nat) : x < y + z → y + 1 < z → z + x < 3*z := by\n  grind\n\n\nThe solver also supports linear division and modulo operations.\n\nexample (x y : Int) : x = y / 2 → y % 2 = 0 → y - 2*x = 0 := by\n  grind\n\n\nThe cutsat solver normalizes commutative (semi)ring expressions, so can solve goals like\n\nexample (a b : Nat) (h₁ : a + 1 ≠ a * b * a) (h₂ : a * a * b ≤ a + 1) : b * a^2 < a + 1 := by\n  grind\n\n\nThere is an extensible mechanism via the Lean.Grind.ToInt typeclass to tell cutsat that a type embeds in the integers.\nUsing this, we can solve goals such as:\n\nexample (a b c : Fin 11) : a ≤ 2 → b ≤ 3 → c = a + b → c ≤ 5 := by\n  grind\n\nexample (a : Fin 2) : a ≠ 0 → a ≠ 1 → False := by\n  grind\n\nexample (a b c : UInt64) : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n\n\nPlanned future features: improved constraint propagation.\n\n"},"/Notations-and-Macros/Notations/#operators-and-notations":{"id":"/Notations-and-Macros/Notations/#operators-and-notations","header":"20.3.1. Operators and Notations","context":"Lean Reference\u0009Notations and Macros\u0009Notations","contents":"Internally, operator declarations are translated into notation declarations.\nTerm notation items are inserted where the operator would expect arguments, and in the corresponding positions in the expansion.\nFor prefix and postfix operators, the notation's precedence as well as the precedences of its term items is the operator's declared precedence.\nFor non-associative infix operators, the notation's precedence is the declared precedence, but both arguments are parsed at a precedence level that is one higher, which prevents successive uses of the notation without parentheses.\nAssociative infix operators use the operator's precedence for the notation and for one argument, while a precedence that is one level higher is used for the other argument; this prevents successive applications in one direction only.\nLeft-associative operators use the higher precedence for their right argument, while right-associative operators use the higher precedence for their left argument.\n\n\n"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-from-Mutable-References":{"id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--Varieties-of-Monads--State--State-Monads-from-Mutable-References","header":"14.5.4.4. State Monads from Mutable References","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009Varieties of Monads\u0009State","contents":"\n\nThe monad StateRefT σ m is a specialized state monad transformer that can be used when m is a monad to which ST computations can be lifted.\nIt implements the operations of MonadState using an ST.Ref, rather than pure functions.\nThis ensures that mutation is actually used at run time.\n\nST and EST require a phantom type parameter that's used together with runST's polymorphic function argument to encapsulate mutability.\nRather than require this as a parameter to the transformer, an auxiliary type class STWorld is used to propagate it directly from m.\n\nThe transformer itself is defined as a syntax extension and an elaborator, rather than an ordinary function.\nThis is because STWorld has no methods: it exists only to propagate information from the inner monad to the transformed monad.\nNonetheless, its instances are terms; keeping them around could lead to unnecessarily large types.\n\nAn auxiliary class used to infer the “state” of EST and ST monads.\n\nStateRefTThe syntax for StateRefT σ m accepts two arguments:Its elaborator synthesizes an instance of STWorld ω m to ensure that m supports mutable references.\nHaving discovered the value of ω, it then produces the term StateRefT' ω σ m, discarding the synthesized instance.\n\nA state monad that uses an actual mutable reference cell (i.e. an ST.Ref ω σ).The macro StateRefT σ m α infers ω from m. It should normally be used instead.\n\nRetrieves the current value of the monad's mutable state.This increments the reference count of the state, which may inhibit in-place updates.\n\nReplaces the mutable state with a new value.\n\nApplies a function to the current state that both computes a new state and a value. The new state\nreplaces the current state, and the value is returned.It is equivalent to a get followed by a set. However, using modifyGet may lead to higher\nperformance because it doesn't add a new reference to the state value. Additional references can\ninhibit in-place updates of data.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value paired with the final state.The monad m must support ST effects in order to create and mutate reference cells.\n\nExecutes an action from a monad with added state in the underlying monad m. Given an initial\nstate, it returns a value, discarding the final state.The monad m must support ST effects in order to create and mutate reference cells.\n\nRuns an action from the underlying monad in the monad with state. The state is not modified.This function is typically implicitly accessed via a MonadLiftT instance as part of automatic\nlifting.\n\n"}});