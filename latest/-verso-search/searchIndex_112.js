window.docContents[112].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-inductive-elim","header":"13.5.13.2. Elimination","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference\u0009Inductive Types","contents":"Elimination tactics use recursors and the automatically-derived casesOn helper to implement induction and case splitting.\nThe subgoals that result from these tactics are determined by the types of the minor premises of the eliminators, and using different eliminators with the using option results in different subgoals.\n\nChoosing EliminatorsWhen attempting to prove that ∀(i : Fin (n + 1)), 0 + i = i, after introducing the hypotheses the tactic induction i results in:case mk\nn val✝ : Nat\nisLt✝ : val✝ < n + 1\n⊢ 0 + ⟨val✝, isLt✝⟩ = ⟨val✝, isLt✝⟩\nThis is because Fin is a structure with a single non-recursive constructor.\nIts recursor has a single minor premise for this constructor:Fin.rec.{u} {n : Nat} {motive : Fin n → Sort u}\n  (mk : (val : Nat) →\n    (isLt : val < n) →\n    motive ⟨val, isLt⟩)\n  (t : Fin n) : motive t\nUsing the tactic induction i using Fin.induction instead results in:case zero\nn : Nat\n⊢ 0 + 0 = 0\n\ncase succ\nn : Nat\ni✝ : Fin n\na✝ : 0 + i✝.castSucc = i✝.castSucc\n⊢ 0 + i✝.succ = i✝.succ\nFin.induction is an alternative eliminator that implements induction on the underlying Nat:Fin.induction.{u} {n : Nat}\n  {motive : Fin (n + 1) → Sort u}\n  (zero : motive 0)\n  (succ : (i : Fin n) →\n    motive i.castSucc →\n    motive i.succ)\n  (i : Fin (n + 1)) : motive i\n\n\nCustom eliminators can be registered using the induction_eliminator and cases_eliminator attributes.\nThe eliminator is registered for its explicit targets (i.e. those that are explicit, rather than implicit, parameters to the eliminator function) and will be applied when induction or cases is used on targets of those types.\nWhen present, custom eliminators take precedence over recursors.\nSetting tactic.customEliminators to false disables the use of custom eliminators.\n\nCustom EliminatorsThe induction_eliminator attribute registers an eliminator for use by the induction tactic.The induction_eliminator attribute registers an eliminator for use by the cases tactic.\n\nAssuming x is a variable in the local context with an inductive type,\ncases x splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on x,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\ncases detects unreachable cases and closes them automatically.For example, given n : Nat and a goal with a hypothesis h : P n and target Q n,\ncases n produces one goal with hypothesis h : P 0 and target Q 0,\nand one goal with hypothesis h : P (Nat.succ a) and target Q (Nat.succ a).\nHere the name a is chosen automatically and is not accessible.\nYou can use with to provide the variables names for each constructor.* cases e, where e is an expression instead of a variable, generalizes e in the goal,\nand then cases on the resulting variable.* Given as : List α, cases as with | nil => tac₁ | cons a as' => tac₂,\nuses tactic tac₁ for the nil case, and tac₂ for the cons case,\nand a and as' are used as names for the new variables introduced.* cases h : e, where e is a variable or an expression,\nperforms cases on e as above, but also adds a hypothesis h : e = ... to each hypothesis,\nwhere ... is the constructor instance for that particular case.\n\nrcases is a tactic that will perform cases recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like h1 : a ∧ b ∧ c ∨ d or\nh2 : ∃ x y, trans_rel R x y. Usual usage might be rcases h1 with ⟨ha, hb, hc⟩ | hd or\nrcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩ for these examples.Each element of an rcases pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of rcases and represent individual elements destructured from\nthe input expression). An rcases pattern has the following grammar:* A name like x, which names the active hypothesis as x.* A blank _, which does nothing (letting the automatic naming system used by cases name the\nhypothesis).* A hyphen -, which clears the active hypothesis and any dependents.* The keyword rfl, which expects the hypothesis to be h : a = b, and calls subst on the\nhypothesis (which has the effect of replacing b with a everywhere or vice versa).* A type ascription p : ty, which sets the type of the hypothesis to ty and then matches it\nagainst p. (Of course, ty must unify with the actual type of h for this to work.)* A tuple pattern ⟨p1, p2, p3⟩, which matches a constructor with many arguments, or a series\nof nested conjunctions or existentials. For example if the active hypothesis is a ∧ b ∧ c,\nthen the conjunction will be destructured, and p1 will be matched against a, p2 against b\nand so on.* A @ before a tuple pattern as in @⟨p1, p2, p3⟩ will bind all arguments in the constructor,\nwhile leaving the @ off will only use the patterns on the explicit arguments.* An alternation pattern p1 | p2 | p3, which matches an inductive type with multiple constructors,\nor a nested disjunction like a ∨ b ∨ c.A pattern like ⟨a, b, c⟩ | ⟨d, e⟩ will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as a,b,c and the\nfirst two of the second constructor d,e. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as ⟨⟨a⟩, b | c⟩ | d then these will cause more case splits as necessary.\nIf there are too many arguments, such as ⟨a, b, c⟩ for splitting on\n∃ x, ∃ y, p x, then it will be treated as ⟨a, ⟨b, c⟩⟩, splitting the last\nparameter as necessary.rcases also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor quot.mk.rcases h : e with PAT will do the same as rcases e with PAT with the exception that an\nassumption h : e = PAT will be added to the context.\n\nThe fun_cases tactic is a convenience wrapper of the cases tactic when using a functional\ncases principle.The tactic invocationfun_cases f x ... y ...`\nis equivalent tocases y, ... using f.fun_cases_unfolding x ...\nwhere the arguments of f are used as arguments to f.fun_cases_unfolding or targets of the case\nanalysis, as appropriate.The formfun_cases f\n(with no arguments to f) searches the goal for an unique eligible application of f, and uses\nthese arguments. An application of f is eligible if it is saturated and the arguments that will\nbecome targets are free variables.The form fun_cases f x y with | case1 => tac₁ | case2 x' ih => tac₂ works like with cases.Under set_option tactic.fun_induction.unfolding true (the default), fun_induction uses the\nf.fun_cases_unfolding theorem, which will try to automatically unfold the call to f in\nthe goal. With set_option tactic.fun_induction.unfolding false, it uses f.fun_cases instead.\n\nAssuming x is a variable in the local context with an inductive type,\ninduction x applies induction on x to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on x,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.For example, given n : Nat and a goal with a hypothesis h : P n and target Q n,\ninduction n produces one goal with hypothesis h : P 0 and target Q 0,\nand one goal with hypotheses h : P (Nat.succ a) and ih₁ : P a → Q a and target Q (Nat.succ a).\nHere the names a and ih₁ are chosen automatically and are not accessible.\nYou can use with to provide the variables names for each constructor.* induction e, where e is an expression instead of a variable,\ngeneralizes e in the goal, and then performs induction on the resulting variable.* induction e using r allows the user to specify the principle of induction that should be used.\nHere r should be a term whose result type must be of the form C t,\nwhere C is a bound variable and t is a (possibly empty) sequence of bound variables* induction e generalizing z₁ ... zₙ, where z₁ ... zₙ are variables in the local context,\ngeneralizes over z₁ ... zₙ before applying the induction but then introduces them in each goal.\nIn other words, the net effect is that each inductive hypothesis is generalized.* Given x : Nat, induction x with | zero => tac₁ | succ x' ih => tac₂\nuses tactic tac₁ for the zero case, and tac₂ for the succ case.\n\nThe fun_induction tactic is a convenience wrapper around the induction tactic to use the the\nfunctional induction principle.The tactic invocationfun_induction f x₁ ... xₙ y₁ ... yₘ\nwhere f is a function defined by non-mutual structural or well-founded recursion, is equivalent toinduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\nwhere the arguments of f are used as arguments to f.induct_unfolding or targets of the\ninduction, as appropriate.The formfun_induction f\n(with no arguments to f) searches the goal for an unique eligible application of f, and uses\nthese arguments. An application of f is eligible if it is saturated and the arguments that will\nbecome targets are free variables.The forms fun_induction f x y generalizing z₁ ... zₙ and\nfun_induction f x y with | case1 => tac₁ | case2 x' ih => tac₂ work like with induction.Under set_option tactic.fun_induction.unfolding true (the default), fun_induction uses the\nf.induct_unfolding induction principle, which will try to automatically unfold the call to f in\nthe goal. With set_option tactic.fun_induction.unfolding false, it uses f.induct instead.\n\nThe tactic nofun is shorthand for exact nofun: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n\nThe tactic nomatch h is shorthand for exact nomatch h.\n\n"},"/Tactic-Proofs/Tactic-Reference/#tactic-reducibility":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-reducibility","header":"13.5.17. Controlling Reduction","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"with_reducible tacs executes tacs using the reducible transparency setting.\nIn this setting only definitions tagged as [reducible] are unfolded.\n\nwith_reducible_and_instances tacs executes tacs using the .instances transparency setting.\nIn this setting only definitions tagged as [reducible] or type class instances are unfolded.\n\nwith_unfolding_all tacs executes tacs using the .all transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n\n"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-dir":{"id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-dir","header":"22.2.2. Toolchain Locations","context":"Lean Reference\u0009Build Tools\u0009Elan","contents":"By default, Elan stores installed toolchains in .elan/toolchains in the user's home directory, and its proxies are kept in .elan/bin, which is added to the path when Elan is installed.\nThe environment variable ELAN_HOME can be used to change this location.\nIt should be set both prior to installing Elan and in all sessions that use Lean in order to ensure that Elan's files are found.\n\n"},"/Basic-Types/Tuples/#pairs":{"id":"/Basic-Types/Tuples/#pairs","header":"19.13.1. Ordered Pairs","context":"Lean Reference\u0009Basic Types\u0009Tuples","contents":"\n\nThe type α × β, which is a notation for Prod α β, contains ordered pairs in which the first item is an α and the second is a β.\nThese pairs are written in parentheses, separated by commas.\nLarger tuples are represented as nested tuples, so α × β × γ is equivalent to α × (β × γ) and (x, y, z) is equivalent to (x, (y, z)).\n\nProduct TypesThe product Prod α β is written α × β.\n\nPairs\n\nThe product type, usually written α × β. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an α and the second element is a\nβ.Products nest to the right, so (x, y, z) : α × β × γ is equivalent to (x, (y, z)) : α × (β × γ).Conventions for notations in identifiers:* The recommended spelling of × in identifiers is Prod.Constructs a pair. This is usually written (x, y) instead of Prod.mk x y.Conventions for notations in identifiers:* The recommended spelling of (a, b) in identifiers is mk.The first element of a pair.The second element of a pair.\n\n\n\nThere are also the variants α ×' β (which is notation for PProd α β) and MProd, which differ with respect to universe levels: like PSum, PProd allows either α or β to be a proposition, while MProd requires that both be types at the same universe level.\nGenerally speaking, PProd is primarily used in the implementation of proof automation and the elaborator, as it tends to give rise to universe level unification problems that can't be solved.\nMProd, on the other hand, can simplify universe level issues in certain advanced use cases.\n\n\n\nProducts of Arbitrary SortsThe product PProd α β, in which both types could be propositions, is written α × β.\n\nA product type in which the types may be propositions, usually written α ×' β.This type is primarily used internally and as an implementation detail of proof automation. It is\nrarely useful in hand-written code.Conventions for notations in identifiers:* The recommended spelling of ×' in identifiers is PProd.The first element of a pair.The second element of a pair.\n\nA product type in which both α and β are in the same universe.It is called MProd is because it is the universe-monomorphic product type.The first element of a pair.The second element of a pair.\n\n\n\n"}});