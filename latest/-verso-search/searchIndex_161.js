window.docContents[161].resolve({"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--The-problem":{"id":"/The--grind--tactic/Bigger-Examples/#The-Lean-Language-Reference--The--grind--tactic--Bigger-Examples--if-then-else-normalization--The-problem","header":"17.12.2.1. The problem","context":"Lean Reference\u0009The  grind  tactic\u0009Bigger Examples\u0009if-then-else normalization","contents":"Here is Rustan Leino's original description of the problem, as posted by Leonardo de Moura on the Lean Zulip:\n\nThe data structure is an expression with Boolean literals, variables, and if-then-else expressions.\n\n\n\nThe goal is to normalize such expressions into a form where:\n\na) No nested ifs: the condition part of an if-expression is not itself an if-expression\n\nb) No constant tests: the condition part of an if-expression is not a constant\n\nc) No redundant ifs: the then and else branches of an if are not the same\n\nd) Each variable is evaluated at most once: the free variables of the condition are disjoint from those in the then branch, and also disjoint from those in the else branch.\n\n\n\nOne should show that a normalization function produces an expression satisfying these four conditions, and one should also prove that the normalization function preserves the meaning of the given expression.\n\n"}});