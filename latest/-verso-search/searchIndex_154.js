window.docContents[154].resolve({"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable--Examples":{"id":"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable--Examples","header":"Examples","context":"Lean Reference\u0009Error Explanations\u0009lean.dependsOnNoncomputable","contents":"Necessarily noncomputable function not appropriately markedaxiom transform : Nat → Nat\n\ndef transformIfZero : Nat → Nat\n  | 0 => transform 0\n  | n => n\naxiom 'transform' not supported by code generator; consider marking definition as 'noncomputable'\naxiom transform : Nat → Nat\n\nnoncomputable def transformIfZero : Nat → Nat\n  | 0 => transform 0\n  | n => n\nIn this example, transformIfZero depends on the axiom transform. Because transform is an\naxiom, it does not contain any executable code; although the value transform 0 has type Nat,\nthere is no way to compute its value. Thus, transformIfZero must be marked noncomputable because\nits execution would depend on this axiom.\n\nNoncomputable dependency can be made computablenoncomputable def getOrDefault [Nonempty α] : Option α → α\n  | some x => x\n  | none => Classical.ofNonempty\n\ndef endsOrDefault (ns : List Nat) : Nat × Nat :=\n  let head := getOrDefault ns.head?\n  let tail := getOrDefault ns.getLast?\n  (head, tail)\nfailed to compile definition, consider marking it as 'noncomputable' because it depends on 'getOrDefault', which is 'noncomputable'\ndef getOrDefault [Inhabited α] : Option α → α\n  | some x => x\n  | none => default\n\ndef endsOrDefault (ns : List Nat) : Nat × Nat :=\n  let head := getOrDefault ns.head?\n  let tail := getOrDefault ns.getLast?\n  (head, tail)\nThe original definition of getOrDefault is noncomputable due to its use of Classical.choice.\nUnlike in the preceding example, however, it is possible to implement a similar but computable\nversion of getOrDefault (using the Inhabited type class), allowing endsOrDefault to be\ncomputable. (The differences between Inhabited and Nonempty are described in the documentation\nof inhabited types in the manual section on Basic Classes.)\n\nNoncomputable instance in namespaceopen Classical in\n/--\nReturns `y` if it is in the image of `f`,\nor an element of the image of `f` otherwise.\n-/\ndef fromImage (f : Nat → Nat) (y : Nat) :=\n  if ∃ x, f x = y then\n    y\n  else\n    f 0\nfailed to compile definition, consider marking it as 'noncomputable' because it depends on 'Classical.propDecidable', which is 'noncomputable'\nopen Classical in\n/--\nReturns `y` if it is in the image of `f`,\nor an element of the image of `f` otherwise.\n-/\nnoncomputable def fromImage (f : Nat → Nat) (y : Nat) :=\n  if ∃ x, f x = y then\n    y\n  else\n    f 0\nThe Classical namespace contains Decidable instances that are not computable. These are a common\nsource of noncomputable dependencies that do not explicitly appear in the source code of a\ndefinition. In the above example, for instance, a Decidable instance for the proposition\n∃ x, f x = y is synthesized using a Classical decidability instance; therefore, fromImage must\nbe marked noncomputable.\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Extensional-Hash-Sets--Queries","header":"19.17.7.3. Queries","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Extensional Hash Sets","contents":"Returns true if the given key is present in the set. There is also a Prop-valued version of\nthis: a ∈ m is equivalent to m.contains a = true.Observe that this is different behavior than for lists: for lists, ∈ uses = and contains use\n== for comparisons, while for hash sets, both use ==.\n\nRetrieves the key from the set that matches a. Ensures that such a key exists by requiring a proof\nof a ∈ m. The result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise panics.\nIf no panic occurs the result is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise none.\nThe result in the some case is guaranteed to be pointer equal to the key in the set.\n\nChecks if given key is contained and returns the key if it is, otherwise fallback.\nIf they key is contained the result is guaranteed to be pointer equal to the key in the set.\n\n"},"/Attributes/#scoped-attributes":{"id":"/Attributes/#scoped-attributes","header":"9.3. Scoped Attributes","context":"Lean Reference\u0009Attributes","contents":"Many attributes can be applied in a particular scope.\nThis determines whether the attribute's effect is visible only in the current section scope, in namespaces that open the current namespace, or everywhere.\nThese scope indications are also used to control syntax extensions and type class instances.\nEach attribute is responsible for defining precisely what these terms mean for its particular effect.\n\nAttribute ScopesGlobally-scoped declarations (the default) are in effect whenever the module in which they're established is transitively imported.\nThey are indicated by the absence of another scope modifier.Locally-scoped declarations are in effect only for the extent of the section scope in which they are established.Scoped declarations are in effect whenever the namespace in which they are established is opened.\n\n"}});