window.docContents[69].resolve({"/The-Type-System/Inductive-Types/#mutual-inductive-types-dependencies":{"id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-dependencies","header":"4.4.5.1.1. Mutual Dependencies","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","contents":"Each type constructor's signature must be able to be elaborated without reference to the other inductive types in the mutual group.\nIn other words, the inductive types in the mutual group may not take each other as arguments.\nThe constructors of each inductive type may mention the other type constructors in the group in their parameter types, with restrictions that are a generalization of those for recursive occurrences in non-mutual inductive types.\n\nMutual inductive type constructors may not mention each otherThese inductive types are not accepted by Lean:mutual\n  inductive FreshList (α : Type) (r : α → α → Prop) : Type where\n    | nil : FreshList α r\n    | cons (x : α) (xs : FreshList α r) (fresh : Fresh r x xs)\n  inductive Fresh\n      (r : α → FreshList α → Prop) :\n      α → FreshList α r → Prop where\n    | nil : Fresh r x .nil\n    | cons : r x y → (f : Fresh r x ys) → Fresh r x (.cons y ys f)\nend\nThe type constructors may not refer to the other type constructors in the mutual group, so FreshList is not in scope in the type constructor of Fresh:unknown identifier 'FreshList'\n\n\n"},"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--Random-Generators":{"id":"/IO/Random-Numbers/#The-Lean-Language-Reference--IO--Random-Numbers--Random-Generators","header":"15.10.1. Random Generators","context":"Lean Reference\u0009IO\u0009Random Numbers","contents":"Interface for random number generators.range returns the range of values returned by\nthe generator.next operation returns a natural number that is uniformly distributed\nthe range returned by range (including both end points),\nand a new generator.The 'split' operation allows one to obtain two distinct random number\ngenerators. This is very useful in functional programs (for example, when\npassing a random number generator down to recursive calls).\n\n\"Standard\" random number generator.\n\nThe range of values returned by StdGen\n\nThe next value from a StdGen, paired with an updated generator state.\n\nSplits a StdGen into two separate states.\n\nReturns a standard number generator.\n\n"},"/Basic-Types/Arrays/#Array":{"id":"/Basic-Types/Arrays/#Array","header":"19.16. Arrays","context":"Lean Reference\u0009Basic Types","contents":"The Array type represents sequences of elements, addressable by their position in the sequence.\nArrays are specially supported by Lean:\n\n* They have a logical model that specifies their behavior in terms of lists of elements, which specifies the meaning of each operation on arrays.* They have an optimized run-time representation in compiled code as dynamic arrays, and the Lean runtime specially optimizes array operations.* There is array literal syntax for writing arrays.\n\nArrays can be vastly more efficient than lists or other sequences in compiled code.\nIn part, this is because they offer good locality: because all the elements of the sequence are next to each other in memory, the processor's caches can be used efficiently.\nEven more importantly, if there is only a single reference to an array, operations that might otherwise copy or allocate a data structure can be implemented via mutation.\nLean code that uses an array in such a way that there's only ever one unique reference (that is, uses it linearly) avoids the performance overhead of persistent data structures while still being as convenient to write, read, and prove things about as ordinary pure functional programs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});