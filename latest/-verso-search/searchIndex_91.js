window.docContents[91].resolve({"/The-Module-System/Visibility/#The-Lean-Language-Reference--The-Module-System--Visibility":{"id":"/The-Module-System/Visibility/#The-Lean-Language-Reference--The-Module-System--Visibility","header":"Visibility","context":"Lean Reference\u0009The Module System","contents":"The main distinction the module system introduces is between the public scope that contains all information visible to other modules via import and the private scope that is not imported by default.\nBoth declarations and imports themselves are scoped in this way.\n\nThe default scope is private.\nThe new modifier public before a declaration or import puts it into the public scope instead.\nNo information from the private scope can be used in the public scope to ensure information in the latter still makes sense when only it is imported into other modules.\n\n\n\nmodule\n\ndef priv : Nat := 0\n\npublic abbrev pub : Nat := priv  -- error: unknown identifier `priv`\n\n\npublic section can be used to switch the default scope for declarations, with private locally negating it.\nThis is mostly intended to ease porting while avoiding merge conflicts.\n\nMarking a declaration as public at minimum makes its \"signature\", i.e. its name and type, visible.\nSome specific declarations/terms may still put other parts in the private scope as follows:\n\n* by used in the public scope to prove a proposition puts the resulting proof in the private scope (by wrapping it in a public helper theorem).* def puts its body in the private scope by default. The defined constant cannot be unfolded when used in the public scope.\nThis can be changed with the @[expose] attribute.\n@[expose] section can be used to apply the attribute to all defs in the section and can locally be negated by @[no_expose].* theorem and opaque never expose their body.\nConsider using @[expose] def instead if exposition is absolutely necessary.* abbrev and instance always expose their body.\nFor instance, individual field values can be marked private, which can be useful for programming purposes.\nFor proof fields, by already does the trick.\n\nmodule\n\ndef myInternalHelper (x : Nat) : String := ...\n\npublic instance : ToString Nat where\n  toString x := private myInternalHelper x\n\n\n\n\n"},"/The--grind--tactic/What--grind--is--not-___/#The-Lean-Language-Reference--The--grind--tactic--What--grind--is--not-___":{"id":"/The--grind--tactic/What--grind--is--not-___/#The-Lean-Language-Reference--The--grind--tactic--What--grind--is--not-___","header":"17.3. What  grind  is  not .","context":"Lean Reference\u0009The  grind  tactic","contents":"grind is not designed for goals whose search space explodes combinatorially—think large‑n pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards, or a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require thousands (or millions) of case‑splits that overwhelm grind’s branching search.\n\n* Bit‑level or pure Boolean combinatorial problems → use bv_decide.\n  The bv_decide tactic calls a state‑of‑the‑art SAT solver (e.g. CaDiCaL or Kissat) and then returns a compact, machine‑checkable certificate.  All heavy search happens outside Lean; the certificate is replayed and verified inside Lean, so trust is preserved (verification time scales with certificate size).* Full SMT problems that need substantial case analysis across multiple theories (arrays, bit‑vectors, rich arithmetic, quantifiers, …) → use the forthcoming lean‑smt tactic—a tight Lean front‑end for CVC5 that replays unsat cores or models inside Lean.\n\n"},"/The--grind--tactic/E___matching/#The-Lean-Language-Reference--The--grind--tactic--E___matching":{"id":"/The--grind--tactic/E___matching/#The-Lean-Language-Reference--The--grind--tactic--E___matching","header":"17.8. E‑matching","context":"Lean Reference\u0009The  grind  tactic","contents":"E-matching is a mechanism used by grind to instantiate theorems efficiently.\nIt is especially effective when combined with congruence closure, enabling\ngrind to discover non-obvious consequences of equalities and annotated theorems\nautomatically.\n\nConsider the following functions and theorems:\n\ndef f (a : Nat) : Nat :=\n  a + 1\n\ndef g (a : Nat) : Nat :=\n  a - 1\n\n@[grind =]\ntheorem gf (x : Nat) : g (f x) = x := by\n  simp [f, g]\n\n\nThe theorem gf asserts that g (f x) = x for all natural numbers x.\nThe attribute [grind =] instructs grind to use the left-hand side of the equation,\ng (f x), as a pattern for heuristic instantiation via E-matching.\nSuppose we now have a goal involving:\n\nexample {a b} (h : f b = a) : g a = b := by\n  grind\n\n\nAlthough g a is not an instance of the pattern g (f x),\nit becomes one modulo the equation f b = a.\nBy substituting a with f b in g a, we obtain the term g (f b),\nwhich matches the pattern g (f x) with the assignment x := b.\nThus, the theorem gf is instantiated with x := b,\nand the new equality g (f b) = b is asserted.\ngrind then uses congruence closure to derive the implied equality\ng a = g (f b) and completes the proof.\n\nThe pattern used to instantiate theorems affects the effectiveness of grind.\nFor example, the pattern g (f x) is too restrictive in the following case:\nthe theorem gf will not be instantiated because the goal does not even\ncontain the function symbol g.\n\nexample (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n\n\nYou can use the command grind_pattern to manually select a pattern for a given theorem.\nIn the following example, we instruct grind to use f x as the pattern,\nallowing it to solve the goal automatically:\n\ngrind_pattern gf => f x\n\nexample {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n\n\nYou can enable the option trace.grind.ematch.instance to make grind print a\ntrace message for each theorem instance it generates.\n\n/--\ntrace: [grind.ematch.instance] gf: g (f c) = c\n[grind.ematch.instance] gf: g (f b) = b\n-/\n#guard_msgs (trace) in\nexample (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  set_option trace.grind.ematch.instance true in\n  grind\n\n\nYou can also specify a multi-pattern to control when grind should instantiate a theorem.\nA multi-pattern requires that all specified patterns are matched in the current context\nbefore the theorem is instantiated. This is useful for lemmas such as transitivity rules,\nwhere multiple premises must be simultaneously present for the rule to apply.\nThe following example demonstrates this feature using a transitivity axiom for a binary relation R:\n\nopaque R : Int → Int → Prop\naxiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\ngrind_pattern Rtrans => R x y, R y z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n\n\nBy specifying the multi-pattern R x y, R y z, we instruct grind to\ninstantiate Rtrans only when both R x y and R y z are available in the context.\nIn the example, grind applies Rtrans to derive R a c from R a b and R b c,\nand can then repeat the same reasoning to deduce R a d from R a c and R c d.\n\nInstead of using grind_pattern to explicitly specify a pattern,\nyou can use the @[grind] attribute or one of its variants, which will use a heuristic to generate a (multi-)pattern.\nThe @[grind?] attribute displays an info message showing the pattern which was selected—this is very helpful for debugging!\n\n* @[grind →] will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).\n  In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable (i.e. has a constant as its head) subexpression which \"covers\" (i.e. fixes the value of) an argument which was not previously covered, it will add that subexpression as a pattern, until all arguments have been covered. This rule is described in more detail below.* @[grind ←] will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).\n  This may fail if not all the arguments to the theorem appear in the conclusion.* @[grind] will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage, stopping when all arguments are covered.* @[grind =] checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.\n  This may fail if not all of the arguments appear in the left-hand-side.* @[grind =_] is like @[grind =], but using the right-hand-side of the equality.* @[grind _=_] acts like a macro which expands to @[grind =, grind =_] (i.e. it will add two multipatterns, allowing the equality theorem to trigger in either direction).\n\nAlthough it is tempting to just use @[grind] by default, we recommend that when one of the other forms achieves the desired effect, you use those.\nIn every case, it is worthwhile to verify the chosen pattern using @[grind?] (which accepts all of these modifiers).\n\nThere are also three less commonly used modifiers:\n\n* @[grind =>] traverses all the hypotheses left-to-right and then the conclusion.* @[grind <=] traverses the conclusion and then all hypotheses right-to-left.* @[grind ←=] is unlike the others, and it used specifically for backwards reasoning on equality. As an example, suppose we have a theoremtheorem inv_eq [One α] [Mul α] [Inv α] {a b : α} (w : a * b = 1) : a⁻¹ = b := sorry\nAdding @[grind ←=] will cause this theorem to be instantiated whenever we are trying to prove a⁻¹ = b, i.e. whenever we have the disequality a⁻¹ ≠ b (recall grind proves goals by contradiction).\n  Without special support via ←= this instantiation would be not possible as grind does not consider the = symbol while generating patterns.\n\nThe rule for selecting patterns from subexpressions of the hypotheses and conclusion as described above is subtle, so we'll give some examples.\n\naxiom p : Nat → Nat\naxiom q : Nat → Nat\n\n/-- info: h₁: [q #1] -/\n#guard_msgs (info) in\n@[grind? →] theorem h₁ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\n\n\nFirst, to understand the output we need to recall that the #n appearing in patterns are arguments of the theorem, numbered as de-Bruijn variables, i.e. in reverse order (so #0 would be w : p (q x) = 7, while #1 is the implicit argument x).\n\nWhy was q #1 selected when we use @[grind →]? The attribute @[grind →] instructed grind to find patterns by traversing the hypotheses from left-to-right.\nIn this case, there's only the one hypothesis p (q x) = 7. The heuristic described above says that grind will search for a minimal indexable subexpression which covers a previously uncovered argument.\nThere's just one uncovered argument, x, so we're looking for a minimal expression containing that.\nWe can't take the whole p (q x) = 7 because grind will not index on equality. The right-hand-side 7 is not helpful, because it doesn't determine the value of x.\nWe don't take p (q x) because it is not minimal: it has q x inside of it, which is indexable (its head is the constant q),\nand it determines the value of x. The expression q x itself is minimal, because x is not indexable. Thus grind selects q x as the pattern.\n\nLet's see some more examples:\n\n/-- info: h₂: [p (#1 + 1)] -/\n#guard_msgs (info) in\n@[grind? ←] theorem h₂ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\n\n/--\ninfo: h₃: [p (#1 + 1)]\n---\ninfo: h₃: [q #1]\n-/\n#guard_msgs (info) in\n@[grind? _=_] theorem h₃ (w : 7 = p (q x)) : p (x + 1) = q x := sorry\n\n/-- info: h₄: [p (#2 + 2), q #1] -/\n#guard_msgs (info) in\n@[grind?] theorem h₄ (w : p x = q y) : p (x + 2) = 7 := sorry\n\n/--\nerror: `@[grind ←] theorem h₅` failed to\nfind patterns in the theorem's conclusion,\nconsider using different options or the `grind_pattern` command\n-/\n#guard_msgs (error) in\n@[grind? ←] theorem h₅ (w : p x = q y) : p (x + 2) = 7 := sorry\n\n/-- info: h₆: [q (#3 + 2), p (#2 + 2)] -/\n#guard_msgs (info) in\n@[grind? =>] theorem h₆ (_ : q (y + 2) = q y) (_ : q (y + 1) = q y) : p (x + 2) = 7 := sorry\n\n\nIf you're planning to do substantial annotation work, you should study these examples and verify that\nthey follow the rules described above.\n\nE-matching can generate too many theorem instances. Some patterns may even generate an unbounded\nnumber of instances. For example, consider the pattern s x in the following example.\n\ndef s (x : Nat) := 0\n\n@[grind =] theorem s_eq (x : Nat) : s x = s (x + 1) :=\n  rfl\n\nexample : s 0 > 0 := by\n  grind\n\n\nIn the example above, grind instantiates s_eq with x := 0 which generates the term\ns 1 with is then used to instantiate s_eq with x := 1 which generates the term s 2\nand so on. The instantiation process is interrupted using the generation threshold.\nTerms occurring in the input goal have generation zero. When grind instantiates\na theorem using terms with generation ≤ n, the new generated terms have generation n+1.\nYou can set the maximum generation using the option grind (gen := <num>).\nYou can also control the number of E-matching rounds using the option grind (ematch := <num>).\nIn the following example, we prove that (iota 20).length > 10 by instantiating iota_succ\nand List.length_cons\n\ndef iota : Nat → List Nat\n  | 0 => []\n  | n+1 => n :: iota n\n\n@[grind =] theorem iota_succ : iota (n+1) = n :: iota n :=\n  rfl\n\nexample : (iota 20).length > 10 := by\n  grind (gen := 20) (ematch := 20)\n\n\nYou can set the option set_option diagnostics true to obtain the number of\ntheorem instances generated by grind per theorem. This is useful to detect\ntheorems that contain patterns that are triggering too many instances.\n\n\n\nset_option diagnostics true in\nexample : (iota 20).length > 10 := by\n  grind (gen := 20) (ematch := 20)\n\n\nBy default, grind uses automatically generated equations for match-expressions as E-matching theorems.\n\nexample (x y : Nat)\n    : x = y + 1 →\n      0 < match x with\n          | 0 => 0\n          | _+1 => 1 := by\n  grind\n\n\nYou can disable this feature by using grind -matchEqs\n\nexample (x y : Nat)\n    : x = y + 1 →\n      0 < match x with\n          | 0 => 0\n          | _+1 => 1 := by\n  grind -matchEqs\n\n\n\n\n"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-simp":{"id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-simp","header":"13.6.4.2. Simplification","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv\u0009Changing the Goal","contents":"simp [thm] performs simplification using thm and marked @[simp] lemmas.\nSee the simp tactic for more information.\n\ndsimp is the definitional simplifier in conv-mode. It differs from simp in that it only\napplies theorems that hold by reflexivity.Examples:example (a : Nat): (0 + 0) = a - a := by\n  conv =>\n    lhs\n    dsimp\n    rw [← Nat.sub_self a]\n\n\nsimp_match simplifies match expressions. For example,match [a, b] with\n| [] => 0\n| hd :: tl => hd\nsimplifies to a.\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Environment","header":"22.1.4.1. Accessing the Environment","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference","contents":"Monads that provide access to information about the current Lake environment (such as the locations of Lean, Lake, and other tools) have MonadLakeEnv instances.\nThis is true for all of the monads in the Lake API, including ScriptM.\n\nA monad equipped with a (read-only) detected environment for Lake.\n\nGets the current Lake environment.\n\nGet the LAKE_NO_CACHE/--no-cache Lake configuration.\n\nGet whether the LAKE_NO_CACHE/--no-cache Lake configuration is NOT set.\n\nGet the LAKE_PACKAGE_URL_MAP for the Lake environment. Empty if none.\n\nGet the name of Elan toolchain for the Lake environment. Empty if none.\n\n\n\n\n\n\n\n\n\n"}});