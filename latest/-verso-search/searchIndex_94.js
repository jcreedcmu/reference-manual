window.docContents[94].resolve({"/The-Type-System/Quotients/#quotient-funext":{"id":"/The-Type-System/Quotients/#quotient-funext","header":"4.5.6. Quotients and Function Extensionality","context":"Lean Reference\u0009Type System\u0009Quotients","contents":"Because Lean's definitional equality includes a computational reduction rule for Quot.lift, quotient types are used in the standard library to prove function extensionality, which would need to be an axiom otherwise.\nThis is done by first defining a type of functions quotiented by extensional equality, for which extensional equality holds by definition.variable {α : Sort u} {β : α → Sort v}\n\ndef extEq (f g : (x : α) → β x) : Prop :=\n  ∀ x, f x = g x\n\ndef ExtFun (α : Sort u) (β : α → Sort v) :=\n  Quot (@extEq α β)\nExtensional functions can be applied just like ordinary functions.\nApplication respects extensional equality by definition: if applying to functions gives equal results, then applying them gives equal results.def extApp\n    (f : ExtFun α β)\n    (x : α) :\n    β x :=\n  f.lift (· x) fun g g' h => by\n    exact h x\nTo show that two functions that are extensionally equal are in fact equal, it suffices to show that the functions that result from extensionally applying the corresponding extensional functions are equal.\nThis is becauseextApp (Quot.mk _ f)\nis definitionally equal tofun x => (Quot.mk extEq f).lift (· x) (fun _ _ h => h x)\nwhich is definitionally equal to fun x => f x, which is definitionally equal (by η-equivalence) to f.\nA propositional version of the computation rule for Quot.lift would not suffice, because the reducible expression occurs in the body of a function and rewriting by an equality in a function would already require function extensionality.From here, it is enough to show that the extensional versions of the two functions are equal.\nThis is true due to Quot.sound: the fact that they are in the quotient's equivalence relation is an assumption.\nThis proof is a much more explicit version of the one in the standard library:theorem funext'\n    {f g : (x : α) → β x}\n    (h : ∀ x, f x = g x) :\n    f = g := by\n  suffices extApp (Quot.mk _ f) = extApp (Quot.mk _ g) by\n    unfold extApp at this\n    dsimp at this\n    exact this\n  suffices Quot.mk extEq f = Quot.mk extEq g by\n    apply congrArg\n    exact this\n  apply Quot.sound\n  exact h\n\n\n"},"/Interacting-with-Lean/#hash-check":{"id":"/Interacting-with-Lean/#hash-check","header":"3.3. Checking Types","context":"Lean Reference\u0009Interacting with Lean","contents":"Checking Types#check can be used to elaborate a term and check its type.If the provided term is an identifier that is the name of a global constant, then #check prints its signature.\nOtherwise, the term is elaborated as a Lean term and its type is printed.\n\nElaboration of the term in #check does not require that the term is fully elaborated; it may contain metavariables.\nIf the term as written could have a type, elaboration succeeds.\nIf a required instance could never be synthesized, then elaboration fails; synthesis problems that are due to metavariables do not block elaboration.\n\n#check and Underdetermined TypesIn this example, the type of the list's elements is not determined, so the type contains a metavariable:#check fun x => [x]\nfun x => [x] : ?m.9 → List ?m.9\nIn this example, both the type of the terms being added and the result type of the addition are unknown, because HAdd allows terms of different types to be added.\nBehind the scenes, a metavariable represents the unknown HAdd instance.#check fun x => x + x\nfun x => x + x : (x : ?m.12) → ?m.19 x\n\n\nTesting Type ErrorsThis variant of #check elaborates the term using the same process as #check.\nIf elaboration succeeds, it is an error; if it fails, there is no error.\nThe partially-elaborated term and any type information that was discovered are added to the message log.\n\nChecking for Type ErrorsAttempting to add a string to a natural number fails, as expected:#check_failure \"one\" + 1\nfailed to synthesize\n  HAdd String Nat ?m.32\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\nNonetheless, a partially-elaborated term is available:\"one\" + 1 : ?m.32\n\n\n"},"/Basic-Types/Natural-Numbers/#nat-api":{"id":"/Basic-Types/Natural-Numbers/#nat-api","header":"19.1.4. API Reference","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});