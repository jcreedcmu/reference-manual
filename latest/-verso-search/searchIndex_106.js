window.docContents[106].resolve({"/Tactic-Proofs/The-Tactic-Language/#tactic-language-multiple-goals":{"id":"/Tactic-Proofs/The-Tactic-Language/#tactic-language-multiple-goals","header":"13.3.1.3.2. Working on Multiple Goals","context":"Lean Reference\u0009Tactic Proofs\u0009The Tactic Language\u0009Control Structures\u0009Goal Selection","contents":"The tactics all_goals and any_goals allow a tactic to be applied to every goal in the proof state.\nThe difference between them is that if the tactic fails for in any of the goals, all_goals itself fails, while any_goals fails only if the tactic fails in all of the goals.\n\nall_goals tac runs tac on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire all_goals tactic fails.See also any_goals tac.\n\nany_goals tac applies the tactic tac to every goal,\nconcatenating the resulting goals for successful tactic applications.\nIf the tactic fails on all of the goals, the entire any_goals tactic fails.This tactic is like all_goals try tac except that it fails if none of the applications of tac succeeds.\n\n"},"/Tactic-Proofs/#tactics":{"id":"/Tactic-Proofs/#tactics","header":"13. Tactic Proofs","context":"Lean Reference","contents":"The tactic language is a special-purpose programming language for constructing proofs.\nIn Lean, propositions are represented by types, and proofs are terms that inhabit these types.\nThe section on propositions describes propositions in more detail.\nWhile terms are designed to make it convenient to indicate a specific inhabitant of a type, tactics are designed to make it convenient to demonstrate that a type is inhabited.\nThis distinction exists because it's important that definitions pick out the precise objects of interest and that programs return the intended results, but proof irrelevance means that there's no technical reason to prefer one proof term over another.\nFor example, given two assumptions of a given type, a program must be carefully written to use the correct one, while a proof may use either without consequence.\n\nTactics are imperative programs that modify a proof state.\nA proof state consists of an ordered sequence of goals, which are contexts of local assumptions together with types to be inhabited; a tactic may either succeed with a possibly-empty sequence of further goals (called subgoals) or fail if it cannot make progress.\nIf a tactic succeeds with no subgoals, then the proof is complete.\nIf it succeeds with one or more subgoals, then its goal or goals will be proved when those subgoals have been proved.\nThe first goal in the proof state is called the main goal.\nWhile most tactics affect only the main goal, operators such as <;> and all_goals can be used to apply a tactic to many goals, and operators such as bullets, next or case can narrow the focus of subsequent tactics to only a single goal in the proof state.\n\nBehind the scenes, tactics construct proof terms.\nProof terms are independently checkable evidence of a theorem's truth, written in Lean's type theory.\nEach proof is checked in the kernel, and can be verified with independently-implemented external checkers, so the worst outcome from a bug in a tactic is a confusing error message, rather than an incorrect proof.\nEach goal in a tactic proof corresponds to an incomplete portion of a proof term.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Custom-Tactics":{"id":"/Notations-and-Macros/Elaborators/#The-Lean-Language-Reference--Notations-and-Macros--Elaborators--Custom-Tactics","header":"20.6.3. Custom Tactics","context":"Lean Reference\u0009Notations and Macros\u0009Elaborators","contents":"Custom tactics are described in the section on tactics.\n\n\n"},"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs":{"id":"/Definitions/Recursive-Definitions/#The-Lean-Language-Reference--Definitions--Recursive-Definitions--Well-Founded-Recursion--Termination-proofs","header":"7.6.3.2. Termination proofs","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","contents":"Once a measure is specified and its well-founded relation is determined, Lean determines the termination proof obligation for every recursive call.\n\n\n\nThe proof obligation for each recursive call is of the form g a₁ a₂ … ≺ g p₁ p₂ …, where:\n\n* g is the measure as a function of the parameters,* ≺ is the inferred well-founded relation,* a₁ a₂ … are the arguments of the recursive call and* p₁ p₂ … are the parameters of the function definition.\n\nThe context of the proof obligation is the local context of the recursive call.\nIn particular, local assumptions (such as those introduced by if h : _, match h : _ with  or have) are available.\nIf a function parameter is the discriminant of a pattern match (e.g. by a match expression), then this parameter is refined to the matched pattern in the proof obligation.\n\n\n\nThe overall termination proof obligation consists of one goal for each recursive call.\nBy default, the tactic decreasing_trivial is used to prove each proof obligation.\nA custom tactic script can be provided using the optional decreasing_by clause, which comes after the termination_by clause.\nThis tactic script is run once, with one goal for each proof obligation, rather than separately on each proof obligation.\n\n\n\nTermination Proof ObligationsThe following recursive definition of the Fibonacci numbers has two recursive calls, which results in two goals in the termination proof.def fib (n : Nat) :=\n  if h : n ≤ 1 then\n    1\n  else\n    fib (n - 1) + fib (n - 2)\ntermination_by n\ndecreasing_by\n  skip\nn : Nat\nh : ¬n ≤ 1\n⊢ n - 1 < n\n\nn : Nat\nh : ¬n ≤ 1\n⊢ n - 2 < nHere, the measure is simply the parameter itself, and the well-founded order is the less-than relation on natural numbers.\nThe first proof goal requires the user to prove that the argument of the first recursive call, namely n - 1, is strictly smaller than the function's parameter, n.Both termination proofs can be easily discharged using the omega tactic.def fib (n : Nat) :=\n  if h : n ≤ 1 then\n    1\n  else\n    fib (n - 1) + fib (n - 2)\ntermination_by n\ndecreasing_by\n  · omega\n  · omega\n\n\n\n\nRefined ParametersIf a parameter of the function is the discriminant of a pattern match, then the proof obligations mention the refined parameter.def fib : Nat → Nat\n  | 0 | 1 => 1\n  | .succ (.succ n) => fib (n + 1) + fib n\ntermination_by n => n\ndecreasing_by\n  skip\nn : Nat\n⊢ n + 1 < n.succ.succ\n\nn : Nat\n⊢ n < n.succ.succ\n\nAdditionally, the context is enriched with additional assumptions that can make it easier to prove termination.\nSome examples include:* In the branches of an if-then-else expression, a hypothesis that asserts the current branch's condition is added, much as if the dependent if-then-else syntax had been used.* In the function argument to certain higher-order functions, the context of the function's body is enriched with assumptions about the argument.This list is not exhaustive, and the mechanism is extensible.\nIt is described in detail in the section on preprocessing.\n\n\n\nEnriched Proof Obligation ContextsHere, the if does not add a local assumption about the condition (that is, whether n ≤ 1) to the local contexts in the branches.def fib (n : Nat) :=\n  if n ≤ 1 then\n    1\n  else\n    fib (n - 1) + fib (n - 2)\ntermination_by n\ndecreasing_by\n  skip\nNevertheless, the assumptions are available in the context of the termination proof:n : Nat\nh✝ : ¬n ≤ 1\n⊢ n - 1 < n\n\nn : Nat\nh✝ : ¬n ≤ 1\n⊢ n - 2 < nTermination proof obligations in body of a for​…​in loop are also enriched, in this case with a Std.Range membership hypothesis:def f (xs : Array Nat) : Nat := Id.run do\n  let mut s := xs.sum\n  for i in [:xs.size] do\n    s := s + f (xs.take i)\n  pure s\ntermination_by xs\ndecreasing_by\n  skip\nxs : Array Nat\ni : Nat\nh✝ : i ∈ { stop := xs.size, step_pos := Nat.zero_lt_one }\n⊢ sizeOf (xs.take i) < sizeOf xsSimilarly, in the following (contrived) example, the termination proof contains an additional assumption showing that x ∈ xs.def f (n : Nat) (xs : List Nat) : Nat :=\n  List.sum (xs.map (fun x => f x []))\ntermination_by xs\ndecreasing_by\n  skip\nn : Nat\nxs : List Nat\nx : Nat\nh✝ : x ∈ xs\n⊢ sizeOf [] < sizeOf xsThis feature requires special setup for the higher-order function under which the recursive call is nested, as described in the section on preprocessing.\nIn the following definition, identical to the one above except using a custom, equivalent function instead of List.map, the proof obligation context is not enriched:def List.myMap := @List.map\ndef f (n : Nat) (xs : List Nat) : Nat :=\n  List.sum (xs.myMap (fun x => f x []))\ntermination_by xs\ndecreasing_by\n  skip\nn : Nat\nxs : List Nat\nx : Nat\n⊢ sizeOf [] < sizeOf xs\n\n\n\n\n\n\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Iteration":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Dependent-Hash-Maps--Iteration","header":"19.17.3.5. Iteration","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Dependent Hash Maps","contents":"Updates the values of the hash map by applying the given function to all mappings.\n\nFolds the given function over the mappings in the hash map in some order.\n\nMonadically computes a value by folding the given function over the mappings in the hash\nmap in some order.\n\nSupport for the for loop construct in do blocks.\n\nCarries out a monadic action on each mapping in the hash map in some order.\n\n"},"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Conversions":{"id":"/Basic-Types/Characters/#The-Lean-Language-Reference--Basic-Types--Characters--API-Reference--Conversions","header":"19.7.4.1. Conversions","context":"Lean Reference\u0009Basic Types\u0009Characters\u0009API Reference","contents":"Converts a Nat into a Char. If the Nat does not encode a valid Unicode scalar value, '\\0' is\nreturned instead.\n\nThe character's Unicode code point as a Nat.\n\nTrue for natural numbers that are valid Unicode scalar\nvalues.\n\nConverts an 8-bit unsigned integer into a character.The integer's value is interpreted as a Unicode code point.\n\nConverts a character into a UInt8 that contains its code point.If the code point is larger than 255, it is truncated (reduced modulo 256).\n\nThere are two ways to convert a character to a string.\nChar.toString converts a character to a singleton string that consists of only that character, while Char.quote converts the character to a string representation of the corresponding character literal.\n\nConstructs a singleton string that contains only the provided character.Examples:* 'L'.toString = \"L\"* '\"'.toString = \"\\\"\"\n\nQuotes the character to its representation as a character literal, surrounded by single quotes and\nescaped as necessary.Examples:* 'L'.quote = \"'L'\"* '\"'.quote = \"'\\\\\\\"'\"\n\nFrom Characters to StringsChar.toString produces a string that contains only the character in question:#eval 'e'.toString\n\"e\"\n#eval '\\x65'.toString\n\"e\"\n#eval '\"'.toString\n\"\\\"\"\nChar.quote produces a string that contains a character literal, suitably escaped:#eval 'e'.quote\n\"'e'\"\n#eval '\\x65'.quote\n\"'e'\"\n#eval '\"'.quote\n\"'\\\\\\\"'\"\n\n\n"}});