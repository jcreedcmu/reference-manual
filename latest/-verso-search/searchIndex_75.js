window.docContents[75].resolve({"/The--grind--tactic/Case-Analysis/#The-Lean-Language-Reference--The--grind--tactic--Case-Analysis--Selection-heuristics":{"id":"/The--grind--tactic/Case-Analysis/#The-Lean-Language-Reference--The--grind--tactic--Case-Analysis--Selection-heuristics","header":"17.7.1. Selection heuristics","context":"Lean Reference\u0009The  grind  tactic\u0009Case Analysis","contents":"grind decides which sub‚Äëterm to split on by combining three sources of signal:\n\n1. Structural flags ‚Äî quick Booleans that enable whole syntactic classes:* splitIte (default true) ‚Üí split every if ‚Ä¶ then ‚Ä¶ else ‚Ä¶ term.* splitMatch (default true) ‚Üí split on all match expressions (the grind analogue of Lean‚Äôs split tactic, just like splitIte).* splitImp (default false) ‚Üí when true splits on any hypothesis A ‚Üí B whose antecedent A is propositional.  Arithmetic antecedents are special‚Äëcased: if A is an arithmetic literal (‚â§, =, ¬¨, Dvd, ‚Ä¶) grind will split even when splitImp := false so the integer solver can propagate facts.\n\nüëâ Shorthand toggles: by grind -splitIte +splitImp expands to by grind (splitIte := false) (splitImp := true).\n\n2. Global limit ‚Äî splits := n caps the depth of the search tree.  Once a branch performs n splits grind stops splitting further in that branch; if the branch cannot be closed it reports that the split threshold has been reached.3. Manual annotations ‚Äî you may mark any inductive predicate or structure withattribute [grind cases] Even Sorted\nand grind will treat every instance of that predicate as a candidate for splitting.\n\n"},"/Terms/Holes/#The-Lean-Language-Reference--Terms--Holes":{"id":"/Terms/Holes/#The-Lean-Language-Reference--Terms--Holes","header":"10.9. Holes","context":"Lean Reference\u0009Terms","contents":"A hole or placeholder term is a term that indicates the absence of instructions to the elaborator.\nIn terms, holes can be automatically filled when the surrounding context would only allow one type-correct term to be written where the hole is.\nOtherwise, a hole is an error.\nIn patterns, holes represent universal patterns that can match anything.\n\nHolesHoles are written with underscores.\n\nFilling Holes with UnificationThe function the can be used similarly to show or a type ascription.def the (Œ± : Sort u) (x : Œ±) : Œ± := x\nIf the second parameter's type can be inferred, then the first parameter can be a hole.\nBoth of these commands are equivalent:#check the String \"Hello!\"\n\n#check the _ \"Hello\"\n\n\nWhen writing proofs, it can be convenient to explicitly introduce unknown values.\nThis is done via synthetic holes, which are never solved by unification and may occur in multiple positions.\nThey are primarily useful in tactic proofs, and are described in the section on metavariables in proofs.\n\nSynthetic Holes\n\n"},"/Tactic-Proofs/Custom-Tactics/#tactic-macros":{"id":"/Tactic-Proofs/Custom-Tactics/#tactic-macros","header":"13.8.1. Tactic Macros","context":"Lean Reference\u0009Tactic Proofs\u0009Custom Tactics","contents":"The easiest way to define a new tactic is as a macro that expands into already-existing tactics.\nMacro expansion is interleaved with tactic execution.\nThe tactic interpreter first expands tactic macros just before they are to be interpreted.\nBecause tactic macros are not fully expanded prior to running a tactic script, they can use recursion; as long as the recursive occurrence of the macro syntax is beneath a tactic that can be executed, there will not be an infinite chain of expansion.\n\nRecursive tactic macroThis recursive implementation of a tactic akin to repeat is defined via macro expansion.\nWhen the argument $t fails, the recursive occurrence of rep is never invoked, and is thus never macro expanded.syntax \"rep\" tactic : tactic\nmacro_rules\n  | `(tactic|rep $t) =>\n  `(tactic|\n    first\n      | $t; rep $t\n      | skip)\n\nexample : 0 ‚â§ 4 := by\n  rep (apply Nat.le.step)\n  apply Nat.le.refl\n\n\nLike other Lean macros, tactic macros are hygienic.\nReferences to global names are resolved when the macro is defined, and names introduced by the tactic macro cannot capture names from its invocation site.\n\nWhen defining a tactic macro, it's important to specify that the syntax being matched or constructed is for the syntax category tactic.\nOtherwise, the syntax will be interpreted as that of a term, which will match against or construct an incorrect AST for tactics.\n\n\n\n"},"/Notations-and-Macros/Macros/#macros":{"id":"/Notations-and-Macros/Macros/#macros","header":"20.5. Macros","context":"Lean Reference\u0009Notations and Macros","contents":"Macros are transformations from Syntax to Syntax that occur during elaboration and during tactic execution.\nReplacing syntax with the result of transforming it with a macro is called macro expansion.\nMultiple macros may be associated with a single syntax kind, and they are attempted in order of definition.\nMacros are run in a monad that has access to some compile-time metadata and has the ability to either emit an error message or to delegate to subsequent macros, but the macro monad is much less powerful than the elaboration monads.\n\n\n\nMacros are associated with syntax kinds.\nAn internal table maps syntax kinds to macros of type Syntax ‚Üí MacroM Syntax.\nMacros delegate to the next entry in the table by throwing the unsupportedSyntax exception.\nA given Syntax value is a macro when there is a macro associated with its syntax kind that does not throw unsupportedSyntax.\nIf a macro throws any other exception, an error is reported to the user.\nSyntax categories are irrelevant to macro expansion; however, because each syntax kind is typically associated with a single syntax category, they do not interfere in practice.\n\nMacro Error ReportingThe following macro reports an error when its parameter is the literal numeral five.\nIt expands to its argument in all other cases.syntax &\"notFive\" term:arg : term\nopen Lean in\nmacro_rules\n  | `(term|notFive 5) =>\n    Macro.throwError \"'5' is not allowed here\"\n  | `(term|notFive $e) =>\n    pure e\nWhen applied to terms that are not syntactically the numeral five, elaboration succeeds:#eval notFive (2 + 3)\n5\nWhen the error case is triggered, the user receives an error message:#eval notFive 5\n'5' is not allowed here\n\n\nBefore elaborating a piece of syntax, the elaborator checks whether its syntax kind has macros associated with it.\nThese are attempted in order.\nIf a macro succeeds, potentially returning syntax with a different kind, the check is repeated and macros are expanded again until the outermost layer of syntax is no longer a macro.\nElaboration or tactic execution can then proceed.\nOnly the outermost layer of syntax (typically a node) is expanded, and the output of macro expansion may contain nested syntax that is a macro.\nThese nested macros are expanded in turn when the elaborator reaches them.\n\nIn particular, macro expansion occurs in three situations in Lean:\n\n1. During term elaboration, macros in the outermost layer of the syntax to be elaborated are expanded prior to invoking the syntax's term elaborator.2. During command elaboration, macros in the outermost layer of the syntax to be elaborated are expanded prior to invoking the syntax's command elaborator.3. During tactic execution, macros in the outermost layer of the syntax to be elaborated are expanded prior to executing the syntax as a tactic.\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Definitions/Recursive-Definitions/#inferring-well-founded-recursion":{"id":"/Definitions/Recursive-Definitions/#inferring-well-founded-recursion","header":"7.6.3.4. Inferring Well-Founded Recursion","context":"Lean Reference\u0009Definitions\u0009Recursive Definitions\u0009Well-Founded Recursion","contents":"If a recursive function definition does not indicate a termination measure, Lean will attempt to discover one automatically.\nIf neither termination_by nor decreasing_by is provided, Lean will try to infer structural recursion before attempting well-founded recursion.\nIf a decreasing_by clause is present, only well-founded recursion is attempted.\n\nTo infer a suitable termination measure, Lean considers multiple basic termination measures, which are termination measures of type Nat, and then tries all tuples of these measures.\n\nThe basic termination measures considered are:\n\n* all parameters whose type have a non-trivial SizeOf instance* the expression e‚ÇÇ - e‚ÇÅ whenever the local context of a recursive call has an assumption of type e‚ÇÅ < e‚ÇÇ or e‚ÇÅ ‚â§ e‚ÇÇ, where e‚ÇÅ and e‚ÇÇ are of type Nat and depend only on the function's parameters. This approach is based on work by .* in a mutual group, an additional basic measure is used to distinguish between recursive calls to other functions in the group and recursive calls to the function being defined (for details, see the section on mutual well-founded recursion)\n\nCandidate measures are basic measures or tuples of basic measures.\nIf any of the candidate measures allow all proof obligations to be discharged by the termination proof tactic (that is, the tactic specified by decreasing_by, or decreasing_trivial if there is no decreasing_by clause), then an arbitrary such candidate measure is selected as the automatic termination measure.\n\nA termination_by? clause causes the inferred termination annotation to be shown.\nIt can be automatically added to the source file using the offered suggestion or code action.\n\nTo avoid the combinatorial explosion of trying all tuples of measures, Lean first tabulates all basic termination measures, determining whether the basic measure is decreasing, strictly decreasing, or non-decreasing.\nA decreasing measure is smaller for at least one recursive call and never increases at any recursive call, while a strictly decreasing measure is smaller at all recursive calls.\nA non-decreasing measure is one that the termination tactic could not show to be decreasing or strictly decreasing.\nA suitable tuple is chosen based on the table.This approach is based on .\nThis table shows up in the error message when no automatic measure could be found.\n\nTermination failureIf there is no termination_by clause, Lean attempts to infer a measure for well-founded recursion.\nIf it fails, then it prints the table mentioned above.\nIn this example, the decreasing_by clause simply prevents Lean from also attempting structural recursion; this keeps the error message specific.def f : (n m l : Nat) ‚Üí Nat\n  | n+1, m+1, l+1 => [\n      f (n+1) (m+1) (l+1),\n      f (n+1) (m-1) (l),\n      f (n)   (m+1) (l) ].sum\n  | _, _, _ => 0\ndecreasing_by all_goals decreasing_tactic\nCould not find a decreasing measure.\nThe basic measures relate at each recursive call as follows:\n(<, ‚â§, =: relation proved, ? all proofs failed, _: no proof attempted)\n           n m l\n1) 32:6-25 = = =\n2) 33:6-23 = < _\n3) 34:6-23 < _ _\nPlease use `termination_by` to specify a decreasing measure.\nThe three recursive calls are identified by their source positions.\nThis message conveys the following facts:* In the first recursive call, all arguments are (provably) equal to the parameters* In the second recursive call, the first argument is equal to the first parameter and the second argument is provably smaller than the second parameter.\n  The third parameter was not checked for this recursive call, because it was not necessary to determine that no suitable termination argument exists.* In the third recursive call, the first argument decreases strictly, and the other arguments were not checked.When termination proofs fail in this manner, a good technique to discover the problem is to explicitly indicate the expected termination argument using termination_by.\nThis will surface the messages from the failing tactic.\n\n\n\nArray IndexingThe purpose of considering expressions of the form e‚ÇÇ - e‚ÇÅ as measures is to support the common idiom of counting up to some upper bound, in particular when traversing arrays in possibly interesting ways.\nIn the following function, which performs binary search on a sorted array, this heuristic helps Lean to find the j - i measure.def binarySearch (x : Int) (xs : Array Int) : Option Nat :=\n  go 0 xs.size\nwhere\n  go (i j : Nat) (hj : j ‚â§ xs.size := by omega) :=\n    if h : i < j then\n      let mid := (i + j) / 2\n      let y := xs[mid]\n      if x = y then\n        some mid\n      else if x < y then\n        go i mid\n      else\n        go (mid + 1) j\n    else\n      none\n  termination_by?\nThe fact that the inferred termination argument uses some arbitrary measure, rather than an optimal or minimal one, is visible in the inferred measure, which contains a redundant j:Try this: termination_by (j, j - i)\n\n\n\n\nTermination Proof Tactics During InferenceThe tactic indicated by decreasing_by is used slightly differently when inferring the termination measure than it is in the actual termination proof.* During inference, it is applied to a single goal, attempting to prove < or ‚â§ on Nat.* During the termination proof, it is applied to many simultaneous goals (one per recursive call), and the goals may involve the lexicographic ordering of pairs.A consequence is that a decreasing_by block that addresses goals individually and which works successfully with an explicit termination argument can cause inference of the termination measure to fail:def ack : Nat ‚Üí Nat ‚Üí Nat\n  | 0, n => n + 1\n  | m + 1, 0 => ack m 1\n  | m + 1, n + 1 => ack m (ack (m + 1) n)\ndecreasing_by\n  ¬∑ apply Prod.Lex.left\n    omega\n  ¬∑ apply Prod.Lex.right\n    omega\n  ¬∑ apply Prod.Lex.left\n    omega\nIt is advisable to always include a termination_by clause whenever an explicit decreasing_by proof is given.\n\nInference too powerfulBecause decreasing_tactic avoids the need to backtrack by being incomplete with regard to lexicographic ordering, Lean may infer a termination measure that leads to goals that the tactic cannot prove.\nIn this case, the error message is the one that results from the failing tactic rather than the one that results from being unable to find a measure.\nThis is what happens in notAck:def notAck : Nat ‚Üí Nat ‚Üí Nat\n  | 0, n => n + 1\n  | m + 1, 0 => notAck m 1\n  | m + 1, n + 1 => notAck m (notAck (m / 2 + 1) n)\ndecreasing_by all_goals decreasing_tactic\nfailed to prove termination, possible solutions:\n  - Use `have`-expressions to prove the remaining goals\n  - Use `termination_by` to specify a different well-founded relation\n  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\ncase h\nm n : Nat\n‚ä¢ m / 2 + 1 < m + 1\nIn this case, explicitly stating the termination measure helps.\n\n"}});