window.docContents[117].resolve({"/The--grind--tactic/Linear-Arithmetic-Solver/#The-Lean-Language-Reference--The--grind--tactic--Linear-Arithmetic-Solver":{"id":"/The--grind--tactic/Linear-Arithmetic-Solver/#The-Lean-Language-Reference--The--grind--tactic--Linear-Arithmetic-Solver","header":"17.11. Linear Arithmetic Solver","context":"Lean Reference\u0009The  grind  tactic","contents":"grind also contains a linear arithmetic linarith solver parametrized by type classes.\nIt self-configures depending on the availability of these type classes, so not all need to be provided.\nThe capabilities of the linarith solver will of course degrade when some are not available.\nThe solver ignores any type supported by cutsat. This module is useful for reasoning about Real,\nordered vector spaces, etc.\n\nThe main type classes for module structures are NatModule (every Semiring is a NatModule) and IntModule (every Ring is an IntModule).\nThese may interact with the three order classes Preorder, PartialOrder, and LinearOrder.\n(Typically a Preorder is enough when the context already includes a contradiction, but to prove linear inequality goals you will need a LinearOrder.)\nTo express that the additive structure in a module is compatible with the order we need OrderedAdd. We have limited support for ordered rings at present, represented by the typeclass OrderedRing.\n\nA module over the natural numbers, i.e. a type with zero, addition, and scalar multiplication by natural numbers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative monoid.Use IntModule if the type has negation.Scalar multiplication by natural numbers.Scalar multiplication by zero is zero.Scalar multiplication by one is the identity.Scalar multiplication is distributive over addition in the natural numbers.Scalar multiplication of zero is zero.Scalar multiplication is distributive over addition in the module.\n\nA module over the integers, i.e. a type with zero, addition, negation, subtraction, and scalar multiplication by integers,\nsatisfying appropriate compatibilities.Equivalently, an additive commutative group.Scalar multiplication by natural numbers.Scalar multiplication by integers.Scalar multiplication by zero is zero.Scalar multiplication by one is the identity.Scalar multiplication is distributive over addition in the integers.Scalar multiplication of zero is zero.Scalar multiplication by integers is distributive over addition in the module.Scalar multiplication by natural numbers is consistent with scalar multiplication by integers.\n\nA preorder is a reflexive, transitive relation ≤ with a < b defined in the obvious way.The less-than-or-equal relation is reflexive.The less-than-or-equal relation is transitive.The less-than relation is determined by the less-than-or-equal relation.\n\nA partial order is a preorder with the additional property that a ≤ b and b ≤ a implies a = b.The less-than-or-equal relation is antisymmetric.\n\nA linear order is a partial order with the additional property that every pair of elements is comparable.For every two elements a and b, either a ≤ b or b ≤ a.\n\nAddition is compatible with a preorder if a ≤ b ↔ a + c ≤ b + c.a + c ≤ b + c iff a ≤ b.\n\nA ring which is also equipped with a preorder is considered a strict ordered ring if addition, negation,\nand multiplication are compatible with the preorder, and 0 < 1.In a strict ordered semiring, we have 0 < 1.In a strict ordered semiring, we can multiply an inequality a < b on the left\nby a positive element 0 < c to obtain c * a < c * b.In a strict ordered semiring, we can multiply an inequality a < b on the right\nby a positive element 0 < c to obtain a * c < b * c.\n\nThe core functionality of linarith is a model based solver for linear inequalities with integer coefficients.\nYou can disable this solver using the option grind -linarith.\n\nThe following examples demonstrate goals that can be decided by the linarith solver.\n\n\n\nvariable [IntModule α] [LinearOrder α] [OrderedAdd α]\n\nexample (a b : α) : 2*a + b ≥ b + a + a := by grind\nexample (a b : α) (h : a ≤ b) : 3 * a + b ≤ 4 * b := by grind\nexample (a b c : α) (_ : a = b + c) (_ : 2 * b ≤ c) :\n    2 * a ≤ 3 * c := by grind\n\nexample (a b c d e : α) :\n    2*a + b ≥ 0 → b ≥ 0 → c ≥ 0 → d ≥ 0 → e ≥ 0\n    → a ≥ 3*c → c ≥ 6*e → d - 5*e ≥ 0\n    → a + b + 3*c + d + 2*e < 0 → False := by\n  grind\n\n\n\n\n\n\nAt present we only use the CommRing structure to do basic normalization (e.g. identifying linear atoms a * b and b * a),\nand to allow constants (with the fact 0 < 1) and scalar multiplication on both sides.\n\nvariable [CommRing R] [LinearOrder R] [OrderedRing R]\n\nexample (a b : R) (h : a * b ≤ 1) : b * 3 * a + 1 ≤ 4 := by grind\n\nexample (a b c d e f : R) :\n    2*a + b ≥ 1 → b ≥ 0 → c ≥ 0 → d ≥ 0 → e*f ≥ 0\n    → a ≥ 3*c → c ≥ 6*e*f → d - f*e*5 ≥ 0\n    → a + b + 3*c + d + 2*e*f < 0 → False := by\n  grind\n\n\n\n\nPlanned future features\n\n* Support for NatModule (by embedding in the Grothendieck envelope, as we already do for semirings),* Better communication between the ring and linarith solvers.\n  There is currently very little communication between these two solvers.* Non-linear arithmetic over ordered rings.\n\n\n\n"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv":{"id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv","header":"13.6. Targeted Rewriting with  conv","context":"Lean Reference\u0009Tactic Proofs","contents":"The conv, or conversion, tactic allows targeted rewriting within a goal.\nThe argument to conv is written in a separate language that interoperates with the main tactic language; it features commands to navigate to specific subterms within the goal along with commands that allow these subterms to be rewritten.\nconv is useful when rewrites should only be applied in part of a goal (e.g. only on one side of an equality), rather than across the board, or when rewrites should be applied underneath a binder that prevents tactics like rw from accessing the term.\n\nThe conversion tactic language is very similar to the main tactic language: it uses the same proof states, tactics work primarily on the main goal and may either fail or succeed with a sequence of new goals, and macro expansion is interleaved with tactic execution.\nUnlike the main tactic language, in which tactics are intended to eventually solve goals, the conv tactic is used to change a goal so that it becomes amenable to further processing in the main tactic language.\nGoals that are intended to be rewritten with conv are shown with a vertical bar instead of a turnstile.\n\nconv => ... allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.See https://lean-lang.org/theorem_proving_in_lean4/conv.html for more details.Basic forms:* conv => cs will rewrite the goal with conv tactics cs.* conv at h => cs will rewrite hypothesis h.* conv in pat => cs will rewrite the first subexpression matching pat (see pattern).\n\nNavigation and Rewriting with convIn this example, there are multiple instances of addition, and rw would by default rewrite the first instance that it encounters.\nUsing conv to navigate to the specific subterm before rewriting leaves rw no choice but to rewrite the correct term.example (x y z : Nat) : x + (y + z) = (x + z) + y := by\n  conv =>\n    lhs\n    arg 2\n    rw [Nat.add_comm]\n  rw [Nat.add_assoc]\n\n\nRewriting Under Binders with convIn this example, addition occurs under binders, so rw can't be used.\nHowever, after using conv to navigate to the function body, it succeeds.\nThe nested use of conv causes control to return to the current position in the term after performing further conversions on one of its subterms.\nBecause the goal is a reflexive equation after rewriting, conv automatically closes it.example :\n    (fun (x y z : Nat) =>\n      x + (y + z))\n    =\n    (fun x y z =>\n      (z + x) + y)\n  := by\n  conv =>\n    lhs\n    intro x y z\n    conv =>\n      arg 2\n      rw [Nat.add_comm]\n    rw [← Nat.add_assoc]\n    arg 1\n    rw [Nat.add_comm]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Workspace":{"id":"/Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Script-API-Reference--Accessing-the-Workspace","header":"22.1.4.2. Accessing the Workspace","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Script API Reference","contents":"Monads that provide access to information about the current Lake workspace have MonadWorkspace instances.\nIn particular, there are instances for ScriptM and LakeM.\n\n\n\nA monad equipped with a (read-only) Lake Workspace.Gets the current Lake workspace.\n\nGet the root package of the context's workspace.\n\nTry to find a package within the workspace with the given name.\n\nLocate the named, buildable, importable, local module in the workspace.\n\nTry to find a Lean executable in the workspace with the given name.\n\nTry to find a Lean library in the workspace with the given name.\n\nTry to find an external library in the workspace with the given name.\n\nGet the paths added to LEAN_PATH by the context's workspace.\n\nGet the paths added to LEAN_SRC_PATH by the context's workspace.\n\nGet the paths added to the shared library path by the context's workspace.\n\nGet the augmented LEAN_PATH set by the context's workspace.\n\nGet the augmented LEAN_SRC_PATH set by the context's workspace.\n\nGet the augmented shared library path set by the context's workspace.\n\nGet the augmented environment variables set by the context's workspace.\n\n"},"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Extracting-Values":{"id":"/Basic-Types/Sum-Types/#The-Lean-Language-Reference--Basic-Types--Sum-Types--API-Reference--Extracting-Values","header":"19.14.2.2. Extracting Values","context":"Lean Reference\u0009Basic Types\u0009Sum Types\u0009API Reference","contents":"Case analysis for sums that applies the appropriate function f or g after checking which\nconstructor is present.\n\nRetrieves the contents from a sum known to be inl.\n\nChecks whether a sum is the left injection inl and, if so, retrieves its contents.\n\nRetrieves the contents from a sum known to be inr.\n\nChecks whether a sum is the right injection inr and, if so, retrieves its contents.\n\n"}});