window.docContents[1].resolve({"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Solver-Type-Classes--Algebraic-Structures":{"id":"/The--grind--tactic/Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_/#The-Lean-Language-Reference--The--grind--tactic--Algebraic-Solver-_LPAR_Commutative-Rings___-Fields_RPAR_--Solver-Type-Classes--Algebraic-Structures","header":"17.8.1.1. Algebraic Structures","context":"Lean Reference\u0009The  grind  tactic\u0009Algebraic Solver (Commutative Rings, Fields)\u0009Solver Type Classes","contents":"To enable the algebraic solver, a type should have an instance of the most specific possible algebraic structure that the solver supports.\nIn order of increasing specificity, that is Semiring, Ring, CommSemiring, CommRing, and Field.\n\nA semiring, i.e. a type equipped with addition, multiplication, and a map from the natural numbers,\nsatisfying appropriate compatibilities.Use Ring instead if the type also has negation,\nCommSemiring if the multiplication is commutative,\nor CommRing if the type has negation and multiplication is commutative.In every semiring there is a canonical map from the natural numbers to the semiring,\nproviding the values of 0 and 1. Note that this function need not be injective.Natural number numerals in the semiring.\nThe field ofNat_eq_natCast ensures that these are (propositionally) equal to the values of natCast.Scalar multiplication by natural numbers.Exponentiation by a natural number.Zero is the right identity for addition.Addition is commutative.Addition is associative.Multiplication is associative.One is the right identity for multiplication.One is the left identity for multiplication.Left distributivity of multiplication over addition.Right distributivity of multiplication over addition.Zero is right absorbing for multiplication.Zero is left absorbing for multiplication.The zeroth power of any element is one.The successor power law for exponentiation.Numerals are consistently defined with respect to addition.Numerals are consistently defined with respect to the canonical map from natural numbers.\n\nA commutative semiring, i.e. a semiring with commutative multiplication.Use CommRing if the type has negation.Multiplication is commutative.\n\nA ring, i.e. a type equipped with addition, negation, multiplication, and a map from the integers,\nsatisfying appropriate compatibilities.Use CommRing if the multiplication is commutative.In every ring there is a canonical map from the integers to the ring.Scalar multiplication by integers.Negation is the left inverse of addition.Subtraction is addition of the negative.Scalar multiplication by the negation of an integer is the negation of scalar multiplication by that integer.Scalar multiplication by natural numbers is consistent with scalar multiplication by integers.The canonical map from the integers is consistent with the canonical map from the natural numbers.The canonical map from the integers is consistent with negation.\n\nA commutative ring, i.e. a ring with commutative multiplication.Multiplication is commutative.\n\n\n\n"},"/Notations-and-Macros/Defining-New-Syntax/#syntax-indentation":{"id":"/Notations-and-Macros/Defining-New-Syntax/#syntax-indentation","header":"20.4.12. Indentation","context":"Lean Reference\u0009Notations and Macros\u0009Defining New Syntax","contents":"Internally, the parser maintains a saved source position.\nSyntax rules may include instructions that interact with these saved positions, causing parsing to fail when a condition is not met.\nIndentation-sensitive constructs, such as do, save a source position, parse their constituent parts while taking this saved position into account, and then restore the original position.\n\nIn particular, Indentation-sensitvity is specified by combining withPosition or withPositionAfterLinebreak, which save the source position at the start of parsing some other syntax, with colGt, colGe, and colEq, which compare the current column with the column from the most recently-saved position.\nlineEq can also be used to ensure that two positions are on the same line in the source file.\n\nwithPosition(p) runs p while setting the \"saved position\" to the current position.\nThis has no effect on its own, but various other parsers access this position to achieve some\ncomposite effect:* colGt, colGe, colEq compare the column of the saved position to the current position,\nused to implement Python-style indentation sensitive blocks* lineEq ensures that the current position is still on the same line as the saved position,\nused to implement composite tokensThe saved position is only available in the read-only state, which is why this is a scoping parser:\nafter the withPosition(..) block the saved position will be restored to its original value.This parser has the same arity as p - it just forwards the results of p.\n\nwithoutPosition(p) runs p without the saved position, meaning that position-checking\nparsers like colGt will have no effect. This is usually used by bracketing constructs like\n(...) so that the user can locally override whitespace sensitivity.This parser has the same arity as p - it just forwards the results of p.\n\n\n\nThe colGt parser requires that the next token starts a strictly greater column than the saved\nposition (see withPosition). This can be used for whitespace sensitive syntax for the arguments\nto a tactic, to ensure that the following tactic is not interpreted as an argument.example (x : False) : False := by\n  revert x\n  exact id\nHere, the revert tactic is followed by a list of colGt ident, because otherwise it would\ninterpret exact as an identifier and try to revert a variable named exact.This parser has arity 0 - it does not capture anything.\n\nThe colGe parser requires that the next token starts from at least the column of the saved\nposition (see withPosition), but allows it to be more indented.\nThis can be used for whitespace sensitive syntax to ensure that a block does not go outside a\ncertain indentation scope. For example it is used in the lean grammar for else if, to ensure\nthat the else is not less indented than the if it matches with.This parser has arity 0 - it does not capture anything.\n\nThe colEq parser ensures that the next token starts at exactly the column of the saved\nposition (see withPosition). This can be used to do whitespace sensitive syntax like\na by block or do block, where all the lines have to line up.This parser has arity 0 - it does not capture anything.\n\nThe lineEq parser requires that the current token is on the same line as the saved position\n(see withPosition). This can be used to ensure that composite tokens are not \"broken up\" across\ndifferent lines. For example, else if is parsed using lineEq to ensure that the two tokens\nare on the same line.This parser has arity 0 - it does not capture anything.\n\nAligned ColumnsThis syntax for saving notes takes a bulleted list of items, each of which must be aligned at the same column.syntax \"note \" ppLine withPosition((colEq \"◦ \" str ppLine)+) : term\nThere is no elaborator or macro associated with this syntax, but the following example is accepted by the parser:#check\n  note\n    ◦ \"One\"\n    ◦ \"Two\"\nelaboration function for '«termNote__◦__»' has not been implemented\n  note\n    ◦ \"One\"\n    ◦ \"Two\"\n\nThe syntax does not require that the list is indented with respect to the opening token, which would require an extra withPosition and a colGt.#check\n  note\n◦ \"One\"\n◦ \"Two\"\nelaboration function for '«termNote__◦__»' has not been implemented\n  note\n    ◦ \"One\"\n    ◦ \"Two\"\nThe following examples are not syntactically valid because the columns of the bullet points do not match.#check\n  note\n    ◦ \"One\"\n   ◦ \"Two\"\n<example>:4:3-4:4: expected end of input\n#check\n  note\n   ◦ \"One\"\n     ◦ \"Two\"\n<example>:4:5-4:6: expected end of input\n\n\n"},"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable":{"id":"/Error-Explanations/lean___dependsOnNoncomputable/#The-Lean-Language-Reference--Error-Explanations--lean___dependsOnNoncomputable","header":"lean.dependsOnNoncomputable","context":"Lean Reference\u0009Error Explanations","contents":"\n\nThis error indicates that the specified definition depends on one or more definitions that do not\ncontain executable code and is therefore required to be marked as noncomputable. Such definitions\ncan be type-checked but do not contain code that can be executed by Lean.\n\nIf you intended for the definition named in the error message to be noncomputable, marking it as\nnoncomputable will resolve this error. If you did not, inspect the noncomputable definitions on\nwhich it depends: they may be noncomputable because they failed to compile, are axioms, or were\nthemselves marked as noncomputable. Making all of your definition's noncomputable dependencies\ncomputable will also resolve this error. See the manual section on\nModifiers for more information about noncomputable\ndefinitions.\n\n\n\n"},"/Definitions/Headers-and-Signatures/#bracketed-parameter-syntax":{"id":"/Definitions/Headers-and-Signatures/#bracketed-parameter-syntax","header":"7.2.3. Bracketed Parameter Bindings","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","contents":"Parameters other than identifiers or underscores are collectively referred to as bracketed binders because every syntactic form for specifying them has some kind of brackets, braces, or parentheses.\nAll bracketed binders specify the type of a parameter, and most include parameter names.\nThe name is optional for instance implicit parameters.\nUsing an underscore (_) instead of a parameter name indicates an anonymous parameter.\n\nExplicit ParametersParenthesized parameters indicate explicit parameters.\nIf more than one identifier or underscore is provided, then all of them become parameters with the same type.\n\nOptional and Automatic ParametersParenthesized parameters with a := assign default values to parameters.\nParameters with default values are called optional parameters.\nAt a call site, if the parameter is not provided, then the provided term is used to fill it in.\nPrior parameters in the signature are in scope for the default value, and their values at the call site are substituted into the default value term.If a tactic script is provided, then the tactics are executed at the call site to synthesize a parameter value; parameters that are filled in via tactics are called automatic parameters.\n\nImplicit ParametersParameters in curly braces indicate implicit parameters.\nUnless provided by name at a call site, these parameters are expected to be synthesized via unification at call sites.\nImplicit parameters are synthesized at all call sites.\n\nStrict Implicit ParametersParameters in double curly braces indicate strict implicit parameters.\n⦃ … ⦄ and {{ … }} are equivalent.\nLike implicit parameters, these parameters are expected to be synthesized via unification at call sites when they are not provided by name.\nStrict implicit parameters are only synthesized at call sites when subsequent parameters in the signature are also provided.\n\nInstance Implicit ParametersParameters in square brackets indicate instance implicit parameters, which are synthesized at call sites using instance synthesis.\n\nThe parameters are always in scope in the signature's type, which occurs after the colon.\nThey are also in scope in the declaration's body, while names bound in the type itself are only in scope in the type.\nThus, parameter names are used twice:\n\n* As names in the declaration's function type, bound as part of a dependent function type.* As names in the declaration's body.\n   In function definitions, they are bound by a fun.\n\nParameter ScopeThe signature of add contains one parameter, n.\nAdditionally, the signature's type is (k : Nat) → Nat, which is a function type that includes k.\nThe parameter n is in scope in the function's body, but k is not.def add (n : Nat) : (k : Nat) → Nat\n  | 0 => n\n  | k' + 1 => 1 + add n k'\nLike add, the signature of mustBeEqual contains one parameter, n.\nIt is in scope both in the type, where it occurs in a proposition, and in the body, where it occurs as part of the message.def mustBeEqual (n : Nat) : (k : Nat) → n = k → String :=\n  fun _ =>\n    fun\n    | rfl => s!\"Equal - both are {n}!\"\n\n\n\nThe section on function application describes the interpretation of optional, automatic, implicit, and instance implicit parameters in detail.\n\n"},"/Basic-Types/The-Unit-Type/#The-Lean-Language-Reference--Basic-Types--The-Unit-Type":{"id":"/Basic-Types/The-Unit-Type/#The-Lean-Language-Reference--Basic-Types--The-Unit-Type","header":"19.9. The Unit Type","context":"Lean Reference\u0009Basic Types","contents":"The unit type is the canonical type with exactly one element, named unit and represented by the empty tuple ().\nIt describes only a single value, which consists of said constructor applied to no arguments whatsoever.\n\nUnit is analogous to void in languages derived from C: even though void has no elements that can be named, it represents the return of control flow from a function with no additional information.\nIn functional programming, Unit is the return type of things that \"return nothing\".\nMathematically, this is represented by a single completely uninformative value, as opposed to an empty type such as Empty, which represents unreachable code.\n\nWhen programming with monads, Unit is especially useful.\nFor any type α, m α represents an action that has side effects and returns a value of type α.\nThe type m Unit represents an action that has some side effects but does not return a value.\n\nThere are two variants of the unit type:\n\n* Unit is a Type that exists in the smallest non-propositional universe.* PUnit is universe polymorphic and can be used in any non-propositional universe.\n\nBehind the scenes, Unit is actually defined as PUnit.{1}.\nUnit should be preferred over PUnit when possible to avoid unnecessary universe parameters.\nIf in doubt, use Unit until universe errors occur.\n\nThe canonical type with one element. This element is written ().Unit has a number of uses:* It can be used to model control flow that returns from a function call without providing other\ninformation.* Monadic actions that return Unit have side effects without computing values.* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\nfield.\n\nThe only element of the unit type.It can be written as an empty tuple: ().\n\nThe canonical universe-polymorphic type with just one element.It should be used in contexts that require a type to be universe polymorphic, thus disallowing\nUnit.The only element of the universe-polymorphic unit type.\n\n\n\n"},"/Axioms/#standard-axioms":{"id":"/Axioms/#standard-axioms","header":"8.5. Standard Axioms","context":"Lean Reference\u0009Axioms","contents":"Lean includes the following mathematical axioms:\n\n* propext {a b : Prop} : (a ↔ b) → a = b\n* Classical.choice.{u} {α : Sort u} : Nonempty α → α\n* Quot.sound.{u} {α : Sort u}\n  {r : α → α → Prop} {a b : α} :\n  r a b → Quot.mk r a = Quot.mk r b\n\n\nThree additional axioms allow the Lean kernel to invoke code generated by the compiler, rather than using its internal reduction engine.\nThis can greatly improve performance of implementations of proof by reflection.\nRather than using these axioms directly, they are usually invoked via the native_decide tactic.\nBoth Lean.reduceBool and Lean.reduceNat contain references to Lean.trustCompiler, which ensures that the fact that a proof trusts the correctness of the compiler is tracked.\n\nThese axioms do not truly exist for their mathematical content; after all, Lean.reduceBool and Lean.reduceNat are essentially the identity function.\nHowever, they allow the use of compiled code in proofs to be carefully controlled, and tracking them as axioms allows #print axioms to be used to audit theorems.\n\n*  Lean.trustCompiler : True\n*  Lean.ofReduceBool (a b : Bool) : Lean.reduceBool a = b → a = b\n*  Lean.ofReduceNat (a b : Nat) : Lean.reduceNat a = b → a = b\n\n\nFinally, the axiom sorryAx is used as part of the implementation of the sorry tactic and sorry term.\nUses of this axiom are not intended to occur in finished proofs, and this can be confirmed using #print axioms.\n\n"}});