window.docContents[210].resolve({"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control":{"id":"/Tactic-Proofs/Tactic-Reference/#tactic-ref-control","header":"13.5.19. Control Flow","context":"Lean Reference\u0009Tactic Proofs\u0009Tactic Reference","contents":"skip does nothing.\n\nTactic to check that a named hypothesis has a given type and/or value.* guard_hyp h : t checks the type up to reducible defeq,* guard_hyp h :~ t checks the type up to default defeq,* guard_hyp h :ₛ t checks the type up to syntactic equality,* guard_hyp h :ₐ t checks the type up to alpha equality.* guard_hyp h := v checks value up to reducible defeq,* guard_hyp h :=~ v checks value up to default defeq,* guard_hyp h :=ₛ v checks value up to syntactic equality,* guard_hyp h :=ₐ v checks the value up to alpha equality.The value v is elaborated using the type of h as the expected type.\n\nTactic to check that the target agrees with a given expression.* guard_target = e checks that the target is defeq at reducible transparency to e.* guard_target =~ e checks that the target is defeq at default transparency to e.* guard_target =ₛ e checks that the target is syntactically equal to e.* guard_target =ₐ e checks that the target is alpha-equivalent to e.The term e is elaborated with the type of the goal as the expected type, which is mostly\nuseful within conv mode.\n\nTactic to check equality of two expressions.* guard_expr e = e' checks that e and e' are defeq at reducible transparency.* guard_expr e =~ e' checks that e and e' are defeq at default transparency.* guard_expr e =ₛ e' checks that e and e' are syntactically equal.* guard_expr e =ₐ e' checks that e and e' are alpha-equivalent.Both e and e' are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using isDefEqGuarded) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n\ndone succeeds iff there are no remaining goals.\n\nThe tactic sleep ms sleeps for ms milliseconds and does nothing.\nIt is used for debugging purposes only.\n\nstop is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as repeat sorry.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n\n"},"/Source-Files-and-Modules/#module-syntax":{"id":"/Source-Files-and-Modules/#module-syntax","header":"5.2. Concrete Syntax","context":"Lean Reference\u0009Source Files and Modules","contents":"Lean's concrete syntax is extensible.\nIn a language like Lean, it's not possible to completely describe the syntax once and for all, because libraries may define syntax in addition to new constants or inductive types.\nRather than completely describing the language here, the overall framework is described, while the syntax of each language construct is documented in the section to which it belongs.\n\n\n\n\n\n\n\n"}});