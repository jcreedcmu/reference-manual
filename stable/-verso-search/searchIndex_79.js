window.docContents[79].resolve({"/The-Type-System/Inductive-Types/#inductive-type-universe-levels":{"id":"/The-Type-System/Inductive-Types/#inductive-type-universe-levels","header":"4.4.3.2.1. Universe Levels","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Well-Formedness Requirements","contents":"Type constructors of inductive types must either inhabit a universe or a function type whose return type is a universe.\nEach constructor must inhabit a function type that returns a saturated application of the inductive type.\nIf the inductive type's universe is Prop, then there are no further restrictions on universes, because Prop is impredicative.\nIf the universe is not Prop, then the following must hold for each parameter to the constructor:\n\n* If the constructor's parameter is a parameter (in the sense of parameters vs indices) of the inductive type, then this parameter's type may be no larger than the type constructor's universe.* All other constructor parameters must be smaller than the type constructor's universe.\n\nUniverses, constructors, and parametersEither is in the greater of its arguments' universes, because both are parameters to the inductive type:inductive Either (α : Type u) (β : Type v) : Type (max u v) where\n  | inl : α → Either α β\n  | inr : β → Either α β\nCanRepr is in a larger universe than the constructor parameter α, because α is not one of the inductive type's parameters:inductive CanRepr : Type (u + 1) where\n  | mk : (α : Type u) → [Repr α] → CanRepr\nConstructorless inductive types may be in universes smaller than their parameters:inductive Spurious (α : Type 5) : Type 0 where\nIt would, however, be impossible to add a constructor to Spurious without changing its levels.\n\n"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Reasoning":{"id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference--Reasoning","header":"19.3.3.6. Reasoning","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers\u0009API Reference","contents":"Proves a statement by induction on the underlying Nat value in a Fin (n + 1).For the induction:* zero is the base case, demonstrating motive 0.* succ is the inductive step, assuming the motive for i : Fin n (lifted to Fin (n + 1) with\nFin.castSucc) and demonstrating it for i.succ.Fin.inductionOn is a version of this induction principle that takes the Fin as its first\nparameter, Fin.cases is the corresponding case analysis operator, and Fin.reverseInduction is a\nversion that starts at the greatest value instead of 0.\n\nProves a statement by induction on the underlying Nat value in a Fin (n + 1).For the induction:* zero is the base case, demonstrating motive 0.* succ is the inductive step, assuming the motive for i : Fin n (lifted to Fin (n + 1) with\nFin.castSucc) and demonstrating it for i.succ.Fin.induction is a version of this induction principle that takes the Fin as its last\nparameter.\n\nProves a statement by reverse induction on the underlying Nat value in a Fin (n + 1).For the induction:* last is the base case, demonstrating motive (Fin.last n).* cast is the inductive step, assuming the motive for (j : Fin n).succ and demonstrating it for\nthe predecessor j.castSucc.Fin.induction is the non-reverse induction principle.\n\nProves a statement by cases on the underlying Nat value in a Fin (n + 1).The two cases are:* zero, used when the value is of the form (0 : Fin (n + 1))* succ, used when the value is of the form (j : Fin n).succThe corresponding induction principle is Fin.induction.\n\nProves a statement by cases on the underlying Nat value in a Fin (n + 1), checking whether the\nvalue is the greatest representable or a predecessor of some other.The two cases are:* last, used when the value is Fin.last n* cast, used when the value is of the form (j : Fin n).succThe corresponding induction principle is Fin.reverseInduction.\n\nA case analysis operator for i : Fin (m + n) that separately handles the cases where i < m and\nwhere m ≤ i < m + n.The first case, where i < m, is handled by left. In this case, i can be represented as\nFin.castAdd n (j : Fin m).The second case, where m ≤ i < m + n, is handled by right. In this case, i can be represented\nas Fin.natAdd m (j : Fin n).\n\nAn induction principle for Fin that considers a given i : Fin n as given by a sequence of i\napplications of Fin.succ.The cases in the induction are:* zero demonstrates the motive for (0 : Fin (n + 1)) for all bounds n* succ demonstrates the motive for Fin.succ applied to an arbitrary Fin for an arbitrary\nbound nUnlike Fin.induction, the motive quantifies over the bound, and the bound varies at each inductive\nstep. Fin.succRecOn is a version of this induction principle that takes the Fin argument first.\n\nAn induction principle for Fin that considers a given i : Fin n as given by a sequence of i\napplications of Fin.succ.The cases in the induction are:* zero demonstrates the motive for (0 : Fin (n + 1)) for all bounds n* succ demonstrates the motive for Fin.succ applied to an arbitrary Fin for an arbitrary\nbound nUnlike Fin.induction, the motive quantifies over the bound, and the bound varies at each inductive\nstep. Fin.succRec is a version of this induction principle that takes the Fin argument last.\n\n"},"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference":{"id":"/Basic-Types/Finite-Natural-Numbers/#The-Lean-Language-Reference--Basic-Types--Finite-Natural-Numbers--API-Reference","header":"19.3.3. API Reference","context":"Lean Reference\u0009Basic Types\u0009Finite Natural Numbers","contents":"\n\n\n\n\n\n\n\n\n\n\n\n"}});