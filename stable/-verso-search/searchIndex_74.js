window.docContents[74].resolve({"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes":{"id":"/IO/Tasks-and-Threads/#The-Lean-Language-Reference--IO--Tasks-and-Threads--Communication-Between-Tasks--Mutexes","header":"15.11.6.2. Mutexes","context":"Lean Reference\u0009IO\u0009Tasks and Threads\u0009Communication Between Tasks","contents":"The types and functions in this section are available after importing Std.Sync.Mutex.\n\nMutual exclusion primitive (lock) guarding shared state of type α.The type Mutex α is similar to IO.Ref α, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n\nCreates a new mutex.\n\nmutex.atomically k runs k with access to the mutex's state while locking the mutex.Calling mutex.atomically while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nmutex.atomicallyOnce condvar pred k runs k, waiting on condvar until pred returns true.\nBoth k and pred have access to the mutex's state.Calling mutex.atomicallyOnce while already holding the underlying BaseMutex in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using RecursiveMutex.\n\nAtomicT α m is the monad that can be atomically executed inside mutual exclusion primitives like\nMutex α with outside monad m.\nThe action has access to the state α of the mutex (via get and set).\n\n"},"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters":{"id":"/Definitions/Headers-and-Signatures/#automatic-implicit-parameters","header":"7.2.4. Automatic Implicit Parameters","context":"Lean Reference\u0009Definitions\u0009Headers and Signatures","contents":"By default, otherwise-unbound names that occur in signatures are converted into implicit parameters when possible\nThese parameters are called automatic implicit parameters.\nThis is possible when they are not in the function position of an application and when there is sufficient information available in the signature to infer their type and any ordering constraints on them.\nThis process is iterated: if the inferred type for the freshly-inserted implicit parameter has dependencies that are not uniquely determined, then these dependencies are replaced with further implicit parameters.\n\nImplicit parameters that don't correspond to names written in signatures are assigned names akin to those of inaccessible hypotheses in proofs, which cannot be referred to.\nThey show up in signatures with a trailing dagger ('✝').\nThis prevents an arbitrary choice of name by Lean from becoming part of the API by being usable as a named argument.\n\nAutomatic Implicit ParametersIn this definition of map, α and β are not explicitly bound.\nRather than this being an error, they are converted into implicit parameters.\nBecause they must be types, but nothing constrains their universes, the universe parameters u and v are also inserted.def map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nThe full signature of map is:map.{u, v} {α : Type u} {β : Type v}\n  (f : α → β) (xs : List α) :\n  List β\n\n\nNo Automatic Implicit ParametersIn this definition, α and β are not explicitly bound.\nBecause autoImplicit is disabled, this is an error:set_option autoImplicit false\n\ndef map (f : α → β) : (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nunknown identifier 'α'\nunknown identifier 'β'\nThe full signature allows the definition to be accepted:set_option autoImplicit false\n\ndef map.{u, v} {α : Type u} {β : Type v}\n    (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\nUniverse parameters are inserted automatically for parameters without explicit type annotations.\nThe type parameters' universes can be inferred, and the appropriate universe parameters inserted, even when autoImplicit is disabled:set_option autoImplicit false\n\ndef map {α β} (f : α → β) :\n    (xs : List α) → List β\n  | [] => []\n  | x :: xs => f x :: map f xs\n\n\nIterated Automatic Implicit ParametersGiven a number bounded by n, represented by the type Fin n, an AtLeast i is a natural number paired with a proof that it is at least as large as i.structure AtLeast (i : Fin n) where\n  val : Nat\n  val_gt_i : val ≥ i.val\nThese numbers can be added:def AtLeast.add (x y : AtLeast i) : AtLeast i :=\n  AtLeast.mk (x.val + y.val) <| by\n    cases x\n    cases y\n    dsimp only\n    omega\nThe signature of AtLeast.add requires multiple rounds of automatic implicit parameter insertion.\nFirst, i is inserted; but its type depends on the upper bound n of Fin n.\nIn the second round, n is inserted, using a machine-chosen name.\nBecause n's type is Nat, which has no dependencies, the process terminates.\nThe final signature can be seen with #check:#check AtLeast.add\nAtLeast.add {n✝ : Nat} {i : Fin n✝} (x y : AtLeast i) : AtLeast i\n\n\nAutomatic implicit parameter insertion takes place after the insertion of parameters due to section variables.\nParameters that correspond to section variables have the same name as the corresponding variable, even when they do not correspond to a name written directly in the signature, and disabling automatic implicit parameters has no effect the parameters that correspond to section variables.\nHowever, when automatic implicit parameters are enabled, section variable declarations that contain otherwise-unbound variables receive additional section variables that follow the same rules as those for implicit parameters.\n\nAutomatic implicit parameters insertion is controlled by two options.\nBy default, automatic implicit parameter insertion is relaxed, which means that any unbound identifier may be a candidate for automatic insertion.\nSetting the option relaxedAutoImplicit to false disables relaxed mode and causes only identifiers that consist of a single character followed by zero or more digits to be considered for automatic insertion.\n\nWhen \"relaxed\" mode is enabled, any atomic nonempty identifier is eligible for auto bound implicit locals (see option autoImplicit).\n\nUnbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, def f (x : Vector α n) : Vector α n := automatically introduces the implicit variables {α n}.\n\nRelaxed vs Non-Relaxed Automatic Implicit ParametersMisspelled identifiers or missing imports can end up as unwanted implicit parameters, as in this example:inductive Answer where\n  | yes\n  | maybe\n  | no\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nThe resulting error message states that the argument's type is not a constant, so dot notation cannot be used in the pattern:Invalid dotted identifier notation: The expected type of `.yes`\n  Asnwer\nis not of the form `C ...` or `... → C ...` where C is a constant\nThis is because the signature is:select.{u_1, u_2}\n  {α : Type u_1}\n  {Asnwer : Sort u_2}\n  (choices : α × α × α) :\n  Asnwer → α\nDisabling relaxed automatic implicit parameters makes the error more clear, while still allowing the type to be inserted automatically:set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Asnwer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nunknown identifier 'Asnwer'\nCorrecting the error allows the definition to be accepted.set_option relaxedAutoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nTurning off automatic implicit parameters entirely leads to the definition being rejected:set_option autoImplicit false\n\ndef select (choices : α × α × α) : Answer →  α\n  | .yes => choices.1\n  | .maybe => choices.2.1\n  | .no => choices.2.2\nunknown identifier 'α'\n\n\n"},"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties":{"id":"/Basic-Types/Maps-and-Sets/#The-Lean-Language-Reference--Basic-Types--Maps-and-Sets--Tree-Based-Sets--Properties","header":"19.17.10.2. Properties","context":"Lean Reference\u0009Basic Types\u0009Maps and Sets\u0009Tree-Based Sets","contents":"Returns true if the tree set contains no mappings.\n\nReturns the number of mappings present in the map.\n\n"}});