window.docContents[40].resolve({"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model":{"contents":"Fixed-width integers may be unsigned or signed.\nFurthermore, they are available in five sizes: 8, 16, 32, and 64 bits, along with the current architecture's word size.\nIn their logical models, the unsigned integers are structures that wrap a BitVec of the appropriate width.\nSigned integers wrap the corresponding unsigned integers, and use a twos-complement representation.\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Fixed-Precision Integers","header":"19.4.1. Logical Model","id":"/Basic-Types/Fixed-Precision-Integers/#The-Lean-Language-Reference--Basic-Types--Fixed-Precision-Integers--Logical-Model"},"/Basic-Types/Natural-Numbers/#nat-runtime":{"contents":"The representation suggested by the declaration of Nat would be horrendously inefficient, as it's essentially a linked list.\nThe length of the list would be the number.\nWith this representation, addition would take time linear in the size of one of the addends, and numbers would take at least as many machine words as their magnitude in memory.\nThus, natural numbers have special support in both the kernel and the compiler that avoids this overhead.\n\nIn the kernel, there are special Nat literal values that use a widely-trusted, efficient arbitrary-precision integer library (usually GMP).\nBasic functions such as addition are overridden by primitives that use this representation.\nBecause they are part of the kernel, if these primitives did not correspond to their definitions as Lean functions, it could undermine soundness.\n\nIn compiled code, sufficiently-small natural numbers are represented without pointer indirections: the lowest-order bit in an object pointer is used to indicate that the value is not, in fact, a pointer, and the remaining bits are used to store the number.\n31 bits are available on 32-bits architectures for pointer-free Nats, while 63 bits are available on 64-bit architectures.\nIn other words, natural numbers smaller than 2^{31} = 2,147,483,648 or 2^{63} = 9,223,372,036,854,775,808 do not require allocations.\nIf an natural number is too large for this representation, it is instead allocated as an ordinary Lean object that consists of an object header and an arbitrary-precision integer value.\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Natural Numbers","header":"19.1.2. Run-Time Representation","id":"/Basic-Types/Natural-Numbers/#nat-runtime"},"/Build-Tools-and-Distribution/Lake/#lake-config":{"contents":"Lake offers two formats for package configuration files: TOML\n\nThe TOML configuration format is fully declarative.\n  Projects that don't include custom targets, facets, or scripts can use the TOML format.\n  Because TOML parsers are available for a wide variety of languages, using this format facilitates integration with tools that are not written in Lean.\n\n Lean\n\nThe Lean configuration format is more flexible and allows for custom targets, facets, and scripts.\n  It features an embedded domain-specific language for describing the declarative subset of configuration options that is available from the TOML format.\n  Additionally, the Lake API can be used to express build configurations that are outside of the possibilities of the declarative options.\n\nThe command translate-config can be used to automatically convert between the two formats.\n\nBoth formats are processed similarly by Lake, which extracts the package configuration from the configuration file in the form of internal structure types.\nWhen the package is configured, the resulting data structures are written to lakefile.olean in the build directory.\n\n\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake","header":"22.1.3. Configuration File Format","id":"/Build-Tools-and-Distribution/Lake/#lake-config"},"/Build-Tools-and-Distribution/Lake/#lake-facets":{"contents":"A facet describes the production of a target from another.\nConceptually, any target may have facets.\nHowever, executables, external libraries, and custom targets provide only a single implicit facet.\nPackages, libraries, and modules have multiple facets that can be requested by name when invoking build to select the corresponding target.\n\nWhen no facet is explicitly requested, but an initial target is designated, build produces the initial target's default facet.\nEach type of initial target has a corresponding default facet (e.g. producing an executable binary from an executable target or building a package's default targets); other facets may be explicitly requested in the package configuration or via Lake's command-line interface.\nLake's internal API may be used to write custom facets.\n\n\n\nThe facets available for packages are: extraDep\n\nThe default facets of the package's extra dependency targets, specified in the extraDepTargets field.\n\n deps\n\nThe package's direct dependencies.\n\n transDeps\n\nThe package's transitive dependencies, topologically sorted.\n\n optCache\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n cache\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optBarrel\n\nA package's optional cached build archive (e.g., from Reservoir or GitHub).\n  Will not cause the whole build to fail if the archive cannot be fetched.\n\n barrel\n\nA package's cached build archive (e.g., from Reservoir or GitHub).\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n optRelease\n\nA package's optional build archive from a GitHub release.\n  Will not cause the whole build to fail if the release cannot be fetched.\n\n release\n\nA package's build archive from a GitHub release.\n  Will cause the whole build to fail if the archive cannot be fetched.\n\n\n\n\n\nThe facets available for libraries are: leanArts\n\nThe artifacts that the Lean compiler produces for the library or executable (*.olean, *.ilean, and *.c files).\n\n static\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file).\n\n static.export\n\nThe static library produced by the C compiler from the leanArts (that is, a *.a file), with exported symbols.\n\n shared\n\nThe shared library produced by the C compiler from the leanArts (that is, a *.so, *.dll, or *.dylib file, depending on the platform).\n\n extraDep\n\nA Lean library's extraDepTargets and those of its package.\n\n\n\nExecutables have a single exe facet that consists of the executable binary.\n\n\n\nThe facets available for modules are: lean\n\nThe module's Lean source file.\n\n leanArts (default)\n\nThe module's Lean artifacts (*.olean, *.ilean, *.c files).\n\n deps\n\nThe module's dependencies (e.g., imports or shared libraries).\n\n olean\n\nThe module's .olean file. \n\n ilean\n\nThe module's .ilean file, which is metadata used by the Lean language server.\n\n header\n\nThe parsed module header of the module's source file.\n\n input\n\nThe module's processed Lean source file. Combines tracing the file with parsing its header.\n\n imports\n\nThe immediate imports of the Lean module, but not the full set of transitive imports. \n\n precompileImports\n\nThe transitive imports of the Lean module, compiled to object code.\n\n transImports\n\nThe transitive imports of the Lean module, as .olean files.\n\n allImports\n\nBoth the immediate and transitive imports of the Lean module.\n\n setup\n\nAll of a module's dependencies: transitive local imports and shared libraries to be loaded with --load-dynlib.\n  Returns the list of shared libraries to load along with their search path.\n\n ir\n\nThe .ir file produced by lean (with the experimental module system enabled).\n\n c\n\nThe C file produced by the Lean compiler.\n\n bc\n\nLLVM bitcode file, produced by the Lean compiler.\n\n c.o\n\nThe compiled object file, produced from the C file. On Windows, this is equivalent to .c.o.noexport, while it is equivalent to .c.o.export on other platforms.\n\n c.o.export\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n c.o.noexport\n\nThe compiled object file, produced from the C file, with Lean symbols exported.\n\n bc.o\n\nThe compiled object file, produced from the LLVM bitcode file.\n\n o\n\nThe compiled object file for the configured backend.\n\n dynlib\n\nA shared library (e.g., for the Lean option --load-dynlib).\n\n\n\n","context":"Lean Reference\u0009Build Tools\u0009Lake\u0009Concepts and Terminology","header":"22.1.1.2. Facets","id":"/Build-Tools-and-Distribution/Lake/#lake-facets"},"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties":{"contents":"The IO monad has many, many effects, and is used for writing programs that need to interact with the world.\nIt is described in its own section.\nPrograms that use IO are essentially black boxes: they are typically not particularly amenable to verification.\n\nMany algorithms are easiest to express with a much smaller set of effects.\nThese effects can often be simulated; for example, mutable state can be simulated by passing around a tuple that contains both the program's value and the state.\nThese simulated effects are easier to reason formally about, because they are defined using ordinary code rather than new language primitives.\n\nThe standard library provides abstractions for working with commonly-used effects.\nMany frequently-used effects fall into a small number of categories:\n\n State monads have mutable state\n\nComputations that have access to some data that may be modified by other parts of the computation use mutable state.\n  State can be implemented in a variety of ways, described in the section on state monads and captured in the MonadState type class.\n\n Reader monads are parameterized computations\n\nComputations that can read the value of some parameter provided by a context exist in most programming languages, but many languages that feature state and exceptions as first-class features do not have built-in facilities for defining new parameterized computations.\n  Typically, these computations are provided with a parameter value when invoked, and sometimes they can locally override it.\n  Parameter values have dynamic extent: the value provided most recently in the call stack is the one that is used.\n  They can be simulated by passing a value unchanged through a sequence of function calls; however, this technique can make code harder to read and introduces a risk that the values may be passed incorrectly to further calls by mistake.\n  They can also be simulated using mutable state with a careful discipline surrounding the modification of the state.\n  Monads that maintain a parameter, potentially allowing it to be overridden in a section of the call stack, are called reader monads.\n  Reader monads are captured in the MonadReader type class.\n  Additionally, reader monads that allow the parameter value to be locally overridden are captured in the MonadWithReader type class.\n\n Exception monads have exceptions\n\nComputations that may terminate early with an exceptional value use exceptions.\n  They are typically modeled with a sum type that has a constructor for ordinary termination and a constructor for early termination with errors.\n  Exception monads are described in the section on exception monads, and captured in the MonadExcept type class.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Functors, Monads and  do -Notation","header":"14.5. Varieties of Monads","id":"/Functors___-Monads-and--do--Notation/Varieties-of-Monads/#monad-varieties"},"/Interacting-with-Lean/#repr-instance-howto":{"contents":"Lean can produce an appropriate Repr instance for most types automatically using instance deriving.\nIn some cases, however, it's necessary to write an instance by hand:\n\n\n\n\n\nWhen writing a custom Repr instance, please follow these conventions:\n\n Precedence\n\nCheck precedence, adding parentheses as needed, and pass the correct precedence to the reprPrec instances of embedded data.\n  Each instance is responsible for surrounding itself in parentheses if needed; instances should generally not parenthesize recursive calls to reprPrec.Function application has the maximum precedence, max_prec.\n  The helpers Repr.addAppParen and reprArg respectively insert parentheses around applications when needed and pass the appropriate precedence to function arguments.\n\n Fully-Qualified Names\n\nA Repr instance does have access to the set of open namespaces in a given position.\n  All names of constants in the environment should be fully qualified to remove ambiguity.\n\n Default Nesting\n\nNested data should be indented using nestD to ensure consistent indentation across instances.\n\n Grouping and Line Breaks\n\nThe output of every Repr instance that includes line breaks should be surrounded in a group.\n  Furthermore, if the resulting code contains notional expressions that are nested, a group should be inserted around each nested level.\n  Line breaks should usually be inserted in the following positions:* Between a constructor and each of its arguments* After :=* After ,* Between the opening and closing braces of structure instance notation and its contents* After, but not before, an infix operator\n\n Parentheses and Brackets\n\nParentheses and brackets should be inserted using Std.Format.bracket or its specializations Std.Format.paren for parentheses and Std.Format.sbracket for square brackets.\n  These operators align the contents of the parenthesized or bracketed expression in the same way that Lean's do.\n  Trailing parentheses and brackets should not be placed on their own line, but rather stay with their contents.\n\n\n\nAdds parentheses to f if the precedence prec from the context is at least that of function\napplication.Together with reprArg, this can be used to correctly parenthesize function application\nsyntax.\n\nTurns a into a Format using its Repr instance, with the precedence level set to that of\nfunction application.Together with Repr.addAppParen, this can be used to correctly parenthesize function application\nsyntax.\n\nInductive Types with ConstructorsThe inductive type N.NatOrInt can contain a Nat or an Int:namespace N\n\ninductive NatOrInt where\n  | nat : Nat → NatOrInt\n  | int : Int → NatOrInt\n\nThe Repr NatOrInt instance adheres to the conventions:* The right-hand side is a function application, so it uses Repr.addAppParen to add parentheses if necessary.* Parentheses are wrapped around the entire body with no additional lines.* The entire function application is grouped, and it is nested the default amount.* The function is separated from its parameters by a use of line; this newline will usually be a space because the Repr Nat and Repr Int instances are unlikely to produce long output.* Recursive calls to reprPrec pass max_prec because they are in function parameter positions, and function application has the highest precedence.instance : Repr NatOrInt where\n  reprPrec\n    | .nat n =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.nat\" ++ .line ++ reprPrec n max_prec\n    | .int i =>\n      Repr.addAppParen <|\n        .group <| .nestD <|\n          \"N.NatOrInt.int\" ++ .line ++ reprPrec i max_prec\n#eval IO.println (repr (NatOrInt.nat 5))\nN.NatOrInt.nat 5\n#eval IO.println (repr (NatOrInt.int 5))\nN.NatOrInt.int 5\n#eval IO.println (repr (NatOrInt.int (-5)))\nN.NatOrInt.int (-5)\n#eval IO.println (repr (some (NatOrInt.int (-5))))\nsome (N.NatOrInt.int (-5))\n#eval IO.println (repr <| (List.range 10).map (NatOrInt.nat))\n[N.NatOrInt.nat 0,\n N.NatOrInt.nat 1,\n N.NatOrInt.nat 2,\n N.NatOrInt.nat 3,\n N.NatOrInt.nat 4,\n N.NatOrInt.nat 5,\n N.NatOrInt.nat 6,\n N.NatOrInt.nat 7,\n N.NatOrInt.nat 8,\n N.NatOrInt.nat 9]\n#eval IO.println <|\n  Std.Format.pretty (width := 3) <|\n    repr <| (List.range 10).map NatOrInt.nat\n[N.NatOrInt.nat\n   0,\n N.NatOrInt.nat\n   1,\n N.NatOrInt.nat\n   2,\n N.NatOrInt.nat\n   3,\n N.NatOrInt.nat\n   4,\n N.NatOrInt.nat\n   5,\n N.NatOrInt.nat\n   6,\n N.NatOrInt.nat\n   7,\n N.NatOrInt.nat\n   8,\n N.NatOrInt.nat\n   9]\n\n\nInfix SyntaxThis example demonstrates the use of precedences to encode a left-associative pretty printer.\nThe type AddExpr represents expressions with constants and addition:inductive AddExpr where\n  | nat : Nat → AddExpr\n  | add : AddExpr → AddExpr → AddExpr\nThe OfNat and Add instances provide a more convenient syntax for AddExpr:instance : OfNat AddExpr n where\n  ofNat := .nat n\n\ninstance : Add AddExpr where\n  add := .add\nThe Repr AddExpr instance should insert only the necessary parentheses.\nLean's addition operator is left-associative, with precedence 65, so the recursive call to the left uses precedence 64 and the operator itself is parenthesized if the current context has precedence greater than or equal to 65:protected def AddExpr.reprPrec : AddExpr → Nat → Std.Format\n  | .nat n, p  =>\n    Repr.reprPrec n p\n  | .add e1 e2, p =>\n    let out : Std.Format :=\n      .nestD <| .group <|\n        AddExpr.reprPrec e1 64 ++ \" \" ++ \"+\" ++ .line ++\n        AddExpr.reprPrec e2 65\n    if p ≥ 65 then out.paren else out\n\ninstance : Repr AddExpr := ⟨AddExpr.reprPrec⟩\nRegardless of the input's parenthesization, this instance inserts only the necessary parentheses:#eval IO.println (repr (((2 + 3) + 4) : AddExpr))\n2 + 3 + 4\n#eval IO.println (repr ((2 + 3 + 4) : AddExpr))\n2 + 3 + 4\n#eval IO.println (repr ((2 + (3 + 4)) : AddExpr))\n2 + (3 + 4)\n#eval IO.println (repr ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr))\n[2 + (3 + 4), 2 + 3 + 4]\nThe uses of group, nestD, and line in the implementation lead to the expected newlines and indentation in a narrow context:#eval ([2 + (3 + 4), (2 + 3) + 4] : List AddExpr)\n  |> repr\n  |>.pretty (width := 0)\n  |> IO.println\n[2 +\n   (3 +\n      4),\n 2 +\n     3 +\n   4]\n\n\n","context":"Lean Reference\u0009Interacting with Lean\u0009Formatted Output\u0009Repr","header":"3.7.2.1. How To Write a  Repr  Instance","id":"/Interacting-with-Lean/#repr-instance-howto"},"/releases/v4.15.0/#release-v4___15___0":{"contents":"Language* #4595 implements Simp.Config.implicitDefEqsProofs. When true\n(default: true), simp will not create a proof term for a\nrewriting rule associated with an rfl-theorem. Rewriting rules are\nprovided by users by annotating theorems with the attribute @[simp].\nIf the proof of the theorem is just rfl (reflexivity), and\nimplicitDefEqProofs := true, simp will not create a proof term\nwhich is an application of the annotated theorem.* #5429 avoid negative environment lookup* #5501 ensure instantiateMVarsProfiling adds a trace node* #5856 adds a feature to the the mutual def elaborator where the\ninstance command yields theorems instead of definitions when the class\nis a Prop.* #5907 unset trailing for simpa? \"try this\" suggestion* #5920 changes the rule for which projections become instances. Before,\nall parents along with all indirect ancestors that were represented as\nsubobject fields would have their projections become instances. Now only\nprojections for direct parents become instances.* #5934 make all_goals admit goals on failure* #5942 introduce synthetic atoms in bv_decide* #5945 adds a new definition Message.kind which returns the top-level\ntag of a message. This is serialized as the new field kind in\nSerialMessaege so that i can be used by external consumers (e.g.,\nLake) to identify messages via lean --json.* #5968 arg conv tactic misreported number of arguments on error* #5979 BitVec.twoPow in bv_decide* #5991 simplifies the implementation of omega.* #5992 fix style in bv_decide normalizer* #5999 adds configuration options for\ndecide/decide!/native_decide and refactors the tactics to be\nfrontends to the same backend. Adds a +revert option that cleans up\nthe local context and reverts all local variables the goal depends on,\nalong with indirect propositional hypotheses. Makes native_decide fail\nat elaboration time on failure without sacrificing performance (the\ndecision procedure is still evaluated just once). Now native_decide\nsupports universe polymorphism.* #6010 changes bv_decide's configuration from lots of set_option to\nan elaborated config like simp or omega. The notable exception is\nsat.solver which is still a set_option such that users can configure\na custom SAT solver globally for an entire project or file. Additionally\nit introduces the ability to set maxSteps for the simp preprocessing\nrun through the new config.* #6012 improves the validation of new syntactic tokens. Previously, the\nvalidation code had inconsistencies: some atoms would be accepted only\nif they had a leading space as a pretty printer hint. Additionally,\natoms with internal whitespace are no longer allowed.* #6016 removes the decide! tactic in favor of decide +kernel\n(breaking change).* #6019 removes @[specilize] from MkBinding.mkBinding, which is a\nfunction that cannot be specialized (as none of its arguments are\nfunctions). As a result, the specializable function Nat.foldRevM.loop\ndoesn't get specialized, which leads to worse performing code.* #6022 makes the change tactic and conv tactic use the same\nelaboration strategy. It works uniformly for both the target and local\nhypotheses. Now change can assign metavariables, for example:example (x y z : Nat) : x + y = z := by\n  change ?a = _\n  let w := ?a\n  -- now `w : Nat := x + y`\n* #6024 fixes a bug where the monad lift coercion elaborator would\npartially unify expressions even if they were not monads. This could be\ntaken advantage of to propagate information that could help elaboration\nmake progress, for example the first change worked because the monad\nlift coercion elaborator was unifying @Eq _ _ with @Eq (Nat × Nat) p:example (p : Nat × Nat) : p = p := by\n  change _ = ⟨_, _⟩ -- used to work (yielding `p = (p.fst, p.snd)`), now it doesn't\n  change ⟨_, _⟩ = _ -- never worked\nAs such, this is a breaking change; you may need to adjust expressions\nto include additional implicit arguments.* #6029 adds a normalization rule to bv_normalize (which is used by\nbv_decide) that converts x / 2^k into x >>> k under suitable\nconditions. This allows us to simplify the expensive division circuits\nthat are used for bitblasting into much cheaper shifting circuits.\nConcretely, it allows for the following canonicalization:* #6030 fixes simp only [· ∈ ·] after #5020.* #6035 introduces the and flattening pre processing pass from Bitwuzla\nto bv_decide. It splits hypotheses of the form (a && b) = true into\na = true and b = true which has synergy potential with the already\nexisting embedded constraint substitution pass.* #6037 fixes bv_decide's embedded constraint substitution to generate\ncorrect counter examples in the corner case where duplicate theorems are\nin the local context.* #6045 add LEAN_ALWAYS_INLINE to some functions* #6048 fixes simp? suggesting output with invalid indentation* #6051 mark Meta.Context.config as private* #6053 fixes the caching infrastructure for whnf and isDefEq,\nensuring the cache accounts for all relevant configuration flags. It\nalso cleans up the WHNF.lean module and improves the configuration of\nwhnf.* #6061 adds a simp_arith benchmark.* #6062 optimize Nat.Linear.Expr.toPoly* #6064 optimize Nat.Linear.Poly.norm* #6068 improves the asymptotic performance of simp_arith when there are many variables to consider.* #6077 adds options to bv_decide's configuration structure such that\nall non mandatory preprocessing passes can be disabled.* #6082 changes how the canonicalizer handles forall and lambda,\nreplacing bvars with temporary fvars. Fixes a bug reported by @hrmacbeth\non\nzulip.* #6093 use mkFreshUserName in ArgsPacker* #6096 improves the #print command for structures to show all fields\nand which parents the fields were inherited from, hiding internal\ndetails such as which parents are represented as subobjects. This\ninformation is still present in the constructor if needed. The pretty\nprinter for private constants is also improved, and it now handles\nprivate names from the current module like any other name; private names\nfrom other modules are made hygienic.* #6098 modifies Lean.MVarId.replaceTargetDefEq and\nLean.MVarId.replaceLocalDeclDefEq to use Expr.equal instead of\nExpr.eqv when determining whether the expression has changed. This is\njustified on the grounds that binder names and binder infos are\nuser-visible and affect elaboration.* #6105 fixes a stack overflow caused by a cyclic assignment in the\nmetavariable context. The cycle is unintentionally introduced by the\nstructure instance elaborator.* #6108 turn off pp.mvars in apply? results* #6109 fixes an issue in the injection tactic. This tactic may\nexecute multiple sub-tactics. If any of them fail, we must backtrack the\npartial assignment. This issue was causing the error: \"mvarId is\nalready assigned\" in issue #6066. The issue is not yet resolved, as the\nequation generator for the match expressions is failing in the example\nprovided in this issue.* #6112 makes stricter requirements for the @[deprecated] attribute,\nrequiring either a replacement identifier as @[deprecated bar] or\nsuggestion text @[deprecated \"Past its use by date\"], and also\nrequires a since := \"...\" field.* #6114 liberalizes atom rules by allowing '' to be a prefix of an\natom, after #6012 only added an exception for '' alone, and also adds\nsome unit tests for atom validation.* #6116 fixes a bug where structural recursion did not work when indices\nof the recursive argument appeared as function parameters in a different\norder than in the argument's type's definition.* #6125 adds support for structure in mutual blocks, allowing\ninductive types defined by inductive and structure to be mutually\nrecursive. The limitations are (1) that the parents in the extends\nclause must be defined before the mutual block and (2) mutually\nrecursive classes are not allowed (a limitation shared by class inductive). There are also improvements to universe level inference for\ninductive types and structures. Breaking change: structure parents now\nelaborate with the structure in scope (fix: use qualified names or\nrename the structure to avoid shadowing), and structure parents no\nlonger elaborate with autoimplicits enabled.* #6128 does the same fix as #6104, but such that it doesn't break the\ntest/the file in Plausible. This is done by not creating unused let\nbinders in metavariable types that are made by elimMVar. (This is also\na positive thing for users looking at metavariable types, for example in\nerror messages)* #6129 fixes a bug at isDefEq when zetaDelta := false. See new test\nfor a small example that exposes the issue.* #6131 fixes a bug at the definitional equality test (isDefEq). At\nunification constraints of the form c.{u} =?= c.{v}, it was not trying\nto unfold c. This bug did not affect the kernel.* #6141 make use of recursive structures in snapshot types* #6145 fixes the revert tactic so that it creates a syntheticOpaque\nmetavariable as the new goal, instead of a natural metavariable* #6146 fixes a non-termination bug that occurred when generating the\nmatch-expression splitter theorem. The bug was triggered when the proof\nautomation for the splitter theorem repeatedly applied injection to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6065 for an example that reproduces this issue.* #6165 modifies structure instance notation and where notation to use\nthe same notation for fields. Structure instance notation now admits\nbinders, type ascriptions, and equations, and where notation admits\nfull structure lvals. Examples of these for structure instance notation:structure PosFun where\n  f : Nat → Nat\n  pos : ∀ n, 0 < f n\n* #6168 extends the \"motive is not type correct\" error message for the\nrewrite tactic to explain what it means. It also pretty prints the\ntype-incorrect motive and reports the type error.* #6170 adds core metaprogramming functions for forking off background\ntasks from elaboration such that their results are visible to reporting\nand the language server* #6175 fixes a bug with the structure/class command where if there\nare parents that are not represented as subobjects but which used other\nparents as instances, then there would be a kernel error. Closes #2611.* #6180 fixes a non-termination bug that occurred when generating the\nmatch-expression equation theorems. The bug was triggered when the proof\nautomation for the equation theorem repeatedly applied injection( to\nthe same local declaration, as it could not be removed due to forward\ndependencies. See issue #6067 for an example that reproduces this issue.* #6189 changes how generalized field notation (\"dot notation\") resolves\nthe function. The new resolution rule is that if x : S, then x.f\nresolves the name S.f relative to the root namespace (hence it now\naffected by export and open). Breaking change: aliases now resolve\ndifferently. Before, if x : S, and if S.f is an alias for S'.f,\nthen x.f would use S'.f and look for an argument of type S'. Now,\nit looks for an argument of type S, which is more generally useful\nbehavior. Code making use of the old behavior should consider defining\nS or S' in terms of the other, since dot notation can unfold\ndefinitions during resolution.* #6206 makes it possible to write rw (occs := [1,2]) ... instead of\nrw (occs := .pos [1,2]) ... by adding a coercion from List.Nat to\nLean.Meta.Occurrences.* #6220 adds proper support for let_fun in simp.* #6236 fixes an issue where edits to a command containing a nested\ndocstring fail to reparse the entire command.Library* #4904 introduces date and time functionality to the Lean 4 Std.* #5616 is a follow-up to https://github.com/leanprover/lean4/pull/5609,\nwhere we add lemmas characterizing smtUDiv and smtSDiv's behavior\nwhen the denominator is zero.* #5866 verifies the keys function on Std.HashMap.* #5885 add Int16/Int32/Int64* #5926 add Option.or_some'* #5927 List.pmap_eq_self* #5937 upstream lemmas about Fin.foldX* #5938 upstream List.ofFn and relate to Array.ofFn* #5941 List.mapFinIdx, lemmas, relate to Array version* #5949 consolidate decide_True and decide_true_eq_true* #5950 relate Array.takeWhile with List.takeWhile* #5951 remove @[simp] from BitVec.ofFin_sub and sub_ofFin* #5952 relate Array.eraseIdx with List.eraseIdx* #5961 define ISize and basic operations on it* #5969 upstream List.insertIdx from Batteries, lemmas from Mathlib, and revise lemmas* #5970 deprecate Array.split in favour of identical Array.partition* #5971 relate Array.isPrefixOf with List.isPrefixOf* #5972 relate Array.zipWith/zip/unzip with List versions* #5974 add another List.find?_eq_some lemma* #5981 names the default SizeOf instance instSizeOfDefault* #5982 minor lemmas about List.ofFn* #5984 adds lemmas for List for the interactions between {foldl,\nfoldr, foldlM, foldlrM} and {filter, filterMap}.* #5985 relates the operations findSomeM?, findM?, findSome?, and\nfind? on Array with the corresponding operations on List, and also\nprovides simp lemmas for the Array operations findSomeRevM?,\nfindRevM?, findSomeRev?, findRev? (in terms of reverse and the\nusual forward find operations).* #5987 BitVec.getMsbD in bv_decide* #5988 changes the signature of Array.set to take a Nat, and a\ntactic-provided bound, rather than a Fin.* #5995 BitVec.sshiftRight' in bv_decide* #6007 List.modifyTailIdx naming fix* #6008 missing @[ext] attribute on monad transformer ext lemmas* #6023 variants of List.forIn_eq_foldlM* #6025 deprecate duplicated Fin.size_pos* #6032 changes the signature of Array.get to take a Nat and a proof,\nrather than a Fin, for consistency with the rest of the (planned)\nArray API. Note that because of bootstrapping issues we can't provide\nget_elem_tactic as an autoparameter for the proof. As users will\nmostly use the xs[i] notation provided by GetElem, this hopefully\nisn't a problem.* #6041 modifies the order of arguments for higher-order Array\nfunctions, preferring to put the Array last (besides positional\narguments with defaults). This is more consistent with the List API,\nand is more flexible, as dot notation allows two different partially\napplied versions.* #6049 adds a primitive for accessing the current thread ID* #6052 adds Array.pmap, as well as a @[csimp] lemma in terms of the\nno-copy Array.attachWith.* #6055 adds lemmas about for loops over Array, following the existing\nlemmas for List.* #6056 upstream some NameMap functions* #6060 implements conversion functions from Bool to all UIntX and\nIntX types.* #6070 adds the Lean.RArray data structure.* #6074 allow Sort u in Squash* #6094 adds raw transmutation of floating-point numbers to and from\nUInt64. Floats and UInts share the same endianness across all\nsupported platforms. The IEEE 754 standard precisely specifies the bit\nlayout of floats. Note that Float.toBits is distinct from\nFloat.toUInt64, which attempts to preserve the numeric value rather\nthan the bitwise value.* #6095 generalize List.get_mem* #6097 naming convention and NaN normalization* #6102 moves IO.rand and IO.setRandSeed to be in the BaseIO\nmonad.* #6106 fix naming of left/right injectivity lemmas* #6111 fills in the API for Array.findSome? and Array.find?,\ntransferring proofs from the corresponding List statements.* #6120 adds theorems BitVec.(getMsbD, msb)_(rotateLeft, rotateRight).* #6126 adds lemmas for extracting a given bit of a BitVec obtained\nvia sub/neg/sshiftRight'/abs.* #6130 adds Lean.loadPlugin which exposes functionality similar to\nthe lean executable's --plugin option to Lean code.* #6132 duplicates the verification API for\nList.attach/attachWith/pmap over to Array.* #6133 replaces Array.feraseIdx and Array.insertAt with\nArray.eraseIdx and Array.insertIdx, both of which take a Nat\nargument and a tactic-provided proof that it is in bounds. We also have\neraseIdxIfInBounds and insertIdxIfInBounds which are noops if the\nindex is out of bounds. We also provide a Fin valued version of\nArray.findIdx?. Together, these quite ergonomically improve the array\nindexing safety at a number of places in the compiler/elaborator.* #6136 fixes the run-time evaluation of (default : Float).* #6139 modifies the signature of the functions Nat.fold,\nNat.foldRev, Nat.any, Nat.all, so that the function is passed the\nupper bound. This allows us to change runtime array bounds checks to\ncompile time checks in many places.* #6148 adds a primitive for creating temporary directories, akin to the\nexisting functionality for creating temporary files.* #6149 completes the elementwise accessors for ofNatLt, allOnes,\nand not by adding their implementations of getMsbD.* #6151 completes the toInt interface for BitVec bitwise operations.* #6154 implements BitVec.toInt_abs.* #6155 adds toNat theorems for BitVec.signExtend.* #6157 adds toInt theorems for BitVec.signExtend.* #6160 adds theorem mod_eq_sub, makes theorem\nsub_mul_eq_mod_of_lt_of_le not private anymore and moves its location\nwithin the rotate* section to use it in other proofs.* #6184 uses Array.findFinIdx? in preference to Array.findIdx? where\nit allows converting a runtime bounds check to a compile time bounds\ncheck.* #6188 completes the toNat theorems for the bitwise operations\n(and, or, xor, shiftLeft, shiftRight) of the UInt types and\nadds toBitVec theorems as well. It also renames and_toNat to\ntoNat_and to fit with the current naming convention.* #6190 adds the builtin simproc USize.reduceToNat which reduces the\nUSize.toNat operation on literals less than UInt32.size (i.e.,\n4294967296).* #6191 adds Array.zipWithAll, and the basic lemmas relating it to\nList.zipWithAll.* #6192 adds deprecations for Lean.HashMap functions which did not\nreceive deprecation attributes initially.* #6193 completes the TODO in Init.Data.Array.BinSearch, removing the\npartial keyword and converting runtime bounds checks to compile time\nbounds checks.* #6194 changes the signature of Array.swap, so it takes Nat\narguments with tactic provided bounds checking. It also renames\nArray.swap! to Array.swapIfInBounds.* #6195 renames Array.setD to Array.setIfInBounds.* #6197 upstreams the definition of Vector from Batteries, along with\nthe basic functions.* #6200 upstreams Nat.lt_pow_self and Nat.lt_two_pow from Mathlib\nand uses them to prove the simp theorem Nat.mod_two_pow.* #6202 makes USize.toUInt64 a regular non-opaque definition.* #6203 adds the theorems le_usize_size and usize_size_le, which\nmake proving inequalities about USize.size easier.* #6205 upstreams some UInt theorems from Batteries and adds more\ntoNat-related theorems. It also adds the missing UInt8 and UInt16\nto/from USize conversions so that the the interface is uniform across\nthe UInt types.* #6207 ensures the Fin.foldl and Fin.foldr are semireducible.\nWithout this the defeq example (f : Fin 3 → ℕ) : List.ofFn f = [f 0, f 1, f 2] := rfl was failing.* #6208 fix Vector.indexOf?* #6217 adds simp lemmas about List's == operation.* #6221 fixes:* Problems in other linux distributions that the default tzdata\ndirectory is not the same as previously defined by ensuring it with a\nfallback behavior when directory is missing.* Trim unnecessary characters from local time identifier.* #6222 changes the definition of HashSet.insertMany and\nHashSet.Raw.insertMany so that it is equivalent to repeatedly calling\nHashSet.insert/HashSet.Raw.insert. It also clarifies the docstrings\nof all the insert and insertMany functions.* #6230 copies some lemmas about List.foldX to Array.* #6233 upstreams lemmas about Vector from Batteries.* #6234 upstreams the definition and basic lemmas about List.finRange\nfrom Batteries.* #6235 relates that operations Nat.fold/foldRev/any/all to the\ncorresponding List operations over List.finRange.* #6241 refactors Array.qsort to remove runtime array bounds checks,\nand avoids the use of partial. We use the Vector API, along with\nauto_params, to avoid having to write any proofs. The new code\nbenchmarks indistinguishably from the old.* #6242 deprecates Fin.ofNat in favour of Fin.ofNat' (which takes an\n[NeZero] instance, rather than returning an element of Fin (n+1)).* #6247 adds the theorems numBits_pos, le_numBits, numBits_le ,\nwhich make proving inequalities about System.Platform.numBits easier.Compiler* #5840 changes lean_sharecommon_{eq,hash} to only consider the\nsalient bytes of an object, and not any bytes of any\nunspecified/uninitialized unused capacity.* #6087 fixes a bug in the constant folding for the Nat.ble and\nNat.blt function in the old code generator, leading to a\nmiscompilation.* #6143 should make lean better-behaved around sanitizers, per\nhttps://github.com/google/sanitizers/issues/1688.\nAs far as I can tell,\nhttps://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn#algorithm\nreplaces local variables with heap allocations, and so taking the\naddress of a local is not effective at producing a monotonic measure of\nstack usage.* #6209 documents under which conditions Runtime.markPersistent is\nunsafe and adjusts the elaborator accordingly* #6257 harden markPersistent usesPretty Printing* #2934 adds the option pp.parens (default: false) that causes the\npretty printer to eagerly insert parentheses, which can be useful for\nteaching and for understanding the structure of expressions. For\nexample, it causes p → q → r to pretty print as p → (q → r).* #6014 prevents Nat.succ ?_ from pretty printing as ?_.succ, which\nshould make apply? be more usable.* #6085 improves the term info for coercions marked with\nCoeFnType.coeFun (such as DFunLike.coe in Mathlib), making \"go to\ndefinition\" on the function name work. Hovering over such a coerced\nfunction will show the coercee rather than the coercion expression. The\ncoercion expression can still be seen by hovering over the whitespace in\nthe function application.* #6096 improves the #print command for structures to show all fields\nand which parents the fields were inherited from, hiding internal\ndetails such as which parents are represented as subobjects. This\ninformation is still present in the constructor if needed. The pretty\nprinter for private constants is also improved, and it now handles\nprivate names from the current module like any other name; private names\nfrom other modules are made hygienic.* #6119 adds a new delab option pp.coercions.types which, when\nenabled, will display all coercions with an explicit type ascription.* #6161 ensures whitespace is printed before +opt and -opt\nconfiguration options when pretty printing, improving the experience of\ntactics such as simp?.* #6181 fixes a bug where the signature pretty printer would ignore the\ncurrent setting of pp.raw. This fixes an issue where #check ident\nwould not heed pp.raw. Closes #6090.* #6213 exposes the difference in \"synthesized type class instance is\nnot definitionally equal\" errors.Documentation* #6009 fixes a typo in the docstring for prec and makes the text\nslightly more precise.* #6040 join → flatten in docstring* #6110 does some mild refactoring of the Lean.Elab.StructInst module\nwhile adding documentation.* #6144 converts 3 doc-string to module docs since it seems that this is\nwhat they were intended to be!* #6150 refine kernel code comments* #6158 adjust file reference in Data.Sum* #6239 explains the order in which Expr.abstract introduces de Bruijn\nindices.Server* #5835 adds auto-completion for the fields of structure instance notation. Specifically, querying the completions via Ctrl+Space in the whitespace of a structure instance notation will now bring up the full list of fields. Whitespace structure completion can be enabled for custom syntax by wrapping the parser for the list of fields in a structInstFields parser.* #5837 fixes an old auto-completion bug where x. would issue\nnonsensical completions when x. could not be elaborated as a dot\ncompletion.* #5996 avoid max heartbeat error in completion* #6031 fixes a regression with go-to-definition and document highlight\nmisbehaving on tactic blocks.* #6246 fixes a performance issue where the Lean language server would\nwalk the full project file tree every time a file was saved, blocking\nthe processing of all other requests and notifications and significantly\nincreasing overall language server latency after saving.Lake* #5684 update toolchain on lake update* #6026 adds a newline at end of each Lean file generated by lake new\ntemplates.* #6218 makes Lake no longer automatically fetch GitHub cloud releases\nif the package build directory is already present (mirroring the\nbehavior of the Reservoir cache). This prevents the cache from\nclobbering existing prebuilt artifacts. Users can still manually fetch\nthe cache and clobber the build directory by running lake build <pkg>:release.* #6225 makes lake build also eagerly print package materialization\nlog lines. Previously, only a lake update performed eager logging.* #6231 improves the errors Lake produces when it fails to fetch a\ndependency from Reservoir. If the package is not indexed, it will\nproduce a suggestion about how to require it from GitHub.Other* #6137 adds support for displaying multiple threads in the trace\nprofiler output.* #6138 fixes trace.profiler.pp not using the term pretty printer.* #6259 ensures that nesting trace nodes are annotated with timing\ninformation iff trace.profiler is active.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.15.0 (2025-01-04)","id":"/releases/v4.15.0/#release-v4___15___0"},"/releases/v4.24.0/#release-v4___24___0":{"contents":"For this release, 377 changes landed. In addition to the 105 feature additions and 75 fixes listed below there were 25 refactoring changes, 9 documentation improvements, 21 performance improvements, 4 improvements to the test suite and 138 other changes.HighlightsLean 4.24.0 release brings continued improvements to the module system and the verification framework,\nstrengthens the grind tactic, and advances the standard library.\nThe release also introduces more efficient constructions of DecidableEq instances and noConfusion (#10152 and #10300),\noptimizing compilation.As an example for our continuous improvements to performance:* #10249 speeds up auto-completion by a factor of ~3.5x through various\nperformance improvements in the language server.As always, there are plenty of bug fixes and new features, some of which are listed below:\"Try this\" suggestions are rendered under 'Messages'* #9966 adjusts the \"try this\" widget to be rendered as a widget message\nunder 'Messages', not a separate widget under a 'Suggestions' section.\nThe main benefit of this is that the message of the widget is not\nduplicated between 'Messages' and 'Suggestions'.invariants and with sections in mvcgen* #9927 implements extended induction-inspired syntax for mvcgen,\nallowing optional invariants and with sections.The example below gives the proof that nodup correctly checks for duplicates in a list.import Std.Tactic.Do\nimport Std\n\nopen Std Do\n\ndef nodup (l : List Int) : Bool := Id.run do\n  let mut seen : HashSet Int := ∅\n  for x in l do\n    if x ∈ seen then\n      return false\n    seen := seen.insert x\n  return true\n\ntheorem nodup_correct (h : nodup l = r) : r = true ↔ l.Nodup := by\n  unfold nodup at h\n  apply Id.of_wp_run_eq h; clear h\n  mvcgen\n  invariants\n  · Invariant.withEarlyReturn\n      (onReturn := fun ret seen => ⌜ret = false ∧ ¬l.Nodup⌝)\n      (onContinue := fun xs seen =>\n        ⌜(∀ x, x ∈ seen ↔ x ∈ xs.prefix) ∧ xs.prefix.Nodup⌝)\n  with grind\nLibrary: Dyadic rationals* #9993 defines the dyadic rationals, showing they are an ordered ring\nembedding into the rationals.Grind AC solvergrind can reason about associative, commutative, idempotent, and/or unital operations\n(#10105, #10146, etc..):example (a b c : Nat) : max a (max b c) = max (max b 0) (max a c) := by\n  grind only\n\nexample {α} (as bs cs : List α) : as ++ (bs ++ cs) = ((as ++ []) ++ bs) ++ (cs ++ []) := by\n  grind only\n\nexample {α : Sort u} (op : α → α → α) (u : α) [Std.Associative op] [Std.Commutative op] [Std.IdempotentOp op] [Std.LawfulIdentity op u] (a b c : α)\n    : op (op a a) (op b c) = op (op (op b a) (op (op u b) b)) c := by\n  grind only\nMetaprogramming notes* #10306 fixes a few bugs in the rw tactic.Metaprogramming API: Instead of Lean.MVarId.rewrite prefer Lean.Elab.Tactic.elabRewrite\nfor elaborating rewrite theorems and applying rewrites to expressions.Breaking changes* #9749 refactors the Lake codebase to use the new module system\nthroughout. Every module in Lake is now a module.Breaking change: Since the module system encourages a private-by-default design,\nthe Lake API has switched from its previous public-by-default approach. As such,\nmany definitions that were previously public are now private. The newly private definitions\nare not expected to have had significant user use, nonetheless, important use cases could be missed.\nIf a key API is now inaccessible but seems like it should be public, users are encouraged\nto report this as an issue on GitHub.Language* #8891 improves the error message produced when passing (automatically\nredundant) local hypotheses to grind.* #9651 modifies the generation of induction and partial correctness\nlemmas for mutual blocks defined via partial_fixpoint. Additionally,\nthe generation of lattice-theoretic induction principles of functions\nvia mutual blocks is modified for consistency with partial_fixpoint.* #9674 cleans up optParam/autoParam/etc. annotations before\nelaborating definition bodies, theorem bodies, fun bodies, and let\nfunction bodies. Both variables and binders in declaration headers are\nsupported.* #9918 prevents rcases and obtain from creating absurdly long case\ntag names when taking single constructor types (like Exists) apart.\nFixes #6550* #9923 adds a guard for a delaborator that is causing panics in\ndoc-gen4. This is a band-aid solution for now, and @sgraf812 will take a\nlook when they're back from leave.* #9926 guards the Std.Tactic.Do.MGoalEntails delaborator by a check\nensuring that there are at least 3 arguments present, preventing\npotential panics.* #9927 implements extended induction-inspired syntax for mvcgen,\nallowing optional using invariants and with sections.* #9930 reverts the way grind cutsat embeds Nat.sub into Int. It\nfixes a regression reported by David Renshaw on Zulip.* #9938 removes a duplicate mpure_intro tactic definition.* #9939 expands mvcgen using invariants | $n => $t to mvcgen; case inv<$n> => exact $t to avoid MVar instantiation mishaps observable in\nthe test case for #9581.* #9942 modifies intro to create tactic info localized to each\nhypothesis, making it possible to see how intro works\nvariable-by-variable. Additionally:* The tactic supports intro rfl to introduce an equality and\nimmediately substitute it, like rintro rfl (recall: the rfl pattern\nis like doing intro h; subst h). The rintro tactic can also now\nsupport HEq in rfl patterns if eq_of_heq applies.* In intro (h : t), elaboration of t is interleaved with unification\nwith the type of h, which prevents default instances from causing\nunification to fail.* Tactics that change types of hypotheses (including intro (h : t),\ndelta, dsimp) now update the local instance cache.* #9945 optimizes the proof terms produced by grind cutsat. It removes\nunused entries from the context objects when generating the final proof,\nsignificantly reducing the amount of junk in the resulting terms.\nExample:/--\ntrace: [grind.debug.proof] fun h h_1 h_2 h_3 h_4 h_5 h_6 h_7 h_8 =>\n      let ctx := RArray.leaf (f 2);\n      let p_1 := Poly.add 1 0 (Poly.num 0);\n      let p_2 := Poly.add (-1) 0 (Poly.num 1);\n      let p_3 := Poly.num 1;\n      le_unsat ctx p_3 (eagerReduce (Eq.refl true)) (le_combine ctx p_2 p_1 p_3 (eagerReduce (Eq.refl true)) h_8 h_1)\n-/\n#guard_msgs in -- Context should contain only `f 2`\nopen Lean Int Linear in\nset_option trace.grind.debug.proof true in\nexample (f : Nat → Int) :\n    f 1 <= 0 → f 2 <= 0 → f 3 <= 0 → f 4 <= 0 → f 5 <= 0 →\n    f 6 <= 0 → f 7 <= 0 → f 8 <= 0 → -1 * f 2 + 1 <= 0 → False := by\n  grind\n* #9946 optimizes the proof terms produced by grind ring. It is\nsimilar to #9945, but for the ring module in grind.\nIt removes unused entries from the context objects when generating the\nfinal proof, significantly reducing the amount of junk in the resulting\nterms. Example:/--\ntrace: [grind.debug.proof] fun h h_1 h_2 h_3 =>\n      Classical.byContradiction fun h_4 =>\n        let ctx := RArray.branch 1 (RArray.leaf x) (RArray.leaf x⁻¹);\n        let e_1 := (Expr.var 0).mul (Expr.var 1);\n        let e_2 := Expr.num 0;\n        let e_3 := Expr.num 1;\n        let e_4 := (Expr.var 0).pow 2;\n        let m_1 := Mon.mult (Power.mk 1 1) Mon.unit;\n        let m_2 := Mon.mult (Power.mk 0 1) Mon.unit;\n        let p_1 := Poly.num (-1);\n        let p_2 := Poly.add (-1) (Mon.mult (Power.mk 0 1) Mon.unit) (Poly.num 0);\n        let p_3 := Poly.add 1 (Mon.mult (Power.mk 0 2) Mon.unit) (Poly.num 0);\n        let p_4 := Poly.add 1 (Mon.mult (Power.mk 0 1) (Mon.mult (Power.mk 1 1) Mon.unit)) (Poly.num (-1));\n        let p_5 := Poly.add 1 (Mon.mult (Power.mk 0 1) Mon.unit) (Poly.num 0);\n        one_eq_zero_unsat ctx p_1 (eagerReduce (Eq.refl true))\n          (Stepwise.simp ctx 1 p_4 (-1) m_1 p_5 p_1 (eagerReduce (Eq.refl true))\n            (Stepwise.core ctx e_1 e_3 p_4 (eagerReduce (Eq.refl true)) (diseq0_to_eq x h_4))\n            (Stepwise.mul ctx p_2 (-1) p_5 (eagerReduce (Eq.refl true))\n              (Stepwise.superpose ctx 1 m_2 p_4 (-1) m_1 p_3 p_2 (eagerReduce (Eq.refl true))\n                (Stepwise.core ctx e_1 e_3 p_4 (eagerReduce (Eq.refl true)) (diseq0_to_eq x h_4))\n                (Stepwise.core ctx e_4 e_2 p_3 (eagerReduce (Eq.refl true)) h))))\n-/\n#guard_msgs in -- Context should contains only `x` and its inverse.\nset_option trace.grind.debug.proof true in\nset_option pp.structureInstances false in\nopen Lean Grind CommRing in\nexample [Field α] (x y z w : α) :\n   x^2 = 0 → y^2 = 0 → z^3 = 0 → w^2 = 0 → x = 0 := by\n  grind\n* #9947 optimizes the proof terms produced by grind linarith. It is\nsimilar to #9945, but for the linarith module in grind.\nIt removes unused entries from the context objects when generating the\nfinal proof, significantly reducing the amount of junk in the resulting\nterms.* #9951 generates .ctorIdx functions for all inductive types, not just\nenumeration types. This can be a building block for other constructions\n(BEq, noConfusion) that are size-efficient even for large\ninductives.* #9952 adds “non-branching case statements”: For each inductive\nconstructor T.con this adds a function T.con.with that is similar\nT.casesOn, but has only one arm (the one for con), and an additional\nt.toCtorIdx = 12 assumption.* #9954 removes the option grind +ringNull. It provided an alternative\nproof term construction for the grind ring module, but it was less\neffective than the default proof construction mode and had effectively\nbecome dead code.\nalso optimizes semiring normalization proof terms using the\ninfrastructure added in #9946.\nRemark: After updating stage0, we can remove several background\ntheorems from the Init/Grind folder.* #9958 ensures that equations in the grind cutsat module are\nmaintained in solved form. That is, given an equation a*x + p = 0 used\nto eliminate x, the linear polynomial p must not contain other\neliminated variables. Before this PR, equations were maintained in\ntriangular form. We are going to use the solved form to linearize\nnonlinear terms.* #9968 modifies macros, which implement non-atomic definitions and\n$cmd1 in $cmd2 syntax. These macros involve implicit scopes,\nintroduced through section and namespace commands. Since\nsections or namespaces are designed to delimit local attributes, this\nhas led to unintuitive behaviour when applying local attributes to\ndefinitions appearing in the above-mentioned contexts. This has been\ncausing the following examples to fail:axiom A : Prop\n\n* #9974 registers a parser alias for Lean.Parser.Command.visibility.\nThis avoids having to import Lean.Parser.Command in simple command\nmacros that use visibilities.* #9980 fixes a bug in the dynamic variable reordering function used in\ngrind cutsat.* #9989 changes the new extended syntax for mvcgen to mvcgen invariants ... with ....* #9995 almost completely rewrites the inductive predicate recursion\nalgorithm; in particular IndPredBelow to function more consistently.\nHistorically, the brecOn generation through IndPredBelow has been\nvery error-prone -- this should be fixed now since the new algorithm is\nvery direct and doesn't rely on tactics or meta-variables at all.\nAdditionally, the new structural recursion procedure for inductive\npredicates shares more code with regular structural recursion and thus\nallows for mutual and nested recursion in the same way it was possible\nwith regular structural recursion. For example, the following works now:mutual\n\n* #9996 improves support for nonlinear monomials in grind cutsat. For\nexample, given a monomial a * b, if cutsat discovers that a = 2,\nit now propagates that a * b = 2 * b.\nRecall that nonlinear monomials like a * b are treated as variables in\ncutsat, a procedure designed for linear integer arithmetic.* #10007 lets #print print private before protected, matching the\nsyntax.* #10008 fixes a bug in #eval where clicking on the evaluated\nexpression could show errors in the Infoview. This was caused by #eval\nnot saving the temporary environment that is used when elaborating the\nexpression.* #10010 improves support for nonlinear / and % in grind cutsat.\nFor example, given a / b, if cutsat discovers that b = 2, it now\npropagates that a / b = b / 2. is similar to #9996, but for\n/ and %. Example:example (a b c d : Nat)\n    : b > 1 → d = 1 → b ≤ d + 1 → a % b = 1 → a = 2 * c → False := by\n  grind\n* #10020 fixes a missing case for PR #10010.* #10021 make some minor changes to the grind annotation analysis script,\nincluding sorting results and handling errors. Still need to add an\nexternal UI.* #10022 improves support for Fin n in grind cutsat when n is not a\nnumeral. For example, the following goals can now be solved\nautomatically:example (p d : Nat) (n : Fin (p + 1))\n    : 2 ≤ p → p ≤ d + 1 → d = 1 → n = 0 ∨ n = 1 ∨ n = 2 := by\n  grind\n\n* #10034 changes the \"declaration uses 'sorry'\" error to pretty print an\nactual sorry expression in the message. The effect is that the sorry\nis hoverable and, if it's labeled, you can \"go to definition\" to see\nwhere it came from.* #10038 ensures grind error messages use {.ofConstName declName}\nwhen referencing declaration names.* #10060 allows for more fine-grained control over what derived instances\nhave exposed definitions under the module system: handlers should not\nexpose their implementation unless either the deriving item or a\nsurrounding section is marked with @[expose]. Built-in handlers to be\nupdated after a stage 0 update.* #10069 adds helper theorems to support NatModule in grind linarith.* #10071 improves support for a^n in grind cutsat. For example, if\ncutsat discovers that a and b are equal to numerals, it now\npropagates the equality. is similar to #9996, but a^b.\nExample:example (n : Nat) : n = 2 → 2 ^ (n+1) = 8 := by\n  grind\n* #10085 adds a parser alias for the rawIdent parser, so that it can be\nused in syntax declarations in Init.* #10093 adds background theorems for a new solver to be implemented in\ngrind that will support associative and commutative operators.* #10095 modifies the grind algebra typeclasses to use SMul x y\ninstead of HMul x y y.* #10105 adds support for detecting associative operators in grind. The\nnew AC module also detects whether the operator is commutative,\nidempotent, and whether it has a neutral element. The information is\ncached.* #10113 deprecates .toCtorIdx for the more naturally named .ctorIdx\n(and updates the standard library).* #10120 fixes an issue where private definitions recursively invoked\nusing generalized field notation (dot notation) would give an \"invalid\nfield\" errors. It also fixes an issue where \"invalid field notation\"\nerrors would pretty print the name of the declaration with a _private\nprefix.* #10125 allows #guard_msgs to report the relative positions of logged\nmessages with the config option (positions := true).* #10129 replaces the interim order typeclasses used by Grind with the\nnew publicly available classes in Std.* #10134 makes the generation of functional induction principles more\nrobust when the user let-binds a variable that is then match'ed on.\nFixes #10132.* #10135 lets the ctorIdx definition for single constructor inductives\navoid the pointless .casesOn, and uses macro_inline to avoid\ncompiling the function and wasting symbols.* #10141 reverts the macro_inline part of #10135.* #10144 changes the construction of a CompleteLattice instance on\npredicates (maps intro Prop) inside of\ncoinductive_fixpoint/inductive_fixpoint machinery.* #10146 implements the basic infrastructure for the new procedure\nhandling AC operators in grind. It already supports normalizing\ndisequalities. Future PRs will add support for simplification using\nequalities, and computing critical pairs. Examples:example {α : Sort u} (op : α → α → α) [Std.Associative op] (a b c : α)\n    : op a (op b c) = op (op a b) c := by\n  grind only\n\n* #10151 ensures where finally tactics can access private data under\nthe module system even when the corresponding holes are in the public\nscope as long as all of them are of proposition types.* #10152 introduces an alternative construction for DecidableEq\ninstances that avoids the quadratic overhead of the default\nconstruction.* #10166 reviews the expected-to-fail-right-now tests for grind, moving\nsome (now passing) tests to the main test suite, updating some tests,\nand adding some tests about normalisation of exponents.* #10177 fixes a bug in the grind preprocessor exposed by #10160.* #10179 fixes grind instance normalization procedure.\nSome modules in grind use builtin instances defined directly in core\n(e.g., cutsat), while others synthesize them using synthInstance\n(e.g., ring). This inconsistency is problematic, as it may introduce\nmismatches and result in two different representations for the same\nterm. fixes the issue.* #10183 lets match equations be proved by rfl if possible, instead of\nexplicitly unfolding the LHS first. May lead to smaller proofs.* #10185 documents all grind attribute modifiers (e.g., =, usr,\next, etc).* #10186 adds supports for simplifying disequalities in the grind ac\nmodule.* #10189 implements the proof terms for the new grind ac module.\nExamples:example {α : Sort u} (op : α → α → α) [Std.Associative op] (a b c d : α)\n    : op a (op b b) = op c d → op c (op d c) = op (op a b) (op b c) := by\n  grind only\n\n* #10205 adds superposition for associative and commutative operators in\ngrind ac. Examples:example (a b c d e f g h : Nat) :\n    max a b = max c d → max b e = max d f → max b g = max d h →\n    max (max f d) (max c g) = max (max e (max d (max b (max c e)))) h := by\n  grind -cutsat only\n\n* #10206 adds superposition for associative (but non-commutative)\noperators in grind ac. Examples:example {α} (op : α → α → α) [Std.Associative op] (a b c d : α)\n   : op a b = c →\n     op b a = d →\n     op (op c a) (op b c) = op (op a d) (op d b) := by\n  grind\n\n* #10208 adds the extra critical pairs to ensure the grind ac procedure\nis complete when the operator is AC and idempotent. Example:example {α : Sort u} (op : α → α → α) [Std.Associative op] [Std.Commutative op] [Std.IdempotentOp op]\n      (a b c d : α) : op a (op b b) = op d c → op (op b a) (op b c) = op c (op d c)  := by\n  grind only\n* #10221 adds the extra critical pairs to ensure the grind ac procedure\nis complete when the operator is associative and idempotent, but not\ncommutative. Example:example {α : Sort u} (op : α → α → α) [Std.Associative op] [Std.IdempotentOp op] (a b c d e f x y w : α)\n    : op d (op x c) = op a b →\n      op e (op f (op y w)) = op a (op b c) →\n      op d (op x c) = op e (op f (op y w)) := by\n  grind only\n\n* #10223 implements equality propagation from the new AC module into the\ngrind core. Examples:example {α β : Sort u} (f : α → β) (op : α → α → α) [Std.Associative op] [Std.Commutative op]\n    (a b c d : α) : op a (op b b) = op d c → f (op (op b a) (op b c)) = f (op c (op d c)) := by\n  grind only\n\n* #10230 adds MonoBind for more monad transformers. This allows using\npartial_fixpoint for more complicated monads based on Option and\nEIO. Example:abbrev M := ReaderT String (StateT String.Pos Option)\n\n* #10237 fixes a missing case in the grind canonicalizer. Some types\nmay include terms or propositions that are internalized later in the\ngrind state.* #10239 fixes the E-matching procedure for theorems that contain\nuniverse parameters not referenced by any regular parameter. This kind\nof theorem seldom happens in practice, but we do have instances in the\nstandard library. Example:@[simp, grind =] theorem Std.Do.SPred.down_pure {φ : Prop} : (⌜φ⌝ : SPred []).down = φ := rfl\n* #10241 adds some test cases for grind working with Fin. There are\nmany still failing tests in tests/lean/grind/grind_fin.lean which I'm\nintending to triage and work on.* #10245 changes the implementation of a function unfoldPredRel used in\n(co)inductive predicate machinery, that unfolds pointwise order on\npredicates to quantifications and implications. Previous implementation\nrelied on withDeclsDND that could not deal with types which depend on\neach other. This caused the following example to fail:inductive infSeq_functor1.{u} {α : Type u} (r : α → α → Prop) (call : {α : Type u} → (r : α → α → Prop) → α → Prop) : α → Prop where\n  | step : r a b → infSeq_functor1 r call b → infSeq_functor1 r call a\n\n* #10265 fixes a panic in grind ring exposed by #10242. grind ring\nshould not assume that all normalizations have been applied, because\nsome subterms cannot be rewritten by simp due to typing constraints.\nMoreover, grind uses preprocessLight in a few places, and it skips\nthe simplifier/normalizer.* #10267 implements the infrastructure for supporting NatModule in\ngrind linarith and uses it to handle disequalities. Another PR will\nadd support for equalities and inequalities. Example:open Lean Grind\nvariable (M : Type) [NatModule M] [AddRightCancel M]\n\n* #10269 changes the string interpolation procedure to omit redundant\nempty parts. For example s!\"{1}{2}\" previously elaborated to toString \"\" ++ toString 1 ++ toString \"\" ++ toString 2 ++ toString \"\" and now\nelaborates to toString 1 ++ toString 2.* #10271 changes the naming of the internal functions in deriving\ninstances like BEq to use accessible names. This is necessary to\nreasonably easily prove things about these functions. For example after\nderiving BEq for a type T, the implementation of instBEqT is in\ninstBEqT.beq.* #10273 tries to do the right thing about the visibility of the\nsame-ctor-match-construct.* #10274 changes the implementation of the linear DecidableEq\nimplementation to use match decEq rather than if h :  to compare the\nconstructor tags. Otherwise, the “smart unfolding” machinery will not\nlet rfl decide that different constructors are different.* #10277 adds the missing instances IsPartialOrder, IsLinearPreorder\nand IsLinearOrder for OfNatModule.Q α.* #10278 adds support for NatModule equalities and inequalities in\ngrind linarith. Examples:open Lean Grind Std\n\n* #10280 adds the auxiliary theorem Lean.Grind.Linarith.eq_normN for\nnormalizing NatModule equations when the instance AddRightCancel is\nnot available.* #10281 implements NatModule normalization when the AddRightCancel\ninstance is not available. Note that in this case, the embedding into\nIntModule is not injective. Therefore, we use a custom normalizer,\nsimilar to the CommSemiring normalizer used in the grind ring\nmodule. Example:open Lean Grind\nexample [NatModule α] (a b c : α)\n    : 2•a + 2•(b + 2•c) + 3•a = 4•a + c + 2•b + 3•c + a := by\n  grind\n* #10282 improves the counterexamples produced by grind linarith for\nNatModules. grind now hides occurrences of the auxiliary function\nGrind.IntModule.OfNatModule.toQ.* #10283 implements diagnostic information for the grind ac module. It\nnow displays the basis, normalized disequalities, and additional\nproperties detected for each associative operator.* #10290 adds infrastructure for registering new grind solvers. grind\nalready includes many solvers, and this PR is the first step toward\nmodularizing the design and supporting user-defined solvers.* #10294 completes the grind solver extension design and ports the\ngrind ac solver to the new framework. Future PRs will document the API\nand port the remaining solvers. An additional benefit of the new design\nis faster build times.* #10296 fixes a bug in an auxiliary function used to construct proof\nterms in grind cutsat.* #10300 offers an alternative noConfusion construction for the\noff-diagonal use (i.e. for different constructors), based on comparing\nthe .ctorIdx. This should lead to faster type checking, as the kernel\nonly has to reduce .ctorIdx twice, instead of the complicate\nnoConfusionType construction.* #10301 exposes ctorIdx and per-constructor eliminators. Fixes #10299.* #10306 fixes a few bugs in the rw tactic: it could \"steal\" goals\nbecause they appear in the type of the rewrite, it did not do an occurs\ncheck, and new proof goals would not be synthetic opaque. also\nlets the rfl tactic assign synthetic opaque metavariables so that it\nis equivalent to exact rfl.* #10307 upstreams the Verso parser and adds preliminary support for\nVerso in docstrings. This will allow the compiler to check examples and\ncross-references in documentation.* #10309 modifies the simpa tactic so that in simpa ... using e there\nis tactic info on the range simpa ... using that shows the simplified\ngoal.* #10313 adds missing grind normalization rules for natCast and\nintCast Examples:open Lean.Grind\nvariable (R : Type) (a b : R)\n\n* #10314 skips model based theory combination on instances.* #10315 adds T.ctor.noConfusion declarations, which are\nspecializations of T.noConfusion to equalities between T.ctor. The\npoint is to avoid reducing the T.noConfusionType construction every\ntime we use injection or a similar tactic.* #10316 shares common functionality relate to equalities between same\nconstructors, and when these are type-correct. In particular it uses the\nmore complete logic from mkInjectivityThm also in other places, such\nas CasesOnSameCtor and the deriving code for BEq, DecidableEq,\nOrd, for more consistency and better error messages.* #10321 ensures that the auxiliary temporary metavariable IDs created by\nthe E-matching module used in grind are not affected by what has been\nexecuted before invoking grind. The goal is to increase grind’s\nrobustness.* #10322 introduces limited functionality frontends cutsat and\ngrobner for grind. We disable theorem instantiation (and case\nsplitting for grobner), and turn off all other solvers. Both still\nallow grind configuration options, so for example one can use cutsat +ring (or grobner +cutsat) to solve problems that require both.* #10323 fixes the grind canonicalizer for OfNat.ofNat applications.\nExample:example {C : Type} (h : Fin 2 → C) :\n    -- `0` in the first `OfNat.ofNat` is not a raw literal\n    h (@OfNat.ofNat (Fin (1 + 1)) 0 Fin.instOfNat) = h 0 := by\n  grind\n* #10324 disables an unused instance that causes expensive typeclass\nsearches.* #10325 implements model-based theory combination for types A which\nimplement the ToInt interface. Examples:example {C : Type} (h : Fin 4 → C) (x : Fin 4)\n    : 3 ≤ x → x ≤ 3 → h x = h (-1) := by\n  grind\n\n* #10326 fixes a performance issue in grind linarith. It was creating\nunnecessary NatModule/IntModule structures for commutative rings\nwithout an order. This kind of type should be handled by grind ring\nonly.* #10331 implements mkNoConfusionImp in Lean rather than in C. This\nreduces our reliance on C, and may bring performance benefits from not\nreducing noConfusionType during elaboration time (it still gets\nreduced by the kernel when type-checking).* #10332 ensures that the infotree recognizes Classical.propDecidable\nas an instance, when below a classical tactic.* #10335 fixes the nested proof term detection in grind. It must check\nwhether the gadget Grind.nestedProof is over-applied.* #10342 implements a new E-matching pattern inference procedure that is\nfaithful to the behavior documented in the reference manual regarding\nminimal indexable subexpressions. The old inference procedure was\nfailing to enforce this condition. For example, the manual documents\n[grind ->] as follows* #10373 adds a pp.unicode option and a unicode(\"→\", \"->\") syntax\ndescription alias for the lower-level unicodeSymbol \"→\" \"->\" parser.\nThe syntax is added to the notation command as well. When pp.unicode\nis true (the default) then the first form is used when pretty printing,\nand otherwise the second ASCII form is used. A variant, unicode(\"→\", \"->\", preserveForPP) causes the -> form to be preferred; delaborators\ncan insert → directly into the syntax, which will be pretty printed\nas-is; this allows notations like fun to use custom options such as\npp.unicode.fun to opt into the unicode form when pretty printing.Library* #7858 implements the fast circuit for overflow detection in unsigned\nmultiplication used by Bitwuzla and proposed in:\nhttps://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=987767* #9127 makes saveModuleData throw an IO.Error instead of panicking,\nif given something that cannot be serialized. This doesn't really matter\nfor saving modules, but is handy when writing tools to save auxiliary\ndate in olean files via Batteries' pickle.* #9560 fixes the forIn function, that previously caused the resulting\nPromise to be dropped without a value when an exception was thrown\ninside of it. It also corrects the parameter order of the background\nfunction.* #9599 adds the type Std.Internal.Parsec.Error, which contains the\nconstructors .eof (useful for checking if parsing failed due to not\nhaving enough input and then retrying when more input arrives that is\nuseful in the HTTP server) and .other, which describes other errors.\nIt also adds documentation to many functions, along with some new\nfunctions to the ByteArray Parsec, such as peekWhen?, octDigit,\ntakeWhile, takeUntil, skipWhile, and skipUntil.* #9632 adds lemmas for the TreeMap operations filter, map and\nfilterMap. These lemmas existed already for hash maps and are simply\nported over from there.* #9685 verifies toArray and related functions for hashmaps.* #9797 provides the means to quickly provide all the order instances\nassociated with some high-level order structure (preorder, partial\norder, linear preorder, linear order). This can be done via the factory\nfunctions PreorderPackage.ofLE, PartialOrderPackage.ofLE,\nLinearPreorderPackage.ofLE and LinearOrderPackage.ofLE.* #9908 makes IsPreorder, IsPartialOrder, IsLinearPreorder and\nIsLinearOrder extend BEq and Ord as appropriate, adds the\nLawfulOrderBEq and LawfulOrderOrd typeclasses relating BEq and\nOrd to LE, and adds many lemmas and instances.* #9916 provides factories that derive order typeclasses in bulk, given\nan Ord instance. If present, existing instances are preferred over\nthose derived from Ord. It is possible to specify any instance\nmanually if desired.* #9924 fixes examples in the documentation for PostCond.* #9931 implements Std.Do.Triple.mp, enabling users to compose two\nspecifications for the same program.* #9949 allows most of the List.lookup lemmas to be used when\nLawfulBEq α is not available.* #9957 upstreams the definition of Rat from Batteries, for use in our\nplanned interval arithmetic tactic.* #9967 removes local Triple notation from SpecLemmas.lean to work\naround a bug that breaks the stage2 build.* #9979 replaces Std.Internal.Rat with the new public Rat upstreamed\nfrom Batteries.* #9987 improves the tactic for proving that elements of a Nat-based\nPRange are in-bounds by relying on the omega tactic.* #9993 defines the dyadic rationals, showing they are an ordered ring\nembedding into the rationals. We will use this for future interval\narithmetic tactics.* #9999 reduces the number of Nat.Bitwise grind annotations we have\nthe deal with distributivity. The new smaller set encourages grind to\nrewrite into DNF. The old behaviour just resulted in saturating up to\nthe instantiation limits.* #10000 removes a grind annotation that fired on all Option.maps,\ncausing an avalanche of instantiations.* #10005 shortens the work necessary to make a type compatible with the\npolymorphic range notation. In the concrete case of Nat, it reduces\nthe required lines of code from 150 to 70.* #10015 exposes the bodies of Name.append, Name.appendCore, and\nName.hasMacroScopes. This enables proof by reflection of the\nconcatenation of name literals when using the module system.* #10018 derives BEq and Hashable for Lean.Import. Lake already did\nthis later, but it now done when defining Import.* #10019 adds @[expose] to Lean.ParserState.setPos. This makes it\npossible to prove in-boundedness for a state produced by setPos for\nfunctions like next' and get' without needing to import all.* #10024 adds useful declarations to the LawfulOrderMin/Max and\nLawfulOrderLeftLeaningMin/Max API. In particular, it introduces\n.leftLeaningOfLE factories for Min and Max. It also renames\nLawfulOrderMin/Max.of_le to .of_le_min_iffand.of_max_le_iff` and\nintroduces a second variant with different arguments.* #10045 implements the necessary typeclasses so that range notation\nworks for integers. For example, ((-2)...3).toList = [-2, -1, 0, 1, 2] : List Int.* #10049 adds some background material needed for introducing the dyadic\nrationals in #9993.* #10050 fixes some naming issues in Data/Rat/Lemmas, and upstreams the\neliminator numDenCasesOn and its relatives.* #10059 improves the names of definitions and lemmas in the polymorphic\nrange API. It also introduces a recommended spelling. For example, a\nleft-closed, right-open range is spelled Rco in analogy with Mathlib's\nIco intervals.* #10075 contains lemmas about Int (minor amendments for BitVec and\nNat) that are being used in preparing the dyadics. This is all work of\n@Rob23oba, which I'm pulling out of #9993 early to keep that one\nmanageable.* #10077 upstreams lemmas about Rat from Mathlib.Data.Rat.Defs and\nMathlib.Algebra.Order.Ring.Unbundled.Rat, specifically enough to get\nLean.Grind.Field Rat and Lean.Grind.OrderedRing Rat. In addition to\nthe lemmas, instances for Inv Rat, Pow Rat Nat and Pow Rat Int\nhave been upstreamed.* #10107 adds the Lean.Grind.AddCommGroup instance for Rat.* #10138 adds lemmas about the Dyadic.roundUp and Dyadic.roundDown\noperations.* #10159 adds nodup_keys lemmas as corollaries of existing\ndistinct_keys to all Map variants.* #10162 removes grind → annotations that fire too often, unhelpfully.\nIt would be nice for grind to instantiate these lemmas, but only if\nthey already see xs ++ ys and #[] in the same equivalence class, not\njust as soon as it sees xs ++ ys.* #10163 removes some (hopefully) unnecessary grind annotations that\ncause instantiation explosions.* #10173 removes the extends Monad from MonadAwait and MonadAsync\nto avoid underdetermined instances.* #10182 adds lemmas about Nat.fold and Nat.foldRev on sums, to match\nthe existing theorems about dfold and dfoldRev.* #10194 adds the inverse of a dyadic rational, at a given precision, and\ncharacterising lemmas. Also cleans up various parts of the Int.DivMod\nand Rat APIs, and proves some characterising lemmas about\nRat.toDyadic.* #10216 fixes #10193.* #10224 generalizes the monadic operations for HashMap, TreeMap, and\nHashSet to work for m : Type u → Type v.* #10227 adds @[grind] annotations (nearly all @[grind =] annotations\nparallel to existing @[simp]s) for ReaderT, StateT, ExceptT.* #10244 adds more lemmas about the toList and toArray functions on\nranges and iterators. It also renames Array.mem_toArray into\nList.mem_toArray.* #10247 adds missing the lemmas ofList_eq_insertMany_empty,\nget?_eq_some_iff, getElem?_eq_some_iff and getKey?_eq_some_iff to\nall container types.* #10250 fixes a bug in the LinearOrderPackage.ofOrd factory. If there\nis a LawfulEqOrd instance available, it should automatically use it\ninstead of requiring the user to provide the eq_of_compare argument to\nthe factory. The PR also solves a hygiene-related problem making the\nfactories fail when Std is not open.* #10303 adds range support toBitVec and the UInt* types. This means\nthat it is now possible to write, for example, for i in (1 : UInt8)...5 do, in order to loop over the values 1, 2, 3 and 4 of type UInt8.* #10341 moves the definitions and basic facts about Function.Injective\nand Function.Surjective up from Mathlib. We can do a better job of\narguing via injectivity in grind if these are available.Compiler* #9631 makes IO.RealWorld opaque. It also adds a new compiler -only\nlcRealWorld constant to represent this type within the compiler. By\ndefault, an opaque type definition is treated like lcAny, whereas we\nwant a more efficient representation. At the moment, this isn't a big\ndifference, but in the future we would like to completely erase\nIO.RealWorld at runtime.* #9922 changes internalizeCode to replace all substitutions with\nnon-param-bound fvars in Exprs (which are all types) with lcAny,\npreserving the invariant that there are no such dependencies. The\nviolation of this invariant across files caused test failures in a\npending PR, but it is difficult to write a direct test for it. In the\nfuture, we should probably change the LCNF checker to detect this.* #9972 fixes an issue when running Mathlib's FintypeCat as code,\nwhere an erased type former is passed to a polymorphic function. We were\nlowering the arrow type toobject, which conflicts with the runtime\nrepresentation of an erased value as a tagged scalar.* #9977 adds support for compilation of casesOn recursors of\nsubsingleton predicates.* #10023 adds support for correctly handling computations on fields in\ncasesOn for inductive predicates that support large elimination. In\nany such predicate, the only relevant fields allowed are those that are\nalso used as an index, in which case we can find the supplied index and\nuse that term instead.* #10032 changes the handling of overapplied constructors when lowering\nLCNF to IR from a (slightly implicit) assertion failure to producing\nunreachable. Transformations on inlined unreachable code can produce\nconstructor applications with additional arguments.* #10040 changes the toMono pass to replace decls with their _redArg\nequivalent, which has the consequence of not considering arguments\ndeemed useless by the reduceArity pass for the purposes of the\nnoncomputable check.* #10070 fixes the compilation of noConfusion by repairing an oversight\nmade when porting this code from the old compiler. The old compiler only\nrepeatedly expanded the major for each non-Prop field of the inductive\nunder consideration, mirroring the construction of noConfusion itself,\nwhereas the new compiler erroneously counted all fields.* #10133 fixes compatibility of Lean-generated executables with Unicode\nfile system paths on Windows* #10214 fixes #10213.* #10256 corrects a mistake in toIR where it could over-apply a\nfunction that has an IR decl but no mono decl.* #10355 changes toLCNF to convert .proj for builtin types to use\nprojection functions instead.Pretty Printing* #10122 adds support for pretty printing using generalized field\nnotation (dot notation) for private definitions on public types. It also\nmodifies dot notation elaboration to resolve names after removing the\nprivate prefix, which enables using dot notation for private definitions\non private imported types.* #10373 adds a pp.unicode option and a unicode(\"→\", \"->\") syntax\ndescription alias for the lower-level unicodeSymbol \"→\" \"->\" parser.\nThe syntax is added to the notation command as well. When pp.unicode\nis true (the default) then the first form is used when pretty printing,\nand otherwise the second ASCII form is used. A variant, unicode(\"→\", \"->\", preserveForPP) causes the -> form to be preferred; delaborators\ncan insert → directly into the syntax, which will be pretty printed\nas-is; this allows notations like fun to use custom options such as\npp.unicode.fun to opt into the unicode form when pretty printing.* #10374 adds the options pp.piBinderNames and\npp.piBinderNames.hygienic. Enabling pp.piBinderNames causes\nnon-dependent pi binder names to be pretty printed, rather than be\nomitted. When pp.piBinderNames.hygienic is false (the default) then\nonly non-hygienic such biner names are pretty printed. Setting pp.all\nenables pp.piBinderNames if it is not otherwise explicitly set.Documentation* #9956 adds additional information to the let and have tactic\ndocstrings about opaqueness, when to use each, and associated tactics.Server* #9966 adjusts the \"try this\" widget to be rendered as a widget message\nunder 'Messages', not a separate widget under a 'Suggestions' section.\nThe main benefit of this is that the message of the widget is not\nduplicated between 'Messages' and 'Suggestions'.* #10047 ensures that hovering over match displays the type of the\nmatch.* #10052 fixes a bug that caused the Lean server process tree to survive\nthe closing of VS Code.* #10249 speeds up auto-completion by a factor of ~3.5x through various\nperformance improvements in the language server. On one machine, with\nimport Mathlib, completing i used to take 3200ms and now instead\nyields a result in 920ms.Lake* #9749 refactors the Lake codebase to use the new module system\nthroughout. Every module in Lake is now a module.* #10276 moves the verLit syntax into the Lake.DSL namespace to be\nconsistent with other code found in Lake.DSL.Other* #10043 allows Lean's parser to run with a final position prior to the\nend of the string, so it can be invoked on a sub-region of the input.* #10217 ensures @[init] declarations such as from initialize are run\nin the order they were declared on import.* #10262 adds a new option maxErrors that limits the number of errors\nprinted from a single lean run, defaulting to 100. Processing is\naborted when the limit is reached, but this is tracked only on a\nper-command level.\n\n","context":"Lean Reference\u0009Release Notes","header":"Lean 4.24.0-rc1 (2025-09-15)","id":"/releases/v4.24.0/#release-v4___24___0"}});