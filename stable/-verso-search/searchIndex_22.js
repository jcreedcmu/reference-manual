window.docContents[22].resolve({"/The-Type-System/Inductive-Types/#recursor-types":{"id":"/The-Type-System/Inductive-Types/#recursor-types","header":"4.4.3.1.1. Recursor Types","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Logical Model\u0009Recursors","contents":"The recursor takes the following parameters: The inductive type's parameters\n\nBecause parameters are consistent, they can be abstracted over the entire recursor.\n\n The motive\n\nThe motive determines the type of an application of the recursor. The motive is a function whose arguments are the type's indices and an instance of the type with these indices instantiated. The specific universe for the type that the motive determines depends on the inductive type's universe and the specific constructors—see the section on subsingleton elimination for details.\n\n A minor premise for each constructor\n\nFor each constructor, the recursor expects a function that satisfies the motive for an arbitrary application of the constructor.\n  Each minor premise abstracts over all of the constructor's parameters.\n  If the constructor's parameter's type is the inductive type itself, then the minor premise additionally takes a parameter whose type is the motive applied to that parameter's value—this will receive the result of recursively processing the recursive parameter.\n\n The major premise, or target\n\nFinally, the recursor takes an instance of the type as an argument, along with any index values.\n\nThe result type of the recursor is the motive applied to these indices and the major premise.\n\nThe recursor for BoolBool's recursor Bool.rec has the following parameters:* The motive computes a type in any universe, given a Bool.* There are minor premises for both constructors, in which the motive is satisfied for both false and true.* The major premise is some Bool.The return type is the motive applied to the major premise.Bool.rec.{u} {motive : Bool → Sort u}\n  (false : motive false)\n  (true : motive true)\n  (t : Bool) : motive t\n\n\nThe recursor for ListList's recursor List.rec has the following parameters:* The parameter α comes first, because the motive, minor premises, and major premise need to refer to it.* The motive computes a type in any universe, given a List α. There is no connection between the universe levels u and v.* There are minor premises for both constructors:* The motive is satisfied for List.nil* The motive should be satisfiable for any application of List.cons, given that it is satisfiable for the tail. The extra parameter motive tail is because tail's type is a recursive occurrence of List.* The major premise is some List α.Once again, the return type is the motive applied to the major premise.List.rec.{u, v} {α : Type v} {motive : List α → Sort u}\n  (nil : motive [])\n  (cons : (head : α) → (tail : List α) → motive tail →\n    motive (head :: tail))\n  (t : List α) : motive t\n\n\nRecursor with parameters and indicesGiven the definition of EvenOddList:inductive EvenOddList (α : Type u) : Bool → Type u where\n  | nil : EvenOddList α true\n  | cons : α → EvenOddList α isEven → EvenOddList α (not isEven)\nThe recursor EvenOddList.rec is very similar to that for List.\nThe difference comes from the presence of the index:* The motive now abstracts over any arbitrary choice of index.* The minor premise for nil applies the motive to nil's index value true.* The minor premise cons abstracts over the index value used in its recursive occurrence, and instantiates the motive with its negation.* The major premise additionally abstracts over an arbitrary choice of index.EvenOddList.rec.{u, v} {α : Type v}\n  {motive : (isEven : Bool) → EvenOddList α isEven → Sort u}\n  (nil : motive true EvenOddList.nil)\n  (cons : {isEven : Bool} →\n    (head : α) →\n    (tail : EvenOddList α isEven) → motive isEven tail →\n    motive (!isEven) (EvenOddList.cons head tail)) :\n  {isEven : Bool} → (t : EvenOddList α isEven) → motive isEven t\n\n\nWhen using a predicate (that is, a function that returns a Prop) for the motive, recursors express induction.\nThe minor premises for non-recursive constructors are the base cases, and the additional arguments supplied to minor premises for constructors with recursive arguments are the induction hypotheses.\n\n\n\n"},"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-default":{"id":"/Build-Tools-and-Distribution/Managing-Toolchains-with-Elan/#elan-default","header":"22.2.3.2. Setting the Default Toolchain","context":"Lean Reference\u0009Build Tools\u0009Elan\u0009Command-Line Interface","contents":"Elan's configuration file specifies a default toolchain to be used when there is no lean-toolchain file or toolchain override for the current directory.\nRather than manually editing the file, this value is typically changed using the default command.\n\n\n\nSets the default toolchain to toolchain, which should be a valid toolchain identifier such as stable, nightly, or 4.17.0.\n\n"},"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Bitwise-Operators":{"id":"/Basic-Types/Integers/#The-Lean-Language-Reference--Basic-Types--Integers--API-Reference--Bitwise-Operators","header":"19.2.4.4. Bitwise Operators","context":"Lean Reference\u0009Basic Types\u0009Integers\u0009API Reference","contents":"Bitwise operators on Int can be understood as bitwise operators on an infinite stream of bits that are the twos-complement representation of integers.\n\nBitwise not, usually accessed via the ~~~ prefix operator.Interprets the integer as an infinite sequence of bits in two's complement and complements each bit.Examples:* ~~~(0 : Int) = -1* ~~~(1 : Int) = -2* ~~~(-1 : Int) = 0\n\nBitwise right shift, usually accessed via the >>> operator.Interprets the integer as an infinite sequence of bits in two's complement and shifts the value to\nthe right.Examples:* ( 0b0111 : Int) >>> 1 =  0b0011* ( 0b1000 : Int) >>> 1 =  0b0100* (-0b1000 : Int) >>> 1 = -0b0100* (-0b0111 : Int) >>> 1 = -0b0100\n\n"}});