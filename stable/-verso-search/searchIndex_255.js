window.docContents[255].resolve({"/Notations-and-Macros/Notations/#notations":{"id":"/Notations-and-Macros/Notations/#notations","header":"20.3. Notations","context":"Lean Reference\u0009Notations and Macros","contents":"The term notation is used in two ways in Lean: it can refer to the general concept of concise ways of writing down ideas, and it is the name of a language feature that allows notations to be conveniently implemented with little code.\nLike custom operators, Lean notations allow the grammar of terms to be extended with new forms.\nHowever, notations are more general: the new syntax may freely intermix required keywords or operators with subterms, and they provide more precise control over precedence levels.\nNotations may also rearrange their parameters in the resulting subterms, while infix operators provide them to the function term in a fixed order.\nBecause notations may define operators that use a mix of prefix, infix, and postfix components, they can be called mixfix operators.\n\nNotation DeclarationsNotations are defined using the notation command.\n\nNotation ItemsThe body of a notation definition consists of a sequence of notation items, which may be either string literals or identifiers with optional precedences.\n\nAs with operator declarations, the contents of the documentation comments are shown to users while they interact with the new syntax.\nAdding the inherit_doc attribute causes the documentation comment of the function at the head of the term into which the notation expands to be copied to the new syntax.\nOther attributes may be added to invoke other compile-time metaprograms on the resulting definition.\n\nNotations interact with section scopes in the same manner as attributes and operators.\nBy default, notations are available in any module that transitively imports the one in which they are established, but they may be declared scoped or local to restrict their availability either to contexts in which the current namespace has been opened or to the current section scope, respectively.\n\nLike operators, the local longest-match rule is used while parsing notations.\nIf more than one notation ties for the longest match, the declared priorities are used to determine which parse result applies.\nIf this still does not resolve the ambiguity, then all are saved, and the elaborator is expected to attempt all of them, succeeding when exactly one can be elaborated.\n\nRather than a single operator with its fixity and token, the body of a notation declaration consists of a sequence of notation items, which may be either new atoms (including both keywords such as if, #eval, or where and symbols such as =>, +, ↗, ⟦, or ⋉) or positions for terms.\nJust as they do in operators, string literals identify the placement of atoms.\nLeading and trailing spaces in the strings do not affect parsing, but they cause Lean to insert spaces in the corresponding position when displaying the syntax in proof states and error messages.\nIdentifiers indicate positions where terms are expected, and name the corresponding term so it can be inserted in the notation's expansion.\n\nWhile custom operators have a single notion of precedence, there are many involved in a notation.\nThe notation itself has a precedence, as does each term to be parsed.\nThe notation's precedence determines which contexts it may be parsed in: the parser only attempts to parse productions whose precedence is at least as high as the current context.\nFor example, because multiplication has higher precedence than addition, the parser will attempt to parse an infix multiplication term while parsing the arguments to addition, but not vice versa.\nThe precedence of each term to be parsed determines which other productions may occur in them.\n\nIf no precedence is supplied for the notation itself, the default value depends on the form of the notation.\nIf the notation both begins and ends with an atom (represented by string literals), then the default precedence is max.\nThis applies both to notations that consist only of a single atom and to notations with multiple items, in which the first and last items are both atoms.\nOtherwise, the default precedence of the whole notation is lead.\nIf no precedence is provided for notation items that are terms, then they default to precedence min.\n\n\n\nAfter the required double arrow (=>), the notation is provided with an expansion.\nWhile operators are always expanded by applying their function to the operator's arguments in order, notations may place their term items in any position in the expansion.\nThe terms are referred to by name.\nTerm items may occur any number of times in the expansion.\nBecause notation expansion is a purely syntactic process that occurs prior to elaboration or code generation, duplicating terms in the expansion may lead to duplicated computation when the resulting term is evaluated, or even duplicated side effects when working in a monad.\n\nIgnored Terms in Notation ExpansionThis notation ignores its first parameter:notation (name := ignore) \"ignore \" _ign:arg e:arg => e\nThe term in the ignored position is discarded, and Lean never attempts to elaborate it, so terms that would otherwise result in errors can be used here:#eval ignore (2 + \"whatever\") 5\n5\nHowever, the ignored term must still be syntactically valid:#eval ignore (2 +) 5\n<example>:1:17-1:18: unexpected token ')'; expected term\n\n\nDuplicated Terms in Notation ExpansionThe dup! notation duplicates its sub-term.notation (name := dup) \"dup!\" t:arg => (t, t)\nBecause the term is duplicated, it can be elaborated separately with different types:def e : Nat × Int := dup! (2 + 2)\nPrinting the resulting definition demonstrates that the work of addition will be performed twice:#print e\ndef e : Nat × Int :=\n(2 + 2, 2 + 2)\n\n\nWhen the expansion consists of the application of a function defined in the global environment and each term in the notation occurs exactly once, an unexpander is generated.\nThe new notation will be displayed in proof states, error messages, and other output from Lean when matching function application terms otherwise would have been displayed.\nAs with custom operators, Lean does not track whether the notation was used in the original term; it is used at every opportunity in Lean's output.\n\n\n\n"},"/IO/Logical-Model/#io-monad-errors":{"id":"/IO/Logical-Model/#io-monad-errors","header":"15.1.2. Errors and Error Handling in  IO","context":"Lean Reference\u0009IO\u0009Logical Model","contents":"Error handling in the IO monad uses the same facilities as any other exception monad.\nIn particular, throwing and catching exceptions uses the methods of the MonadExceptOf type class.\nThe exceptions thrown in IO have the type IO.Error.\nThe constructors of this type represent the low-level errors that occur on most operating systems, such as files not existing.\nThe most-used constructor is userError, which covers all other cases and includes a string that describes the problem.\n\nExceptions that may be thrown in the IO monad.Many of the constructors of IO.Error correspond to POSIX error numbers. In these cases, the\ndocumentation string lists POSIX standard error macros that correspond to the error. This list is\nnot necessarily exhaustive, and these constructor includes a field for the underlying error number.The operation failed because a file already exists.This corresponds to POSIX errors EEXIST, EINPROGRESS, and EISCONN.Some error not covered by the other constructors of IO.Error occurred.This also includes POSIX error EFAULT.A necessary resource was busy.This corresponds to POSIX errors EADDRINUSE, EBUSY, EDEADLK, and ETXTBSY.A necessary resource is no longer available.This corresponds to POSIX errors ECONNRESET, EIDRM, ENETDOWN, ENETRESET, ENOLINK, and\nEPIPE.An operation was not supported.This corresponds to POSIX errors EADDRNOTAVAIL, EAFNOSUPPORT, ENODEV, ENOPROTOOPT\nENOSYS, EOPNOTSUPP, ERANGE, ESPIPE, and EXDEV.The operation failed due to a hardware problem, such as an I/O error.This corresponds to the POSIX error EIO.A constraint required by an operation was not satisfied (e.g. a directory was not empty).This corresponds to the POSIX error ENOTEMPTY.An inappropriate I/O control operation was attempted.This corresponds to the POSIX error ENOTTY.A protocol error occurred.This corresponds to the POSIX errors EPROTO, EPROTONOSUPPORT, and EPROTOTYPE.An operation timed out.This corresponds to the POSIX errors ETIME, and ETIMEDOUT.The operation was interrupted.This corresponds to the POSIX error EINTR.No such file or directory.This corresponds to the POSIX error ENOENT.An argument to an I/O operation was invalid.This corresponds to the POSIX errors ELOOP, ENAMETOOLONG, EDESTADDRREQ, EILSEQ, EINVAL, EDOM, EBADF\nENOEXEC, ENOSTR, ENOTCONN, and ENOTSOCK.An operation failed due to insufficient permissions.This corresponds to the POSIX errors EACCES, EROFS, ECONNABORTED, EFBIG, and EPERM.A resource was exhausted.This corresponds to the POSIX errors  EMFILE, ENFILE, ENOSPC, E2BIG, EAGAIN, EMLINK,\nEMSGSIZE, ENOBUFS, ENOLCK, ENOMEM, and ENOSR.An argument was the wrong type (e.g. a directory when a file was required).This corresponds to the POSIX errors EISDIR, EBADMSG, and ENOTDIR.A required resource does not exist.This corresponds to the POSIX errors ENXIO, EHOSTUNREACH, ENETUNREACH, ECHILD,\nECONNREFUSED, ENODATA, ENOMSG, and ESRCH.An unexpected end-of-file marker was encountered.Some other error occurred.\n\nConverts an IO.Error to a descriptive string.IO.Error.userError is converted to its embedded message. The other constructors are converted in a\nway that preserves structured information, such as error codes and filenames, that can help\ndiagnose the issue.\n\nConverts an Except ε action into an IO action.If the Except ε action throws an exception, then the exception type's ToString instance is used\nto convert it into an IO.Error, which is thrown. Otherwise, the value is returned.\n\nHandles any exception that might be thrown by an EIO ε action, transforming it into an\nexception-free BaseIO action.\n\nConstructs an IO.Error from a string.IO.Error is the type of exceptions thrown by the IO monad.\n\nThrowing and Catching ErrorsThis program repeatedly demands a password, using exceptions for control flow.\nThe syntax used for exceptions is available in all exception monads, not just IO.\nWhen an incorrect password is provided, an exception is thrown, which is caught by the loop that repeats the password check.\nA correct password allows control to proceed past the check, terminating the loop, and any other exceptions are re-thrown.def accessControl : IO Unit := do\n  IO.println \"What is the password?\"\n  let password ← (← IO.getStdin).getLine\n  if password.trim != \"secret\" then\n    throw (.userError \"Incorrect password\")\n  else return\n\ndef repeatAccessControl : IO Unit := do\n  repeat\n    try\n      accessControl\n      break\n    catch\n      | .userError \"Incorrect password\" =>\n        continue\n      | other =>\n        throw other\n\ndef main : IO Unit := do\n  repeatAccessControl\n  IO.println \"Access granted!\"\nWhen run with this input:publicinfo\nsecondtry\nsecret\nthe program emits:What is the password?\nWhat is the password?\nWhat is the password?\nAccess granted!\n\n\n"},"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Rounding":{"id":"/Basic-Types/Floating-Point-Numbers/#The-Lean-Language-Reference--Basic-Types--Floating-Point-Numbers--API-Reference--Rounding","header":"19.6.2.8. Rounding","context":"Lean Reference\u0009Basic Types\u0009Floating-Point Numbers\u0009API Reference","contents":"Rounds to the nearest integer, rounding away from zero at half-way points.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nround.\n\nRounds to the nearest integer, rounding away from zero at half-way points.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nroundf.\n\nComputes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfloor.Examples:* Float.floor 1.5 = 1* Float.floor (-1.5) = (-2)\n\nComputes the floor of a floating-point number, which is the largest integer that's no larger\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nfloorf.Examples:* Float32.floor 1.5 = 1* Float32.floor (-1.5) = (-2)\n\nComputes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nceil.Examples:* Float.ceil 1.5 = 2* Float.ceil (-1.5) = (-1)\n\nComputes the ceiling of a floating-point number, which is the smallest integer that's no smaller\nthan the given number.This function does not reduce in the kernel. It is implemented in compiled code by the C function\nceilf.Examples:* Float32.ceil 1.5 = 2* Float32.ceil (-1.5) = (-1)\n\n"}});