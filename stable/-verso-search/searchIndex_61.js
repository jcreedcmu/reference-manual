window.docContents[61].resolve({"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference":{"contents":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values","header":"19.12.2. API Reference","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference"},"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning":{"contents":"An optional arbitrary element of a given type.If α is non-empty, then there exists some v : α and this arbitrary element is some v.\nOtherwise, it is none.\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.bind.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pbind fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven an optional value and a function that can be applied when the value is some, returns the\nresult of applying the function if this is possible, or a fallback value otherwise.The function f is partial because it is only defined for the values a : α such that\no = some a. This restriction allows the function to use the fact that it can only be called when\no is not none: it can relate its argument to the optional value o. Its runtime behavior is\nequivalent to that of Option.elim.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pelim none fun x h => some ⟨x, h⟩\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\nGiven a function from the elements of α that satisfy p to β and a proof that an optional value\nsatisfies p if it's present, applies the function to the value.Examples:def attach (v : Option α) : Option { y : α // v = some y } :=\n  v.pmap (fun a (h : a ∈ v) => ⟨_, h⟩) (fun _ h => h)\n#reduce attach (some 3)\nsome ⟨3, ⋯⟩\n#reduce attach none\nnone\n\n\n","context":"Lean Reference\u0009Basic Types\u0009Optional Values\u0009API Reference","header":"19.12.2.7. Reasoning","id":"/Basic-Types/Optional-Values/#The-Lean-Language-Reference--Basic-Types--Optional-Values--API-Reference--Reasoning"},"/IO/Timing/#io-timing":{"contents":"Pauses execution for the specified number of milliseconds.\n\nMonotonically increasing time since an unspecified past point in nanoseconds. There is no relation\nto wall clock time.\n\nMonotonically increasing time since an unspecified past point in milliseconds. There is no relation\nto wall clock time.\n\nReturns the number of heartbeats that have occurred during the current thread's execution. The\nheartbeat count is the number of “small” memory allocations performed in a thread.Heartbeats used to implement timeouts that are more deterministic across different hardware.\n\nAdjusts the heartbeat counter of the current thread by the given amount. This can be useful to give\nallocation-avoiding code additional “weight” and is also used to adjust the counter after resuming\nfrom a snapshot.Heartbeats are a means of implementing “deterministic” timeouts. The heartbeat counter is the number\nof “small” memory allocations performed on the current execution thread.\n\n","context":"Lean Reference\u0009IO","header":"15.8. Timing","id":"/IO/Timing/#io-timing"},"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays":{"contents":"List and array literals contain comma-separated sequences of elements inside of brackets, with arrays prefixed by a hash mark (#).\nArray literals are interpreted as list literals wrapped in a call to a conversion.\nFor performance reasons, very large list and array literals are converted to sequences of local definitions, rather than just iterated applications of the list constructor.\n\nList Literals\n\nArray Literals\n\nLong List LiteralsThis list contains 32 elements.\nThe generated code is an iterated application of List.cons:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1]\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] : List Nat\nWith 33 elements, the list literal becomes a sequence of local definitions:#check\n  [1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1,1,1,1,1,1,1,1,\n   1]\nlet y :=\n  let y :=\n    let y := [1, 1, 1, 1, 1];\n    1 :: 1 :: 1 :: 1 :: y;\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y :=\n  let y := 1 :: 1 :: 1 :: 1 :: y;\n  1 :: 1 :: 1 :: 1 :: y;\nlet y := 1 :: 1 :: 1 :: 1 :: y;\n1 :: 1 :: 1 :: 1 :: y : List Nat\n\n\n","context":"Lean Reference\u0009Terms\u0009Numeric Literals","header":"10.5.4. Lists and Arrays","id":"/Terms/Numeric-Literals/#The-Lean-Language-Reference--Terms--Numeric-Literals--Lists-and-Arrays"}});