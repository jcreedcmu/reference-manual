window.docContents[37].resolve({"/The-Type-System/Quotients/#quotients-nested-inductives":{"id":"/The-Type-System/Quotients/#quotients-nested-inductives","header":"4.5.5.2. Quotients and Inductive Types","context":"Lean Reference\u0009Type System\u0009Quotients\u0009Logical Model","contents":"Because Quot is not an inductive type, types implemented as quotients may not occur around nested occurrences in inductive type declarations.\nThese types declarations must be rewritten to remove the nested quotient, which can often be done by defining a quotient-free version and then separately defining an equivalence relation that implements the desired equality relation.\n\nNested Inductive Types and QuotientsThe nested inductive type of rose trees nests the recursive occurrence of RoseTree under List:inductive RoseTree (α : Type u) where\n  | leaf : α → RoseTree α\n  | branch : List (RoseTree α) → RoseTree α\nHowever, taking a quotient of the List that identifies all elements in the style of squash types causes Lean to reject the declaration:inductive SetTree (α : Type u) where\n  | leaf : α → SetTree α\n  | branch :\n    Quot (fun (xs ys : List (SetTree α)) => True) →\n    SetTree α\n(kernel) arg #2 of 'SetTree.branch' contains a non valid occurrence of the datatypes being declared\n\n\n"},"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nested":{"id":"/Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-nested","header":"13.6.5. Nested Tactics","context":"Lean Reference\u0009Tactic Proofs\u0009Targeted Rewriting with  conv","contents":"Executes the given conv block without converting regular goal into a conv goal.\n\nFocuses, converts the conv goal ⊢ lhs into a regular goal ⊢ lhs = rhs, and then executes the given tactic block.\n\nExecutes the given tactic block without converting conv goal into a regular goal.\n\nExecutes the given conv block without converting regular goal into a conv goal.\n\nconv => cs runs cs in sequence on the target t,\nresulting in t', which becomes the new target subgoal.\n\n"},"/Introduction/#dependency-licenses":{"id":"/Introduction/#dependency-licenses","header":"Open-Source Licenses","context":"Lean Reference\u0009Introduction","contents":"\n\n"},"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Re-Ordered-Operations":{"id":"/Functors___-Monads-and--do--Notation/API-Reference/#The-Lean-Language-Reference--Functors___-Monads-and--do--Notation--API-Reference--Re-Ordered-Operations","header":"14.4.5. Re-Ordered Operations","context":"Lean Reference\u0009Functors, Monads and  do -Notation\u0009API Reference","contents":"Sometimes, it can be convenient to partially apply a function to its second argument.\nThese functions reverse the order of arguments, making it this easier.\n\nMaps a function over a functor, with parameters swapped so that the function comes last.This function is Functor.map with the parameters reversed, typically used via the <&> operator.Conventions for notations in identifiers:* The recommended spelling of <&> in identifiers is mapRev.\n\nSame as Bind.bind but with arguments swapped.Conventions for notations in identifiers:* The recommended spelling of =<< in identifiers is bindLeft.\n\n"},"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic":{"id":"/Basic-Types/Bitvectors/#The-Lean-Language-Reference--Basic-Types--Bitvectors--API-Reference--Arithmetic","header":"19.5.5.8. Arithmetic","context":"Lean Reference\u0009Basic Types\u0009Bitvectors\u0009API Reference","contents":"These operators treat bitvectors as numbers.\nSome operations are signed, while others are unsigned.\nBecause bitvectors are understood as two's complement numbers, addition, subtraction and multiplication coincide for the signed and unsigned interpretations.\n\nAdds two bitvectors. This can be interpreted as either signed or unsigned addition modulo 2^n.\nUsually accessed via the + operator.SMT-LIB name: bvadd.\n\nSubtracts one bitvector from another. This can be interpreted as either signed or unsigned subtraction\nmodulo 2^n. Usually accessed via the - operator.\n\nMultiplies two bitvectors. This can be interpreted as either signed or unsigned multiplication\nmodulo 2^n. Usually accessed via the * operator.SMT-LIB name: bvmul.\n\n\n\n\n\n"}});