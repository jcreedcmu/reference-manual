window.docContents[194].resolve({"/releases/v4.3.0/#release-v4___3___0":{"id":"/releases/v4.3.0/#release-v4___3___0","header":"Lean 4.3.0 (2023-11-30)","context":"Lean Reference\u0009Release Notes","contents":"* simp [f] does not unfold partial applications of f anymore. See issue #2042.\nTo fix proofs affected by this change, use unfold f or simp (config := { unfoldPartialApp := true }) [f].* By default, simp will no longer try to use Decidable instances to rewrite terms. In particular, not all decidable goals will be closed by simp, and the decide tactic may be useful in such cases. The decide simp configuration option can be used to locally restore the old simp behavior, as in simp (config := {decide := true}); this includes using Decidable instances to verify side goals such as numeric inequalities.* Many bug fixes:* Add left/right actions to term tree coercion elaborator and make `^`` a right action* Fix for #2775, don't catch max recursion depth errors* Reduction of Decidable instances very slow when using cases tactic* simp not rewriting in binder* simp unfolding let even with zeta := false option* simp (with beta/zeta disabled) and discrimination trees* unknown free variable introduced by rw ... at h* dsimp doesn't use rfl theorems which consist of an unapplied constant* dsimp does not close reflexive equality goals if they are wrapped in metadata* rw [h] uses h from the environment in preference to h from the local context* missing withAssignableSyntheticOpaque for assumption tactic* ignoring default value for field warning* Cancel outstanding tasks on document edit in the language server.* Remove unnecessary % operations in Fin.mod and Fin.div* Avoid DecidableEq in Array.mem* Ensure USize.size unifies with ?m + 1* Improve compatibility with emacs eglot clientLake:* Sensible defaults for lake new MyProject math* Changed postUpdate? configuration option to a post_update declaration. See the post_update syntax docstring for more information on the new syntax.* A manifest is automatically created on workspace load if one does not exists..* The := syntax for configuration declarations (i.e., package, lean_lib, and lean_exe) has been deprecated. For example, package foo := {...} is deprecated.* support for overriding package URLs via LAKE_PKG_URL_MAP* Moved the default build directory (e.g., build), default packages directory (e.g., lake-packages), and the compiled configuration (e.g., lakefile.olean) into a new dedicated directory for Lake outputs, .lake. The cloud release build archives are also stored here, fixing #2713.* Update manifest format to version 7 (see lean4#2801 for details on the changes).* Deprecate the manifestFile field of a package configuration.* There is now a more rigorous check on lakefile.olean compatibility (see #2842 for more details).\n\n"},"/The-Type-System/Inductive-Types/#mutual-inductive-types-positivity":{"id":"/The-Type-System/Inductive-Types/#mutual-inductive-types-positivity","header":"4.4.5.1.4. Positivity","context":"Lean Reference\u0009Type System\u0009Inductive Types\u0009Mutual Inductive Types\u0009Requirements","contents":"Each inductive type that is defined in the mutual group may occur only strictly positively in the types of the parameters of the constructors of all the types in the group.\nIn other words, in the type of each parameter to each constructor in all the types of the group, none of the type constructors in the group occur to the left of any arrows, and none of them occur in argument positions unless they are an argument to an inductive type's type constructor.\n\nMutual strict positivityIn the following mutual group, Tm occurs in a negative position in the argument to Binding.scope:mutual\n  inductive Tm where\n    | app : Tm → Tm → Tm\n    | lam : Binding → Tm\n  inductive Binding where\n    | scope : (Tm → Tm) → Binding\nend\nBecause Tm is part of the same mutual group, it must occur only strictly positively in the arguments to the constructors of Binding.\nIt occurs, however, negatively:(kernel) arg #1 of 'Binding.scope' has a non positive occurrence of the datatypes being declared\n\n\nNested positionsThe definitions of LocatedStx and Stx satisfy the positivity condition because the recursive occurrences are not to the left of any arrows and, when they are arguments, they are arguments to inductive type constructors.mutual\n  inductive LocatedStx where\n    | mk (line col : Nat) (val : Stx)\n  inductive Stx where\n    | atom (str : String)\n    | node (kind : String) (args : List LocatedStx)\nend\n\n\n"}});